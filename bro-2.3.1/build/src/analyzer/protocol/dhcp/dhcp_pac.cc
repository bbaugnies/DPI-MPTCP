// This file is automatically generated from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dhcp/dhcp.pac.


#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include "/home/benjamin/Bro/bro-2.3.1/build/src/analyzer/protocol/dhcp/dhcp_pac.h"

namespace binpac {






namespace DHCP {
ContextDHCP::ContextDHCP(DHCP_Conn * connection, DHCP_Flow * flow)
	{
	connection_ = connection;
	flow_ = flow;
	}

ContextDHCP::~ContextDHCP()
	{
	}

Option_Info::Option_Info(uint8 code)
	{
	length_ = 0;
	value_case_index_ = -1;
	mask_ = 0;
	router_list_ = 0;
	router_list__elem_ = 0;
	req_addr_ = 0;
	lease_ = 0;
	msg_type_ = 0;
	serv_addr_ = 0;
	code_ = code;
	}

Option_Info::~Option_Info()
	{
	switch ( value_case_index() )
		{
		case 1:
			// Clean up "mask"
			{
			}
			break;
		case 3:
			// Clean up "router_list"
			{
			delete router_list_;
			}
			break;
		case 50:
			// Clean up "req_addr"
			{
			}
			break;
		case 51:
			// Clean up "lease"
			{
			}
			break;
		case 53:
			// Clean up "msg_type"
			{
			}
			break;
		case 54:
			// Clean up "serv_addr"
			{
			}
			break;
		case 12:
			// Clean up "host_name"
			{
			host_name_.free();
			}
			break;
		default:
			// Clean up "other"
			{
			other_.free();
			}
			break;
		}
	}

int Option_Info::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "Option_Info:length"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Option_Info:length",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	int t_value__size;
	value_case_index_ = code();
	switch ( value_case_index() )
		{
		case 1:
			// Parse "mask"
			{
			// Checking out-of-bound for "Option_Info:mask"
			if ( (t_begin_of_data + 1) + (4) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Option_Info:mask",
					(1) + (4), 
					(t_end_of_data) - (t_begin_of_data));
				}
			mask_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 1))));
			// Evaluate 'let' and 'withinput' fields
			t_value__size = 4;
			}
			break;
		case 3:
			// Parse "router_list"
			{
			int t_router_list__arraylength;
			t_router_list__arraylength = 0;
			t_router_list__arraylength = length() / 4;
			if ( t_begin_of_data + t_router_list__arraylength > t_end_of_data + 1 )
				{
				t_router_list__arraylength = t_end_of_data - t_begin_of_data + 1;
				}
			if ( t_router_list__arraylength < 0 )
				{
				t_router_list__arraylength = 0;
				}
			router_list__elem_ = 0;
			int t_router_list__elem__it;
			t_router_list__elem__it = 0;
			int t_router_list__size;
			router_list_ = new vector<uint32>;
			router_list_->reserve(t_router_list__arraylength);
			const_byteptr t_router_list__elem__dataptr = (t_begin_of_data + 1);
			for (; t_router_list__elem__it < t_router_list__arraylength; ++t_router_list__elem__it)
				{
				// Check &until(router_list__elem__dataptr >= end_of_data)
				if ( t_router_list__elem__dataptr >= t_end_of_data )
					{
					goto end_of_router_list;
					}
				// Checking out-of-bound for "Option_Info:router_list__elem"
				if ( t_router_list__elem__dataptr + (4) > t_end_of_data )
					{
					// Handle out-of-bound condition
					throw binpac::ExceptionOutOfBound("Option_Info:router_list__elem",
						((t_router_list__elem__dataptr - t_begin_of_data)) + (4), 
						(t_end_of_data) - (t_begin_of_data));
					}
				router_list__elem_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_router_list__elem__dataptr)));
				// Evaluate 'let' and 'withinput' fields
				router_list_->push_back(router_list__elem_);
				t_router_list__elem__dataptr += 4;
				BINPAC_ASSERT(t_router_list__elem__dataptr <= t_end_of_data);
				}
		end_of_router_list: ;
			t_router_list__size = t_router_list__elem__dataptr - ((t_begin_of_data + 1));
			// Evaluate 'let' and 'withinput' fields
			t_value__size = t_router_list__size;
			}
			break;
		case 50:
			// Parse "req_addr"
			{
			// Checking out-of-bound for "Option_Info:req_addr"
			if ( (t_begin_of_data + 1) + (4) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Option_Info:req_addr",
					(1) + (4), 
					(t_end_of_data) - (t_begin_of_data));
				}
			req_addr_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 1))));
			// Evaluate 'let' and 'withinput' fields
			t_value__size = 4;
			}
			break;
		case 51:
			// Parse "lease"
			{
			// Checking out-of-bound for "Option_Info:lease"
			if ( (t_begin_of_data + 1) + (4) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Option_Info:lease",
					(1) + (4), 
					(t_end_of_data) - (t_begin_of_data));
				}
			lease_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 1))));
			// Evaluate 'let' and 'withinput' fields
			t_value__size = 4;
			}
			break;
		case 53:
			// Parse "msg_type"
			{
			// Checking out-of-bound for "Option_Info:msg_type"
			if ( (t_begin_of_data + 1) + (1) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Option_Info:msg_type",
					(1) + (1), 
					(t_end_of_data) - (t_begin_of_data));
				}
			msg_type_ = *((uint8 const *) ((t_begin_of_data + 1)));
			// Evaluate 'let' and 'withinput' fields
			t_value__size = 1;
			}
			break;
		case 54:
			// Parse "serv_addr"
			{
			// Checking out-of-bound for "Option_Info:serv_addr"
			if ( (t_begin_of_data + 1) + (4) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Option_Info:serv_addr",
					(1) + (4), 
					(t_end_of_data) - (t_begin_of_data));
				}
			serv_addr_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 1))));
			// Evaluate 'let' and 'withinput' fields
			t_value__size = 4;
			}
			break;
		case 12:
			// Parse "host_name"
			{
			int t_host_name__size;
			t_host_name__size = length();
			// Checking out-of-bound for "Option_Info:host_name"
			if ( (t_begin_of_data + 1) + (t_host_name__size) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Option_Info:host_name",
					(1) + (t_host_name__size), 
					(t_end_of_data) - (t_begin_of_data));
				}
			{
			// Setting t_end_of_data with &length
			const_byteptr t_end_of_data = (t_begin_of_data + 1) + t_host_name__size;
			int t_host_name_string_length;
			t_host_name_string_length = length();
			// check for negative sizes
			if ( t_host_name_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dhcp/dhcp-protocol.pac:44", t_host_name_string_length);
			host_name_.init((t_begin_of_data + 1), t_host_name_string_length);
			// Evaluate 'let' and 'withinput' fields
			}
			t_value__size = t_host_name__size;
			}
			break;
		default:
			// Parse "other"
			{
			int t_other__size;
			t_other__size = length();
			// Checking out-of-bound for "Option_Info:other"
			if ( (t_begin_of_data + 1) + (t_other__size) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Option_Info:other",
					(1) + (t_other__size), 
					(t_end_of_data) - (t_begin_of_data));
				}
			{
			// Setting t_end_of_data with &length
			const_byteptr t_end_of_data = (t_begin_of_data + 1) + t_other__size;
			int t_other_string_length;
			t_other_string_length = length();
			// check for negative sizes
			if ( t_other_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dhcp/dhcp-protocol.pac:45", t_other_string_length);
			other_.init((t_begin_of_data + 1), t_other_string_length);
			// Evaluate 'let' and 'withinput' fields
			}
			t_value__size = t_other__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_Option_Info__size;
	const_byteptr const t_dataptr_after_value = (t_begin_of_data + 1) + (t_value__size);
	BINPAC_ASSERT(t_dataptr_after_value <= t_end_of_data);
	t_Option_Info__size = t_dataptr_after_value - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Option_Info__size) <= t_end_of_data);
	return t_Option_Info__size;
	}

DHCP_Option::DHCP_Option()
	{
	code_ = 0;
	data_case_index_ = -1;
	info_ = 0;
	last_ = 0;
	}

DHCP_Option::~DHCP_Option()
	{
	switch ( data_case_index() )
		{
		case 0:
		case 255:
			// Clean up "none"
			{
			}
			break;
		default:
			// Clean up "info"
			{
			delete info_;
			info_ = 0;
			}
			break;
		}
	}

int DHCP_Option::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "DHCP_Option:code"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DHCP_Option:code",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "code"
	code_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data"
	int t_data__size;
	data_case_index_ = code();
	switch ( data_case_index() )
		{
		case 0:
		case 255:
			// Parse "none"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		default:
			// Parse "info"
			{
			info_ = new Option_Info(code());
			int t_info__size;
			t_info__size = info_->Parse((t_begin_of_data + 1), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_info__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_DHCP_Option__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 1) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_DHCP_Option__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	last_ =  ( code() == 255 ) ;
	BINPAC_ASSERT(t_begin_of_data + (t_DHCP_Option__size) <= t_end_of_data);
	return t_DHCP_Option__size;
	}

DHCP_Message::DHCP_Message()
	{
	op_ = 0;
	htype_ = 0;
	hlen_ = 0;
	hops_ = 0;
	xid_ = 0;
	secs_ = 0;
	flags_ = 0;
	ciaddr_ = 0;
	yiaddr_ = 0;
	siaddr_ = 0;
	giaddr_ = 0;
	cookie_ = 0;
	options_ = 0;
	options__elem_ = 0;
	byteorder_ = bigendian;
	type_ = 0;
	proc_dhcp_message_ = 0;
	}

DHCP_Message::~DHCP_Message()
	{
	chaddr_.free();
	sname_.free();
	file_.free();
	delete options__elem_;
	options__elem_ = 0;
	if ( options() )
		{
		for ( int i = 0; i < (int) options()->size(); ++i )
			{
			DHCP_Option * options__elem_ = (*options_)[i];
			delete options__elem_;
			options__elem_ = 0;
			}
		}
	delete options_;
	}

int DHCP_Message::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDHCP * t_context)
	{
	// Checking out-of-bound for "DHCP_Message:giaddr"
	if ( (t_begin_of_data + 24) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DHCP_Message:giaddr",
			(24) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "op"
	op_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "htype"
	htype_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "hlen"
	hlen_ = *((uint8 const *) ((t_begin_of_data + 2)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "hops"
	hops_ = *((uint8 const *) ((t_begin_of_data + 3)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "xid"
	xid_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "secs"
	secs_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 8))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "flags"
	flags_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 10))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "ciaddr"
	ciaddr_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 12))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "yiaddr"
	yiaddr_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 16))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "siaddr"
	siaddr_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 20))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "giaddr"
	giaddr_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 24))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "chaddr"
	// Checking out-of-bound for "DHCP_Message:chaddr"
	if ( (t_begin_of_data + 28) + (16) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DHCP_Message:chaddr",
			(28) + (16), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 28) + 16;
	int t_chaddr_string_length;
	t_chaddr_string_length = 16;
	int t_chaddr__size;
	t_chaddr__size = t_chaddr_string_length;
	chaddr_.init((t_begin_of_data + 28), t_chaddr_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_chaddr = (t_begin_of_data + 28) + (16);
	BINPAC_ASSERT(t_dataptr_after_chaddr <= t_end_of_data);
	// Parse "sname"
	// Checking out-of-bound for "DHCP_Message:sname"
	if ( t_dataptr_after_chaddr + (64) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DHCP_Message:sname",
			((t_dataptr_after_chaddr - t_begin_of_data)) + (64), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_chaddr + 64;
	int t_sname_string_length;
	t_sname_string_length = 64;
	int t_sname__size;
	t_sname__size = t_sname_string_length;
	sname_.init(t_dataptr_after_chaddr, t_sname_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_sname = t_dataptr_after_chaddr + (64);
	BINPAC_ASSERT(t_dataptr_after_sname <= t_end_of_data);
	// Parse "file"
	// Checking out-of-bound for "DHCP_Message:file"
	if ( t_dataptr_after_sname + (128) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DHCP_Message:file",
			((t_dataptr_after_sname - t_begin_of_data)) + (128), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_sname + 128;
	int t_file_string_length;
	t_file_string_length = 128;
	int t_file__size;
	t_file__size = t_file_string_length;
	file_.init(t_dataptr_after_sname, t_file_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_file = t_dataptr_after_sname + (128);
	BINPAC_ASSERT(t_dataptr_after_file <= t_end_of_data);
	// Checking out-of-bound for "DHCP_Message:cookie"
	if ( t_dataptr_after_file + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DHCP_Message:cookie",
			((t_dataptr_after_file - t_begin_of_data)) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "cookie"
	cookie_ = FixByteOrder(byteorder(), *((uint32 const *) (t_dataptr_after_file)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "options"
	int t_options__arraylength;
	t_options__arraylength = 0;
	options__elem_ = 0;
	int t_options__elem__it;
	t_options__elem__it = 0;
	int t_options__size;
	options_ = new vector<DHCP_Option *>;
	const_byteptr t_options__elem__dataptr = (t_dataptr_after_file + 4);
	for (; /* forever */; ++t_options__elem__it)
		{
		// Check &until(options__elem__dataptr >= end_of_data)
		if ( t_options__elem__dataptr >= t_end_of_data )
			{
			options__elem_ = 0;
			goto end_of_options;
			}
		options__elem_ = new DHCP_Option();
		int t_options__elem__size;
		t_options__elem__size = options__elem_->Parse(t_options__elem__dataptr, t_end_of_data, byteorder());
		// Evaluate 'let' and 'withinput' fields
		options_->push_back(options__elem_);
		t_options__elem__dataptr += t_options__elem__size;
		BINPAC_ASSERT(t_options__elem__dataptr <= t_end_of_data);
		// Check &until( ( @$element->last@ ) )
		if (  ( options__elem_->last() )  )
			{
			options__elem_ = 0;
			goto end_of_options;
			}
		options__elem_ = 0;
		}
end_of_options: ;
	t_options__size = t_options__elem__dataptr - ((t_dataptr_after_file + 4));
	// Evaluate 'let' and 'withinput' fields
	
	int t_DHCP_Message__size;
	const_byteptr const t_dataptr_after_options = (t_dataptr_after_file + 4) + (t_options__size);
	BINPAC_ASSERT(t_dataptr_after_options <= t_end_of_data);
	t_DHCP_Message__size = t_dataptr_after_options - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	type_ = t_context->flow()->get_dhcp_msgtype(options());
	proc_dhcp_message_ = t_context->flow()->process_dhcp_message(this);
	BINPAC_ASSERT(t_begin_of_data + (t_DHCP_Message__size) <= t_end_of_data);
	return t_DHCP_Message__size;
	}

DHCP_Conn::DHCP_Conn(BroAnalyzer const & bro_analyzer)
	{
	upflow_ = new DHCP_Flow(this, true);
	downflow_ = new DHCP_Flow(this, false);
	bro_analyzer_ = bro_analyzer;
	}

DHCP_Conn::~DHCP_Conn()
	{
	delete upflow_;
	upflow_ = 0;
	delete downflow_;
	downflow_ = 0;
	}

void DHCP_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void DHCP_Conn::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void DHCP_Conn::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

DHCP_Flow::DHCP_Flow(DHCP_Conn * connection, bool is_orig)
	{
	connection_ = connection;
	is_orig_ = is_orig;

		dhcp_msg_val_ = 0;
	
	dataunit_ = 0;
	context_ = 0;
	}

DHCP_Flow::~DHCP_Flow()
	{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;

		Unref(dhcp_msg_val_);
		dhcp_msg_val_ = 0;
	
	}

void DHCP_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		dataunit_ = new DHCP_Message();
		context_ = new ContextDHCP(connection(), this);
		int t_dataunit__size;
		t_dataunit__size = dataunit_->Parse(t_begin_of_data, t_end_of_data, context_);
		// Evaluate 'let' and 'withinput' fields
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		}
	catch ( binpac::Exception const &e )
		{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;

		Unref(dhcp_msg_val_);
		dhcp_msg_val_ = 0;
	
		throw;
		}
	}

void DHCP_Flow::NewGap(int gap_length)
	{
	}
void DHCP_Flow::FlowEOF()
	{
	}
uint8 DHCP_Flow::get_dhcp_msgtype(vector<DHCP_Option *> * options)
	{

		vector<DHCP_Option*>::const_iterator ptr;
		uint8 type = 0;

		// Leave the for loop if the message type is found.
		bool parsed = false;

		for ( ptr = options->begin();
		      ptr != options->end() && ! (*ptr)->last(); ++ptr )
			{
			// We use a switch for future expandability.
			switch ( (*ptr)->code() ) {
			case MSG_TYPE_OPTION:
				type = (*ptr)->info()->msg_type();
				parsed = true;
				break;
			}

			if ( parsed )
				break;
			}

		if ( type == 0 )
			connection()->bro_analyzer()->ProtocolViolation("no DHCP message type option");

		return type;
		
	}

bool DHCP_Flow::parse_request(vector<DHCP_Option *> * options, uint8 type)
	{

		vector<DHCP_Option*>::const_iterator ptr;

		// Requested IP address to the server.
		::uint32 req_addr = 0, serv_addr = 0;
		StringVal* host_name = 0;

		for ( ptr = options->begin();  ptr != options->end() && ! (*ptr)->last(); ++ptr )
			{
			switch ( (*ptr)->code() )
				{
				case REQ_IP_OPTION:
					req_addr = htonl((*ptr)->info()->req_addr());
					break;

				case SERV_ID_OPTION:
					serv_addr = htonl((*ptr)->info()->serv_addr());
					break;

				case HOST_NAME_OPTION:
					Unref(host_name);
					host_name = new StringVal((*ptr)->info()->host_name().length(),
								  (const char*) (*ptr)->info()->host_name().begin());
					break;
				}
			}

		if ( host_name == 0 )
			host_name = new StringVal("");

		switch ( type )
			{
			case DHCPDISCOVER:
				BifEvent::generate_dhcp_discover(connection()->bro_analyzer(),
								 connection()->bro_analyzer()->Conn(),
								 dhcp_msg_val_->Ref(), new AddrVal(req_addr), host_name);
				break;

			case DHCPREQUEST:
				BifEvent::generate_dhcp_request(connection()->bro_analyzer(),
								connection()->bro_analyzer()->Conn(),
								dhcp_msg_val_->Ref(), new AddrVal(req_addr),
								new AddrVal(serv_addr), host_name);
				break;

			case DHCPDECLINE:
				BifEvent::generate_dhcp_decline(connection()->bro_analyzer(),
								connection()->bro_analyzer()->Conn(),
								dhcp_msg_val_->Ref(), host_name);
				break;

			case DHCPRELEASE:
				BifEvent::generate_dhcp_release(connection()->bro_analyzer(),
								connection()->bro_analyzer()->Conn(),
								dhcp_msg_val_->Ref(), host_name);
				break;

			case DHCPINFORM:
				BifEvent::generate_dhcp_inform(connection()->bro_analyzer(),
							       connection()->bro_analyzer()->Conn(),
							       dhcp_msg_val_->Ref(), host_name);
				break;

			default:
				Unref(host_name);
				break;
			}

		return true;
		
	}

bool DHCP_Flow::parse_reply(vector<DHCP_Option *> * options, uint8 type)
	{

		vector<DHCP_Option*>::const_iterator ptr;

		// RFC 1533 allows a list of router addresses.
		TableVal* router_list = 0;

		::uint32 subnet_mask = 0, serv_addr = 0;

		uint32 lease = 0;
		StringVal* host_name = 0;

		for ( ptr = options->begin();
		      ptr != options->end() && ! (*ptr)->last(); ++ptr )
			{
			switch ( (*ptr)->code() )
				{
				case SUBNET_OPTION:
					subnet_mask = htonl((*ptr)->info()->mask());
					break;

				case ROUTER_OPTION:
					// Let's hope there aren't multiple
					// such options.
					Unref(router_list);
					router_list = new TableVal(dhcp_router_list);

						{
						int num_routers = (*ptr)->info()->router_list()->size();

						for ( int i = 0; i < num_routers; ++i )
							{
							vector<uint32>* rlist = (*ptr)->info()->router_list();

							uint32 raddr = (*rlist)[i];
							::uint32 tmp_addr;
							tmp_addr = htonl(raddr);

							// index starting from 1
							Val* index = new Val(i + 1, TYPE_COUNT);
							router_list->Assign(index, new AddrVal(tmp_addr));
							Unref(index);
							}
						}
					break;

				case LEASE_OPTION:
					lease = (*ptr)->info()->lease();
					break;

				case SERV_ID_OPTION:
					serv_addr = htonl((*ptr)->info()->serv_addr());
					break;

				case HOST_NAME_OPTION:
					Unref(host_name);
					host_name = new StringVal((*ptr)->info()->host_name().length(),
								  (const char*) (*ptr)->info()->host_name().begin());
					break;
				}
			}

			if ( host_name == 0 )
				host_name = new StringVal("");

		switch ( type )
			{
			case DHCPOFFER:
				BifEvent::generate_dhcp_offer(connection()->bro_analyzer(),
							      connection()->bro_analyzer()->Conn(),
							      dhcp_msg_val_->Ref(), new AddrVal(subnet_mask),
							      router_list, lease, new AddrVal(serv_addr), host_name);
				break;

			case DHCPACK:
				BifEvent::generate_dhcp_ack(connection()->bro_analyzer(),
							    connection()->bro_analyzer()->Conn(),
							    dhcp_msg_val_->Ref(), new AddrVal(subnet_mask),
							    router_list, lease, new AddrVal(serv_addr), host_name);
				break;

			case DHCPNAK:
				BifEvent::generate_dhcp_nak(connection()->bro_analyzer(),
							    connection()->bro_analyzer()->Conn(),
							    dhcp_msg_val_->Ref(), host_name);
				break;

			default:
				Unref(host_name);
				break;
			}

		return true;

		
	}

bool DHCP_Flow::process_dhcp_message(DHCP_Message * msg)
	{

		// Check whether the options in the message conform to
		// DHCP or BOOTP.  If not, we are unable to interpret
		// the message options.
		if ( msg->cookie() != 0x63825363 )
			{
			connection()->bro_analyzer()->ProtocolViolation(fmt("bad cookie (%d)", msg->cookie()));
			return false;
			}

		Unref(dhcp_msg_val_);

		const char* mac_str = fmt_mac(msg->chaddr().data(), msg->chaddr().length());

		RecordVal* r = new RecordVal(dhcp_msg);
		r->Assign(0, new Val(msg->op(), TYPE_COUNT));
		r->Assign(1, new Val(msg->type(), TYPE_COUNT));
		r->Assign(2, new Val(msg->xid(), TYPE_COUNT));
		r->Assign(3, new StringVal(mac_str));
		r->Assign(4, new AddrVal(msg->ciaddr()));
		r->Assign(5, new AddrVal(msg->yiaddr()));

		delete [] mac_str;

		dhcp_msg_val_ = r;

		switch ( msg->op() )
			{
			case BOOTREQUEST:	// presumably from client to server
				if ( msg->type() == DHCPDISCOVER ||
			     	     msg->type() == DHCPREQUEST ||
			     	     msg->type() == DHCPDECLINE ||
			     	     msg->type() == DHCPRELEASE ||
			     	     msg->type() == DHCPINFORM )
					parse_request(msg->options(), msg->type());
				else
					connection()->bro_analyzer()->ProtocolViolation(fmt("unknown DHCP message type option for BOOTREQUEST (%d)",
											    msg->type()));
				break;

			case BOOTREPLY:		// presumably from server to client
				if ( msg->type() == DHCPOFFER ||
			     	     msg->type() == DHCPACK ||
				     msg->type() == DHCPNAK )
					parse_reply(msg->options(), msg->type());
				else
					connection()->bro_analyzer()->ProtocolViolation(fmt("unknown DHCP message type option for BOOTREPLY (%d)",
											    msg->type()));

				break;

			default:
				connection()->bro_analyzer()->ProtocolViolation(fmt("unknown DHCP message op code (%d). Known codes: 1=BOOTREQUEST, 2=BOOTREPLY",
										msg->op()));
				break;
			}

		connection()->bro_analyzer()->ProtocolConfirmation();
		return true;
		
	}

} // namespace DHCP
}  // namespace binpac

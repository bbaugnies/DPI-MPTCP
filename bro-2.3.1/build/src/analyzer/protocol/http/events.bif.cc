// This file was automatically generated by bifcl from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/http/events.bif (plugin mode).


#include "events.bif.h"

EventHandlerPtr http_request; 
void BifEvent::generate_http_request(analyzer::Analyzer* analyzer, Connection* c, StringVal* method, StringVal* original_URI, StringVal* unescaped_URI, StringVal* version)
	{
	// Note that it is intentional that here we do not
	// check if ::http_request is NULL, which should happen *before*
	// BifEvent::generate_http_request is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(method);
	vl->append(original_URI);
	vl->append(unescaped_URI);
	vl->append(version);

	mgr.QueueEvent(::http_request, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr http_reply; 
void BifEvent::generate_http_reply(analyzer::Analyzer* analyzer, Connection* c, StringVal* version, bro_uint_t code, StringVal* reason)
	{
	// Note that it is intentional that here we do not
	// check if ::http_reply is NULL, which should happen *before*
	// BifEvent::generate_http_reply is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(version);
	vl->append(new Val(code, TYPE_COUNT));
	vl->append(reason);

	mgr.QueueEvent(::http_reply, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr http_header; 
void BifEvent::generate_http_header(analyzer::Analyzer* analyzer, Connection* c, int is_orig, StringVal* name, StringVal* value)
	{
	// Note that it is intentional that here we do not
	// check if ::http_header is NULL, which should happen *before*
	// BifEvent::generate_http_header is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(name);
	vl->append(value);

	mgr.QueueEvent(::http_header, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr http_all_headers; 
void BifEvent::generate_http_all_headers(analyzer::Analyzer* analyzer, Connection* c, int is_orig, Val* hlist)
	{
	// Note that it is intentional that here we do not
	// check if ::http_all_headers is NULL, which should happen *before*
	// BifEvent::generate_http_all_headers is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(hlist);

	mgr.QueueEvent(::http_all_headers, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr http_begin_entity; 
void BifEvent::generate_http_begin_entity(analyzer::Analyzer* analyzer, Connection* c, int is_orig)
	{
	// Note that it is intentional that here we do not
	// check if ::http_begin_entity is NULL, which should happen *before*
	// BifEvent::generate_http_begin_entity is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));

	mgr.QueueEvent(::http_begin_entity, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr http_end_entity; 
void BifEvent::generate_http_end_entity(analyzer::Analyzer* analyzer, Connection* c, int is_orig)
	{
	// Note that it is intentional that here we do not
	// check if ::http_end_entity is NULL, which should happen *before*
	// BifEvent::generate_http_end_entity is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));

	mgr.QueueEvent(::http_end_entity, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr http_entity_data; 
void BifEvent::generate_http_entity_data(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t length, StringVal* data)
	{
	// Note that it is intentional that here we do not
	// check if ::http_entity_data is NULL, which should happen *before*
	// BifEvent::generate_http_entity_data is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(length, TYPE_COUNT));
	vl->append(data);

	mgr.QueueEvent(::http_entity_data, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr http_content_type; 
void BifEvent::generate_http_content_type(analyzer::Analyzer* analyzer, Connection* c, int is_orig, StringVal* ty, StringVal* subty)
	{
	// Note that it is intentional that here we do not
	// check if ::http_content_type is NULL, which should happen *before*
	// BifEvent::generate_http_content_type is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(ty);
	vl->append(subty);

	mgr.QueueEvent(::http_content_type, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr http_message_done; 
void BifEvent::generate_http_message_done(analyzer::Analyzer* analyzer, Connection* c, int is_orig, Val* stat)
	{
	// Note that it is intentional that here we do not
	// check if ::http_message_done is NULL, which should happen *before*
	// BifEvent::generate_http_message_done is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(stat);

	mgr.QueueEvent(::http_message_done, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr http_event; 
void BifEvent::generate_http_event(analyzer::Analyzer* analyzer, Connection* c, StringVal* event_type, StringVal* detail)
	{
	// Note that it is intentional that here we do not
	// check if ::http_event is NULL, which should happen *before*
	// BifEvent::generate_http_event is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(event_type);
	vl->append(detail);

	mgr.QueueEvent(::http_event, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr http_stats; 
void BifEvent::generate_http_stats(analyzer::Analyzer* analyzer, Connection* c, Val* stats)
	{
	// Note that it is intentional that here we do not
	// check if ::http_stats is NULL, which should happen *before*
	// BifEvent::generate_http_stats is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(stats);

	mgr.QueueEvent(::http_stats, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation

// This file is automatically generated from /home/benjamin/Bro/bro-2.3.1/src/file_analysis/analyzer/unified2/unified2.pac.


#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include "/home/benjamin/Bro/bro-2.3.1/build/src/file_analysis/analyzer/unified2/unified2_pac.h"

namespace binpac {






namespace Unified2 {
ContextUnified2::ContextUnified2(Unified2_Analyzer * analyzer, Flow * flow, FlowBuffer * flow_buffer)
	{
	analyzer_ = analyzer;
	flow_ = flow;
	flow_buffer_ = flow_buffer;
	}

ContextUnified2::~ContextUnified2()
	{
	}

Unified2_Analyzer::Unified2_Analyzer(BroFileAnalyzer * bro_analyzer)
	{
	downflow_ = new Flow(this);
	upflow_ = new Flow(this);
	bro_analyzer_ = bro_analyzer;
	}

Unified2_Analyzer::~Unified2_Analyzer()
	{
	delete downflow_;
	downflow_ = 0;
	delete upflow_;
	upflow_ = 0;
	}

void Unified2_Analyzer::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void Unified2_Analyzer::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void Unified2_Analyzer::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

Time::Time()
	{
	seconds_ = 0;
	microseconds_ = 0;
	byteorder_ = bigendian;
	}

Time::~Time()
	{
	}

int Time::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Time"
	if ( t_begin_of_data + (8) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Time",
			(0) + (8), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "seconds"
	seconds_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "microseconds"
	microseconds_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (8) <= t_end_of_data);
	return 8;
	}

Record::Record()
	{
	rtype_ = 0;
	length_ = 0;
	data_case_index_ = -1;
	packet_ = 0;
	ids_event_ = 0;
	ids_event_ipv6_ = 0;
	ids_event_vlan_ = 0;
	ids_event_ipv6_vlan_ = 0;
	unknown_record_type_ = 0;
	byteorder_ = bigendian;
	buffering_state_ = 0;
	buffering_state_ = 0;
	}

Record::~Record()
	{
	switch ( data_case_index() )
		{
		case 2:
			// Clean up "packet"
			{
			delete packet_;
			packet_ = 0;
			}
			break;
		case 7:
			// Clean up "ids_event"
			{
			delete ids_event_;
			ids_event_ = 0;
			}
			break;
		case 72:
			// Clean up "ids_event_ipv6"
			{
			delete ids_event_ipv6_;
			ids_event_ipv6_ = 0;
			}
			break;
		case 104:
			// Clean up "ids_event_vlan"
			{
			delete ids_event_vlan_;
			ids_event_vlan_ = 0;
			}
			break;
		case 105:
			// Clean up "ids_event_ipv6_vlan"
			{
			delete ids_event_ipv6_vlan_;
			ids_event_ipv6_vlan_ = 0;
			}
			break;
		default:
			// Clean up "unknown_record_type"
			{
			delete unknown_record_type_;
			unknown_record_type_ = 0;
			}
			break;
		}
	}

bool Record::ParseBuffer(flow_buffer_t t_flow_buffer, ContextUnified2 * t_context)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	const_byteptr t_begin_of_data = t_flow_buffer->begin();
	const_byteptr t_end_of_data = t_flow_buffer->end();
	switch ( buffering_state_ )
		{
		case 0:
			if ( buffering_state_ == 0 )
				{
				t_flow_buffer->NewFrame(8, false);
				buffering_state_ = 1;
				}
			buffering_state_ = 1;
			break;
		case 1:
			{
			buffering_state_ = 2;
			// Checking out-of-bound for "Record:length"
			if ( (t_begin_of_data + 4) + (4) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Record:length",
					(4) + (4), 
					(t_end_of_data) - (t_begin_of_data));
				}
			// Parse "length"
			length_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 4))));
			// Evaluate 'let' and 'withinput' fields
			t_flow_buffer->GrowFrame(length() + 8);
			}
			break;
		case 2:
			BINPAC_ASSERT(t_flow_buffer->ready());
			if ( t_flow_buffer->ready() )
				{
				// Parse "rtype"
				rtype_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
				// Evaluate 'let' and 'withinput' fields
				
				
				// Parse "data"
				int t_data__size;
				data_case_index_ = rtype();
				switch ( data_case_index() )
					{
					case 2:
						// Parse "packet"
						{
						packet_ = new Packet(this);
						int t_packet__size;
						t_packet__size = packet_->Parse((t_begin_of_data + 8), t_end_of_data, t_context);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_packet__size;
						}
						break;
					case 7:
						// Parse "ids_event"
						{
						ids_event_ = new IDS_Event(this, 1);
						int t_ids_event__size;
						t_ids_event__size = ids_event_->Parse((t_begin_of_data + 8), t_end_of_data, t_context);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_ids_event__size;
						}
						break;
					case 72:
						// Parse "ids_event_ipv6"
						{
						ids_event_ipv6_ = new IDS_Event(this, 4);
						int t_ids_event_ipv6__size;
						t_ids_event_ipv6__size = ids_event_ipv6_->Parse((t_begin_of_data + 8), t_end_of_data, t_context);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_ids_event_ipv6__size;
						}
						break;
					case 104:
						// Parse "ids_event_vlan"
						{
						ids_event_vlan_ = new IDS_Event_2(this, 1);
						int t_ids_event_vlan__size;
						t_ids_event_vlan__size = ids_event_vlan_->Parse((t_begin_of_data + 8), t_end_of_data, t_context);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_ids_event_vlan__size;
						}
						break;
					case 105:
						// Parse "ids_event_ipv6_vlan"
						{
						ids_event_ipv6_vlan_ = new IDS_Event_2(this, 4);
						int t_ids_event_ipv6_vlan__size;
						t_ids_event_ipv6_vlan__size = ids_event_ipv6_vlan_->Parse((t_begin_of_data + 8), t_end_of_data, t_context);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_ids_event_ipv6_vlan__size;
						}
						break;
					default:
						// Parse "unknown_record_type"
						{
						unknown_record_type_ = new UnknownRecordType(this);
						int t_unknown_record_type__size;
						t_unknown_record_type__size = unknown_record_type_->Parse((t_begin_of_data + 8), t_end_of_data, t_context);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_unknown_record_type__size;
						}
						break;
					}
				// Evaluate 'let' and 'withinput' fields
				
				t_val_parsing_complete = true;
				if ( t_val_parsing_complete )
					{
					// Evaluate 'let' and 'withinput' fields
					}
				BINPAC_ASSERT(t_val_parsing_complete);
				buffering_state_ = 0;
				}
			break;
		default:
			BINPAC_ASSERT(buffering_state_ <= 2);
			break;
		}
	return t_val_parsing_complete;
	}

IDS_Event::IDS_Event(Record * rec, int ip_len)
	{
	sensor_id_ = 0;
	event_id_ = 0;
	ts_ = 0;
	signature_id_ = 0;
	generator_id_ = 0;
	signature_revision_ = 0;
	classification_id_ = 0;
	priority_id_ = 0;
	src_ip_ = 0;
	src_ip__elem_ = 0;
	dst_ip_ = 0;
	dst_ip__elem_ = 0;
	src_p_ = 0;
	dst_p_ = 0;
	protocol_ = 0;
	packet_action_ = 0;
	rec_ = rec;
	ip_len_ = ip_len;
	byteorder_ = bigendian;
	proc_ = 0;
	}

IDS_Event::~IDS_Event()
	{
	delete ts_;
	ts_ = 0;
	delete src_ip_;
	delete dst_ip_;
	}

int IDS_Event::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextUnified2 * t_context)
	{
	// Checking out-of-bound for "IDS_Event:priority_id"
	if ( (t_begin_of_data + 32) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("IDS_Event:priority_id",
			(32) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "sensor_id"
	sensor_id_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "event_id"
	event_id_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "ts"
	ts_ = new Time();
	ts_->Parse((t_begin_of_data + 8), t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "signature_id"
	signature_id_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 16))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "generator_id"
	generator_id_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 20))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "signature_revision"
	signature_revision_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 24))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "classification_id"
	classification_id_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 28))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "priority_id"
	priority_id_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 32))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "src_ip"
	int t_src_ip__arraylength;
	t_src_ip__arraylength = 0;
	t_src_ip__arraylength = ip_len();
	if ( t_begin_of_data + t_src_ip__arraylength > t_end_of_data + 1 )
		{
		t_src_ip__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_src_ip__arraylength < 0 )
		{
		t_src_ip__arraylength = 0;
		}
	src_ip__elem_ = 0;
	int t_src_ip__elem__it;
	t_src_ip__elem__it = 0;
	int t_src_ip__size;
	src_ip_ = new vector<uint32>;
	src_ip_->reserve(t_src_ip__arraylength);
	const_byteptr t_src_ip__elem__dataptr = (t_begin_of_data + 36);
	for (; t_src_ip__elem__it < t_src_ip__arraylength; ++t_src_ip__elem__it)
		{
		// Check &until(src_ip__elem__dataptr >= end_of_data)
		if ( t_src_ip__elem__dataptr >= t_end_of_data )
			{
			goto end_of_src_ip;
			}
		// Checking out-of-bound for "IDS_Event:src_ip__elem"
		if ( t_src_ip__elem__dataptr + (4) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("IDS_Event:src_ip__elem",
				((t_src_ip__elem__dataptr - t_begin_of_data)) + (4), 
				(t_end_of_data) - (t_begin_of_data));
			}
		src_ip__elem_ = FixByteOrder(byteorder(), *((uint32 const *) (t_src_ip__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		src_ip_->push_back(src_ip__elem_);
		t_src_ip__elem__dataptr += 4;
		BINPAC_ASSERT(t_src_ip__elem__dataptr <= t_end_of_data);
		}
end_of_src_ip: ;
	t_src_ip__size = t_src_ip__elem__dataptr - ((t_begin_of_data + 36));
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_src_ip = (t_begin_of_data + 36) + (t_src_ip__size);
	BINPAC_ASSERT(t_dataptr_after_src_ip <= t_end_of_data);
	// Parse "dst_ip"
	int t_dst_ip__arraylength;
	t_dst_ip__arraylength = 0;
	t_dst_ip__arraylength = ip_len();
	if ( t_begin_of_data + t_dst_ip__arraylength > t_end_of_data + 1 )
		{
		t_dst_ip__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_dst_ip__arraylength < 0 )
		{
		t_dst_ip__arraylength = 0;
		}
	dst_ip__elem_ = 0;
	int t_dst_ip__elem__it;
	t_dst_ip__elem__it = 0;
	int t_dst_ip__size;
	dst_ip_ = new vector<uint32>;
	dst_ip_->reserve(t_dst_ip__arraylength);
	const_byteptr t_dst_ip__elem__dataptr = t_dataptr_after_src_ip;
	for (; t_dst_ip__elem__it < t_dst_ip__arraylength; ++t_dst_ip__elem__it)
		{
		// Check &until(dst_ip__elem__dataptr >= end_of_data)
		if ( t_dst_ip__elem__dataptr >= t_end_of_data )
			{
			goto end_of_dst_ip;
			}
		// Checking out-of-bound for "IDS_Event:dst_ip__elem"
		if ( t_dst_ip__elem__dataptr + (4) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("IDS_Event:dst_ip__elem",
				((t_dst_ip__elem__dataptr - t_begin_of_data)) + (4), 
				(t_end_of_data) - (t_begin_of_data));
			}
		dst_ip__elem_ = FixByteOrder(byteorder(), *((uint32 const *) (t_dst_ip__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		dst_ip_->push_back(dst_ip__elem_);
		t_dst_ip__elem__dataptr += 4;
		BINPAC_ASSERT(t_dst_ip__elem__dataptr <= t_end_of_data);
		}
end_of_dst_ip: ;
	t_dst_ip__size = t_dst_ip__elem__dataptr - (t_dataptr_after_src_ip);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_dst_ip = t_dataptr_after_src_ip + (t_dst_ip__size);
	BINPAC_ASSERT(t_dataptr_after_dst_ip <= t_end_of_data);
	// Checking out-of-bound for "IDS_Event:packet_action"
	if ( (t_dataptr_after_dst_ip + 5) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("IDS_Event:packet_action",
			(((t_dataptr_after_dst_ip + 5) - t_begin_of_data)) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "src_p"
	src_p_ = FixByteOrder(byteorder(), *((uint16 const *) (t_dataptr_after_dst_ip)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "dst_p"
	dst_p_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_dataptr_after_dst_ip + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "protocol"
	protocol_ = *((uint8 const *) ((t_dataptr_after_dst_ip + 4)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "packet_action"
	packet_action_ = *((uint8 const *) ((t_dataptr_after_dst_ip + 5)));
	// Evaluate 'let' and 'withinput' fields
	
	int t_IDS_Event__size;
	t_IDS_Event__size = (t_dataptr_after_dst_ip + 6) - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->flow()->proc_ids_event(this);
	BINPAC_ASSERT(t_begin_of_data + (t_IDS_Event__size) <= t_end_of_data);
	return t_IDS_Event__size;
	}

IDS_Event_2::IDS_Event_2(Record * rec, int ip_len)
	{
	sensor_id_ = 0;
	event_id_ = 0;
	ts_ = 0;
	signature_id_ = 0;
	generator_id_ = 0;
	signature_revision_ = 0;
	classification_id_ = 0;
	priority_id_ = 0;
	src_ip_ = 0;
	src_ip__elem_ = 0;
	dst_ip_ = 0;
	dst_ip__elem_ = 0;
	src_p_ = 0;
	dst_p_ = 0;
	protocol_ = 0;
	impact_flag_ = 0;
	impact_ = 0;
	blocked_ = 0;
	mpls_label_ = 0;
	vlan_id_ = 0;
	pad_ = 0;
	rec_ = rec;
	ip_len_ = ip_len;
	byteorder_ = bigendian;
	proc_ = 0;
	}

IDS_Event_2::~IDS_Event_2()
	{
	delete ts_;
	ts_ = 0;
	delete src_ip_;
	delete dst_ip_;
	}

int IDS_Event_2::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextUnified2 * t_context)
	{
	// Checking out-of-bound for "IDS_Event_2:priority_id"
	if ( (t_begin_of_data + 32) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("IDS_Event_2:priority_id",
			(32) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "sensor_id"
	sensor_id_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "event_id"
	event_id_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "ts"
	ts_ = new Time();
	ts_->Parse((t_begin_of_data + 8), t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "signature_id"
	signature_id_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 16))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "generator_id"
	generator_id_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 20))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "signature_revision"
	signature_revision_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 24))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "classification_id"
	classification_id_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 28))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "priority_id"
	priority_id_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 32))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "src_ip"
	int t_src_ip__arraylength;
	t_src_ip__arraylength = 0;
	t_src_ip__arraylength = ip_len();
	if ( t_begin_of_data + t_src_ip__arraylength > t_end_of_data + 1 )
		{
		t_src_ip__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_src_ip__arraylength < 0 )
		{
		t_src_ip__arraylength = 0;
		}
	src_ip__elem_ = 0;
	int t_src_ip__elem__it;
	t_src_ip__elem__it = 0;
	int t_src_ip__size;
	src_ip_ = new vector<uint32>;
	src_ip_->reserve(t_src_ip__arraylength);
	const_byteptr t_src_ip__elem__dataptr = (t_begin_of_data + 36);
	for (; t_src_ip__elem__it < t_src_ip__arraylength; ++t_src_ip__elem__it)
		{
		// Check &until(src_ip__elem__dataptr >= end_of_data)
		if ( t_src_ip__elem__dataptr >= t_end_of_data )
			{
			goto end_of_src_ip;
			}
		// Checking out-of-bound for "IDS_Event_2:src_ip__elem"
		if ( t_src_ip__elem__dataptr + (4) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("IDS_Event_2:src_ip__elem",
				((t_src_ip__elem__dataptr - t_begin_of_data)) + (4), 
				(t_end_of_data) - (t_begin_of_data));
			}
		src_ip__elem_ = FixByteOrder(byteorder(), *((uint32 const *) (t_src_ip__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		src_ip_->push_back(src_ip__elem_);
		t_src_ip__elem__dataptr += 4;
		BINPAC_ASSERT(t_src_ip__elem__dataptr <= t_end_of_data);
		}
end_of_src_ip: ;
	t_src_ip__size = t_src_ip__elem__dataptr - ((t_begin_of_data + 36));
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_src_ip = (t_begin_of_data + 36) + (t_src_ip__size);
	BINPAC_ASSERT(t_dataptr_after_src_ip <= t_end_of_data);
	// Parse "dst_ip"
	int t_dst_ip__arraylength;
	t_dst_ip__arraylength = 0;
	t_dst_ip__arraylength = ip_len();
	if ( t_begin_of_data + t_dst_ip__arraylength > t_end_of_data + 1 )
		{
		t_dst_ip__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_dst_ip__arraylength < 0 )
		{
		t_dst_ip__arraylength = 0;
		}
	dst_ip__elem_ = 0;
	int t_dst_ip__elem__it;
	t_dst_ip__elem__it = 0;
	int t_dst_ip__size;
	dst_ip_ = new vector<uint32>;
	dst_ip_->reserve(t_dst_ip__arraylength);
	const_byteptr t_dst_ip__elem__dataptr = t_dataptr_after_src_ip;
	for (; t_dst_ip__elem__it < t_dst_ip__arraylength; ++t_dst_ip__elem__it)
		{
		// Check &until(dst_ip__elem__dataptr >= end_of_data)
		if ( t_dst_ip__elem__dataptr >= t_end_of_data )
			{
			goto end_of_dst_ip;
			}
		// Checking out-of-bound for "IDS_Event_2:dst_ip__elem"
		if ( t_dst_ip__elem__dataptr + (4) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("IDS_Event_2:dst_ip__elem",
				((t_dst_ip__elem__dataptr - t_begin_of_data)) + (4), 
				(t_end_of_data) - (t_begin_of_data));
			}
		dst_ip__elem_ = FixByteOrder(byteorder(), *((uint32 const *) (t_dst_ip__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		dst_ip_->push_back(dst_ip__elem_);
		t_dst_ip__elem__dataptr += 4;
		BINPAC_ASSERT(t_dst_ip__elem__dataptr <= t_end_of_data);
		}
end_of_dst_ip: ;
	t_dst_ip__size = t_dst_ip__elem__dataptr - (t_dataptr_after_src_ip);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_dst_ip = t_dataptr_after_src_ip + (t_dst_ip__size);
	BINPAC_ASSERT(t_dataptr_after_dst_ip <= t_end_of_data);
	// Checking out-of-bound for "IDS_Event_2:pad"
	if ( (t_dataptr_after_dst_ip + 14) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("IDS_Event_2:pad",
			(((t_dataptr_after_dst_ip + 14) - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "src_p"
	src_p_ = FixByteOrder(byteorder(), *((uint16 const *) (t_dataptr_after_dst_ip)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "dst_p"
	dst_p_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_dataptr_after_dst_ip + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "protocol"
	protocol_ = *((uint8 const *) ((t_dataptr_after_dst_ip + 4)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "impact_flag"
	impact_flag_ = *((uint8 const *) ((t_dataptr_after_dst_ip + 5)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "impact"
	impact_ = *((uint8 const *) ((t_dataptr_after_dst_ip + 6)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "blocked"
	blocked_ = *((uint8 const *) ((t_dataptr_after_dst_ip + 7)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "mpls_label"
	mpls_label_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_dataptr_after_dst_ip + 8))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "vlan_id"
	vlan_id_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_dataptr_after_dst_ip + 12))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "pad"
	pad_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_dataptr_after_dst_ip + 14))));
	// Evaluate 'let' and 'withinput' fields
	
	int t_IDS_Event_2__size;
	t_IDS_Event_2__size = (t_dataptr_after_dst_ip + 16) - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->flow()->proc_ids_event_2(this);
	BINPAC_ASSERT(t_begin_of_data + (t_IDS_Event_2__size) <= t_end_of_data);
	return t_IDS_Event_2__size;
	}

Packet::Packet(Record * rec)
	{
	sensor_id_ = 0;
	event_id_ = 0;
	event_second_ = 0;
	packet_ts_ = 0;
	link_type_ = 0;
	packet_len_ = 0;
	rec_ = rec;
	byteorder_ = bigendian;
	proc_ = 0;
	}

Packet::~Packet()
	{
	delete packet_ts_;
	packet_ts_ = 0;
	packet_data_.free();
	}

int Packet::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextUnified2 * t_context)
	{
	// Checking out-of-bound for "Packet:packet_len"
	if ( (t_begin_of_data + 24) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Packet:packet_len",
			(24) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "sensor_id"
	sensor_id_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "event_id"
	event_id_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "event_second"
	event_second_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 8))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "packet_ts"
	packet_ts_ = new Time();
	packet_ts_->Parse((t_begin_of_data + 12), t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "link_type"
	link_type_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 20))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "packet_len"
	packet_len_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 24))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "packet_data"
	int t_packet_data__size;
	t_packet_data__size = packet_len();
	// Checking out-of-bound for "Packet:packet_data"
	if ( (t_begin_of_data + 28) + (t_packet_data__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Packet:packet_data",
			(28) + (t_packet_data__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 28) + t_packet_data__size;
	int t_packet_data_string_length;
	t_packet_data_string_length = packet_len();
	// check for negative sizes
	if ( t_packet_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/file_analysis/analyzer/unified2/unified2-file.pac:76", t_packet_data_string_length);
	packet_data_.init((t_begin_of_data + 28), t_packet_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_Packet__size;
	const_byteptr const t_dataptr_after_packet_data = (t_begin_of_data + 28) + (t_packet_data__size);
	BINPAC_ASSERT(t_dataptr_after_packet_data <= t_end_of_data);
	t_Packet__size = t_dataptr_after_packet_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->flow()->proc_packet(this);
	BINPAC_ASSERT(t_begin_of_data + (t_Packet__size) <= t_end_of_data);
	return t_Packet__size;
	}

ExtraData::ExtraData(Record * rec)
	{
	sensor_id_ = 0;
	event_id_ = 0;
	event_second_ = 0;
	extra_type_ = 0;
	data_type_ = 0;
	blob_len_ = 0;
	rec_ = rec;
	byteorder_ = bigendian;
	}

ExtraData::~ExtraData()
	{
	blob_.free();
	}

int ExtraData::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextUnified2 * t_context)
	{
	int t_ExtraData__size;
	t_ExtraData__size = rec()->length();
	// Checking out-of-bound for "ExtraData"
	if ( t_begin_of_data + (t_ExtraData__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ExtraData",
			(0) + (t_ExtraData__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + t_ExtraData__size;
	// Parse "sensor_id"
	sensor_id_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "event_id"
	event_id_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "event_second"
	event_second_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 8))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "extra_type"
	extra_type_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 12))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data_type"
	data_type_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 16))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "blob_len"
	blob_len_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 20))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "blob"
	int t_blob__size;
	t_blob__size = blob_len();
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 24) + t_blob__size;
	int t_blob_string_length;
	t_blob_string_length = blob_len();
	// check for negative sizes
	if ( t_blob_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/file_analysis/analyzer/unified2/unified2-file.pac:86", t_blob_string_length);
	blob_.init((t_begin_of_data + 24), t_blob_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	// Evaluate 'let' and 'withinput' fields
	}
	BINPAC_ASSERT(t_begin_of_data + (t_ExtraData__size) <= t_end_of_data);
	return t_ExtraData__size;
	}

UnknownRecordType::UnknownRecordType(Record * rec)
	{
	rec_ = rec;
	byteorder_ = bigendian;
	}

UnknownRecordType::~UnknownRecordType()
	{
	}

int UnknownRecordType::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextUnified2 * t_context)
	{
	int t_UnknownRecordType__size;
	t_UnknownRecordType__size = rec()->length();
	// Checking out-of-bound for "UnknownRecordType"
	if ( t_begin_of_data + (t_UnknownRecordType__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("UnknownRecordType",
			(0) + (t_UnknownRecordType__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + t_UnknownRecordType__size;
	// Parse "data"
	int t_data__size;
	t_data__size = rec()->length();
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + t_data__size;
	int t_data_string_length;
	t_data_string_length = rec()->length();
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/file_analysis/analyzer/unified2/unified2-file.pac:90", t_data_string_length);
	data_.init(t_begin_of_data, t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	// Evaluate 'let' and 'withinput' fields
	}
	BINPAC_ASSERT(t_begin_of_data + (t_UnknownRecordType__size) <= t_end_of_data);
	return t_UnknownRecordType__size;
	}

Flow::Flow(Unified2_Analyzer * connection)
	{
	flow_buffer_ = 0;
	connection_ = connection;

	
	dataunit_ = 0;
	context_ = 0;
	flow_buffer_ = new FlowBuffer();
	}

Flow::~Flow()
	{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;

	
	delete flow_buffer_;
	flow_buffer_ = 0;
	}

void Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		flow_buffer_->NewData(t_begin_of_data, t_end_of_data);
		while ( flow_buffer_->data_available() && 
			( !flow_buffer_->have_pending_request() || flow_buffer_->ready() ) )
			{
			if ( ! dataunit_ )
				{
				BINPAC_ASSERT(!context_);
				dataunit_ = new Record();
				flow_buffer_->NewFrame(0, false);
				context_ = new ContextUnified2(connection(), this, flow_buffer());
				}
			bool t_dataunit_parsing_complete;
			t_dataunit_parsing_complete = false;
			while ( ! t_dataunit_parsing_complete && flow_buffer_->ready() )
				{
				const_byteptr t_begin_of_data = flow_buffer()->begin();
				const_byteptr t_end_of_data = flow_buffer()->end();
				t_dataunit_parsing_complete = dataunit_->ParseBuffer(flow_buffer(), context_);
				if ( t_dataunit_parsing_complete )
					{
					// Evaluate 'let' and 'withinput' fields
					}
				}
			if ( t_dataunit_parsing_complete )
				{
				// Clean up the flow unit after parsing
				delete dataunit_;
				dataunit_ = 0;
				delete context_;
				context_ = 0;
				}
			else
				{
				// Resume upon next input segment
				BINPAC_ASSERT(!flow_buffer()->ready());
				break;
				}
			}
		}
	catch ( binpac::Exception const &e )
		{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;

	
		flow_buffer_->DiscardData();
		throw;
		}
	}

void Flow::NewGap(int gap_length)
	{
	flow_buffer_->NewGap(gap_length);
	}
void Flow::FlowEOF()
	{

	
	flow_buffer_->set_eof();
	NewData(0, 0);
	}
double Flow::ts_to_double(Time * ts)
	{

		double t = ts->seconds() + (ts->microseconds() / 1000000);
		return t;
		
	}

AddrVal * Flow::unified2_addr_to_bro_addr(vector<uint32> * a)
	{

		if ( a->size() == 1 )
			{
			return new AddrVal(IPAddr(IPv4, &(a->at(0)), IPAddr::Host));
			}
		else if ( a->size() == 4 )
			{
			uint32 tmp[4] = { a->at(0), a->at(1), a->at(2), a->at(3) };
			return new AddrVal(IPAddr(IPv6, tmp, IPAddr::Host));
			}
		else
			{
			// Should never reach here.
			return new AddrVal(1);
			}
		
	}

PortVal * Flow::to_port(uint16 n, uint8 p)
	{

		TransportProto proto = TRANSPORT_UNKNOWN;
		switch ( p ) {
		case 1: proto = TRANSPORT_ICMP; break;
		case 6: proto = TRANSPORT_TCP; break;
		case 17: proto = TRANSPORT_UDP; break;
		}

		return new PortVal(n, proto);
		
	}

bool Flow::proc_ids_event(IDS_Event * ev)
	{

		if ( ::unified2_event )
			{
			RecordVal* ids_event = new RecordVal(BifType::Record::Unified2::IDSEvent);
			ids_event->Assign(0, new Val(ev->sensor_id(), TYPE_COUNT));
			ids_event->Assign(1, new Val(ev->event_id(), TYPE_COUNT));
			ids_event->Assign(2, new Val(ts_to_double(ev->ts()), TYPE_TIME));
			ids_event->Assign(3, new Val(ev->signature_id(), TYPE_COUNT));
			ids_event->Assign(4, new Val(ev->generator_id(), TYPE_COUNT));
			ids_event->Assign(5, new Val(ev->signature_revision(), TYPE_COUNT));
			ids_event->Assign(6, new Val(ev->classification_id(), TYPE_COUNT));
			ids_event->Assign(7, new Val(ev->priority_id(), TYPE_COUNT));
			ids_event->Assign(8, unified2_addr_to_bro_addr(ev->src_ip()));
			ids_event->Assign(9, unified2_addr_to_bro_addr(ev->dst_ip()));
			ids_event->Assign(10, to_port(ev->src_p(), ev->protocol()));
			ids_event->Assign(11, to_port(ev->dst_p(), ev->protocol()));
			ids_event->Assign(17, new Val(ev->packet_action(), TYPE_COUNT));

			val_list* vl = new val_list();
			vl->append(connection()->bro_analyzer()->GetFile()->GetVal()->Ref());
			vl->append(ids_event);
			mgr.QueueEvent(::unified2_event, vl, SOURCE_LOCAL);
			}
		return true;
		
	}

bool Flow::proc_ids_event_2(IDS_Event_2 * ev)
	{

		if ( ::unified2_event )
			{
			RecordVal* ids_event = new RecordVal(BifType::Record::Unified2::IDSEvent);
			ids_event->Assign(0, new Val(ev->sensor_id(), TYPE_COUNT));
			ids_event->Assign(1, new Val(ev->event_id(), TYPE_COUNT));
			ids_event->Assign(2, new Val(ts_to_double(ev->ts()), TYPE_TIME));
			ids_event->Assign(3, new Val(ev->signature_id(), TYPE_COUNT));
			ids_event->Assign(4, new Val(ev->generator_id(), TYPE_COUNT));
			ids_event->Assign(5, new Val(ev->signature_revision(), TYPE_COUNT));
			ids_event->Assign(6, new Val(ev->classification_id(), TYPE_COUNT));
			ids_event->Assign(7, new Val(ev->priority_id(), TYPE_COUNT));
			ids_event->Assign(8, unified2_addr_to_bro_addr(ev->src_ip()));
			ids_event->Assign(9, unified2_addr_to_bro_addr(ev->dst_ip()));
			ids_event->Assign(10, to_port(ev->src_p(), ev->protocol()));
			ids_event->Assign(11, to_port(ev->dst_p(), ev->protocol()));
			ids_event->Assign(12, new Val(ev->impact_flag(), TYPE_COUNT));
			ids_event->Assign(13, new Val(ev->impact(), TYPE_COUNT));
			ids_event->Assign(14, new Val(ev->blocked(), TYPE_COUNT));
			ids_event->Assign(15, new Val(ev->mpls_label(), TYPE_COUNT));
			ids_event->Assign(16, new Val(ev->vlan_id(), TYPE_COUNT));

			val_list* vl = new val_list();
			vl->append(connection()->bro_analyzer()->GetFile()->GetVal()->Ref());
			vl->append(ids_event);
			mgr.QueueEvent(::unified2_event, vl, SOURCE_LOCAL);
			}

		return true;
		
	}

bool Flow::proc_packet(Packet * pkt)
	{

		if ( ::unified2_packet )
			{
			RecordVal* packet = new RecordVal(BifType::Record::Unified2::Packet);
			packet->Assign(0, new Val(pkt->sensor_id(), TYPE_COUNT));
			packet->Assign(1, new Val(pkt->event_id(), TYPE_COUNT));
			packet->Assign(2, new Val(pkt->event_second(), TYPE_COUNT));
			packet->Assign(3, new Val(ts_to_double(pkt->packet_ts()), TYPE_TIME));
			packet->Assign(4, new Val(pkt->link_type(), TYPE_COUNT));
			packet->Assign(5, bytestring_to_val(pkt->packet_data()));

			val_list* vl = new val_list();
			vl->append(connection()->bro_analyzer()->GetFile()->GetVal()->Ref());
			vl->append(packet);
			mgr.QueueEvent(::unified2_packet, vl, SOURCE_LOCAL);
			}

		return true;
		
	}

} // namespace Unified2
}  // namespace binpac

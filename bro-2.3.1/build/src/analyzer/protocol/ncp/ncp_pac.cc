// This file is automatically generated from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ncp/ncp.pac.


#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include "/home/benjamin/Bro/bro-2.3.1/build/src/analyzer/protocol/ncp/ncp_pac.h"

namespace binpac {


namespace NCP {
ContextNCP::ContextNCP()
	{
	}

ContextNCP::~ContextNCP()
	{
	}

ncp_request::ncp_request(uint32 length)
	{
	data_ = 0;
	data__elem_ = 0;
	length_ = length;
	function_ = 0;
	subfunction_ = 0;
	}

ncp_request::~ncp_request()
	{
	delete data_;
	}

int ncp_request::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "data"
	int t_data__arraylength;
	t_data__arraylength = 0;
	t_data__arraylength = length();
	if ( t_begin_of_data + t_data__arraylength > t_end_of_data + 1 )
		{
		t_data__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_data__arraylength < 0 )
		{
		t_data__arraylength = 0;
		}
	data__elem_ = 0;
	int t_data__elem__it;
	t_data__elem__it = 0;
	int t_data__size;
	data_ = new vector<uint8>;
	data_->reserve(t_data__arraylength);
	const_byteptr t_data__elem__dataptr = t_begin_of_data;
	for (; t_data__elem__it < t_data__arraylength; ++t_data__elem__it)
		{
		// Check &until(data__elem__dataptr >= end_of_data)
		if ( t_data__elem__dataptr >= t_end_of_data )
			{
			goto end_of_data;
			}
		// Checking out-of-bound for "ncp_request:data__elem"
		if ( t_data__elem__dataptr + (1) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("ncp_request:data__elem",
				((t_data__elem__dataptr - t_begin_of_data)) + (1), 
				(t_end_of_data) - (t_begin_of_data));
			}
		data__elem_ = *((uint8 const *) (t_data__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		data_->push_back(data__elem_);
		t_data__elem__dataptr += 1;
		BINPAC_ASSERT(t_data__elem__dataptr <= t_end_of_data);
		}
end_of_data: ;
	t_data__size = t_data__elem__dataptr - (t_begin_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ncp_request__size;
	const_byteptr const t_dataptr_after_data = t_begin_of_data + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_ncp_request__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	function_ = length() > 0 ? (*(data()))[0] : 0;
	subfunction_ = length() > 1 ? (*(data()))[1] : 0;
	BINPAC_ASSERT(t_begin_of_data + (t_ncp_request__size) <= t_end_of_data);
	return t_ncp_request__size;
	}

ncp_reply::ncp_reply(uint32 length)
	{
	completion_code_ = 0;
	conn_status_ = 0;
	data_ = 0;
	data__elem_ = 0;
	length_ = length;
	}

ncp_reply::~ncp_reply()
	{
	delete data_;
	}

int ncp_reply::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "ncp_reply:conn_status"
	if ( (t_begin_of_data + 1) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ncp_reply:conn_status",
			(1) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "completion_code"
	completion_code_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "conn_status"
	conn_status_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data"
	int t_data__arraylength;
	t_data__arraylength = 0;
	t_data__arraylength = length() - 2;
	if ( t_begin_of_data + t_data__arraylength > t_end_of_data + 1 )
		{
		t_data__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_data__arraylength < 0 )
		{
		t_data__arraylength = 0;
		}
	data__elem_ = 0;
	int t_data__elem__it;
	t_data__elem__it = 0;
	int t_data__size;
	data_ = new vector<uint8>;
	data_->reserve(t_data__arraylength);
	const_byteptr t_data__elem__dataptr = (t_begin_of_data + 2);
	for (; t_data__elem__it < t_data__arraylength; ++t_data__elem__it)
		{
		// Check &until(data__elem__dataptr >= end_of_data)
		if ( t_data__elem__dataptr >= t_end_of_data )
			{
			goto end_of_data;
			}
		// Checking out-of-bound for "ncp_reply:data__elem"
		if ( t_data__elem__dataptr + (1) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("ncp_reply:data__elem",
				((t_data__elem__dataptr - t_begin_of_data)) + (1), 
				(t_end_of_data) - (t_begin_of_data));
			}
		data__elem_ = *((uint8 const *) (t_data__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		data_->push_back(data__elem_);
		t_data__elem__dataptr += 1;
		BINPAC_ASSERT(t_data__elem__dataptr <= t_end_of_data);
		}
end_of_data: ;
	t_data__size = t_data__elem__dataptr - ((t_begin_of_data + 2));
	// Evaluate 'let' and 'withinput' fields
	
	int t_ncp_reply__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 2) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_ncp_reply__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ncp_reply__size) <= t_end_of_data);
	return t_ncp_reply__size;
	}

ncp_frame::ncp_frame(bool is_orig, uint32 length)
	{
	frame_type_ = 0;
	seq_ = 0;
	conn_low_ = 0;
	task_ = 0;
	conn_high_ = 0;
	body_case_index_ = -1;
	request_ = 0;
	reply_ = 0;
	is_orig_ = is_orig;
	length_ = length;
	body_length_ = 0;
	}

ncp_frame::~ncp_frame()
	{
	switch ( body_case_index() )
		{
		case 1:
			// Clean up "request"
			{
			delete request_;
			request_ = 0;
			}
			break;
		case 0:
			// Clean up "reply"
			{
			delete reply_;
			reply_ = 0;
			}
			break;
		}
	}

int ncp_frame::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "ncp_frame:conn_high"
	if ( (t_begin_of_data + 5) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ncp_frame:conn_high",
			(5) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "frame_type"
	frame_type_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "seq"
	seq_ = *((uint8 const *) ((t_begin_of_data + 2)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "conn_low"
	conn_low_ = *((uint8 const *) ((t_begin_of_data + 3)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "task"
	task_ = *((uint8 const *) ((t_begin_of_data + 4)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "conn_high"
	conn_high_ = *((uint8 const *) ((t_begin_of_data + 5)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "body"
	body_length_ = length() - 6;
	int t_body__size;
	body_case_index_ = is_orig();
	switch ( body_case_index() )
		{
		case 1:
			// Parse "request"
			{
			request_ = new ncp_request(body_length());
			int t_request__size;
			t_request__size = request_->Parse((t_begin_of_data + 6), t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_body__size = t_request__size;
			}
			break;
		case 0:
			// Parse "reply"
			{
			reply_ = new ncp_reply(body_length());
			int t_reply__size;
			t_reply__size = reply_->Parse((t_begin_of_data + 6), t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_body__size = t_reply__size;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("ncp_frame", body_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_ncp_frame__size;
	const_byteptr const t_dataptr_after_body = (t_begin_of_data + 6) + (t_body__size);
	BINPAC_ASSERT(t_dataptr_after_body <= t_end_of_data);
	t_ncp_frame__size = t_dataptr_after_body - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ncp_frame__size) <= t_end_of_data);
	return t_ncp_frame__size;
	}

ncp_over_tcpip_req_hdr::ncp_over_tcpip_req_hdr()
	{
	version_ = 0;
	reply_buf_size_ = 0;
	}

ncp_over_tcpip_req_hdr::~ncp_over_tcpip_req_hdr()
	{
	}

int ncp_over_tcpip_req_hdr::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "ncp_over_tcpip_req_hdr"
	if ( t_begin_of_data + (8) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ncp_over_tcpip_req_hdr",
			(0) + (8), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "version"
	version_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "reply_buf_size"
	reply_buf_size_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (8) <= t_end_of_data);
	return 8;
	}

ncp_over_tcpip_frame::ncp_over_tcpip_frame(bool is_orig)
	{
	signature_ = 0;
	length_ = 0;
	aux_case_index_ = -1;
	aux_req_ = 0;
	ncp_ = 0;
	is_orig_ = is_orig;
	byteorder_ = bigendian;
	}

ncp_over_tcpip_frame::~ncp_over_tcpip_frame()
	{
	switch ( aux_case_index() )
		{
		case 1:
			// Clean up "aux_req"
			{
			delete aux_req_;
			aux_req_ = 0;
			}
			break;
		case 0:
			// Clean up "aux_reply"
			{
			}
			break;
		}
	delete ncp_;
	ncp_ = 0;
	}

int ncp_over_tcpip_frame::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	int t_ncp_over_tcpip_frame__size;
	// Checking out-of-bound for "ncp_over_tcpip_frame:length"
	if ( (t_begin_of_data + 4) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ncp_over_tcpip_frame:length",
			(4) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	t_ncp_over_tcpip_frame__size = length();
	// Checking out-of-bound for "ncp_over_tcpip_frame"
	if ( t_begin_of_data + (t_ncp_over_tcpip_frame__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ncp_over_tcpip_frame",
			(0) + (t_ncp_over_tcpip_frame__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + t_ncp_over_tcpip_frame__size;
	// Parse "signature"
	signature_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	
	// Parse "aux"
	int t_aux__size;
	aux_case_index_ = is_orig();
	switch ( aux_case_index() )
		{
		case 1:
			// Parse "aux_req"
			{
			aux_req_ = new ncp_over_tcpip_req_hdr();
			aux_req_->Parse((t_begin_of_data + 8), t_end_of_data, byteorder());
			// Evaluate 'let' and 'withinput' fields
			t_aux__size = 8;
			}
			break;
		case 0:
			// Parse "aux_reply"
			{
			// Evaluate 'let' and 'withinput' fields
			t_aux__size = 0;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("ncp_over_tcpip_frame", aux_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_aux = (t_begin_of_data + 8) + (t_aux__size);
	BINPAC_ASSERT(t_dataptr_after_aux <= t_end_of_data);
	// Parse "ncp"
	ncp_ = new ncp_frame(is_orig(), length() - (t_dataptr_after_aux - t_begin_of_data));
	int t_ncp__size;
	t_ncp__size = ncp_->Parse(t_dataptr_after_aux, t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	}
	BINPAC_ASSERT(t_begin_of_data + (t_ncp_over_tcpip_frame__size) <= t_end_of_data);
	return t_ncp_over_tcpip_frame__size;
	}

} // namespace NCP
}  // namespace binpac

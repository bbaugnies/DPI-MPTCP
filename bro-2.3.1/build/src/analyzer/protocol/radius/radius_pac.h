// This file is automatically generated from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/radius/radius.pac.

#ifndef _home_benjamin_Bro_bro_2_3_1_src_analyzer_protocol_radius_radius_pac_h
#define _home_benjamin_Bro_bro_2_3_1_src_analyzer_protocol_radius_radius_pac_h

#include <vector>

#include "binpac.h"


#include "binpac_bro.h"


	#include "events.bif.h"

namespace binpac {

namespace RADIUS {
class ContextRADIUS;
class RADIUS_Conn;
class RADIUS_PDU;
class RADIUS_Attribute;
class RADIUS_Flow;
} // namespace RADIUS

int bytestring_to_int(const_bytestring const & s, int base);
double bytestring_to_double(const_bytestring const & s);
int bytestring_casecmp(const_bytestring const & s1, const_charptr const & s2);
bool bytestring_caseprefix(const_bytestring const & s1, const_charptr const & s2);
double network_time();
namespace RADIUS {

class ContextRADIUS
{
public:
	ContextRADIUS(RADIUS_Conn * connection, RADIUS_Flow * flow);
	~ContextRADIUS();
	
	// Member access functions
	RADIUS_Conn * connection() const { return connection_; }
	RADIUS_Flow * flow() const { return flow_; }
	
protected:
	RADIUS_Conn * connection_;
	RADIUS_Flow * flow_;
};


class RADIUS_Conn : public binpac::ConnectionAnalyzer
{
public:
	RADIUS_Conn(BroAnalyzer const & bro_analyzer);
	~RADIUS_Conn();
	
	// Member access functions
	RADIUS_Flow * upflow() const { return upflow_; }
	RADIUS_Flow * downflow() const { return downflow_; }
	BroAnalyzer const & bro_analyzer() const { return bro_analyzer_; }
	
	void NewData(bool is_orig, const_byteptr begin, const_byteptr end);
	void NewGap(bool is_orig, int gap_length);
	void FlowEOF(bool is_orig);
	
protected:
	RADIUS_Flow * upflow_;
	RADIUS_Flow * downflow_;
	BroAnalyzer bro_analyzer_;
};


class RADIUS_PDU
{
public:
	RADIUS_PDU(bool is_orig);
	~RADIUS_PDU();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextRADIUS * t_context);
	
	// Member access functions
	uint8 code() const { return code_; }
	uint8 trans_id() const { return trans_id_; }
	uint16 length() const { return length_; }
	bytestring const & authenticator() const { return authenticator_; }
	vector<RADIUS_Attribute *> * attributes() const { return attributes_; }
	bool is_orig() const { return is_orig_; }
	int byteorder() const { return byteorder_; }
	bool proc() const { return proc_; }
	
protected:
	uint8 code_;
	uint8 trans_id_;
	uint16 length_;
	bytestring authenticator_;
	vector<RADIUS_Attribute *> * attributes_;
	RADIUS_Attribute * attributes__elem_;
	bool is_orig_;
	int byteorder_;
	bool proc_;
};


class RADIUS_Attribute
{
public:
	RADIUS_Attribute(uint8 trans_id);
	~RADIUS_Attribute();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextRADIUS * t_context);
	
	// Member access functions
	uint8 code() const { return code_; }
	uint8 length() const { return length_; }
	bytestring const & value() const { return value_; }
	uint8 trans_id() const { return trans_id_; }
	bool proc() const { return proc_; }
	
protected:
	uint8 code_;
	uint8 length_;
	bytestring value_;
	uint8 trans_id_;
	bool proc_;
};


class RADIUS_Flow : public binpac::FlowAnalyzer
{
public:
	RADIUS_Flow(RADIUS_Conn * connection, bool is_orig);
	~RADIUS_Flow();
	
	// Member access functions
	RADIUS_Conn * connection() const { return connection_; }
	bool is_orig() const { return is_orig_; }
	
	void NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data);
	void NewGap(int gap_length);
	void FlowEOF();
	
	// Functions
	bool proc_radius_message(RADIUS_PDU * msg);
	bool proc_radius_attribute(RADIUS_Attribute * attr);
	
protected:
	RADIUS_PDU * dataunit_;
	ContextRADIUS * context_;
	RADIUS_Conn * connection_;
	bool is_orig_;
};

} // namespace RADIUS
}  // namespace binpac
#endif /* _home_benjamin_Bro_bro_2_3_1_src_analyzer_protocol_radius_radius_pac_h */

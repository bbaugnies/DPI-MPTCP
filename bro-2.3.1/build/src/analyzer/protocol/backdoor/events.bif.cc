// This file was automatically generated by bifcl from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/backdoor/events.bif (plugin mode).


#include "events.bif.h"

EventHandlerPtr backdoor_stats; 
void BifEvent::generate_backdoor_stats(analyzer::Analyzer* analyzer, Connection* c, Val* os, Val* rs)
	{
	// Note that it is intentional that here we do not
	// check if ::backdoor_stats is NULL, which should happen *before*
	// BifEvent::generate_backdoor_stats is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(os);
	vl->append(rs);

	mgr.QueueEvent(::backdoor_stats, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr backdoor_remove_conn; 
void BifEvent::generate_backdoor_remove_conn(analyzer::Analyzer* analyzer, Connection* c)
	{
	// Note that it is intentional that here we do not
	// check if ::backdoor_remove_conn is NULL, which should happen *before*
	// BifEvent::generate_backdoor_remove_conn is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());

	mgr.QueueEvent(::backdoor_remove_conn, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr ftp_signature_found; 
void BifEvent::generate_ftp_signature_found(analyzer::Analyzer* analyzer, Connection* c)
	{
	// Note that it is intentional that here we do not
	// check if ::ftp_signature_found is NULL, which should happen *before*
	// BifEvent::generate_ftp_signature_found is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());

	mgr.QueueEvent(::ftp_signature_found, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr gnutella_signature_found; 
void BifEvent::generate_gnutella_signature_found(analyzer::Analyzer* analyzer, Connection* c)
	{
	// Note that it is intentional that here we do not
	// check if ::gnutella_signature_found is NULL, which should happen *before*
	// BifEvent::generate_gnutella_signature_found is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());

	mgr.QueueEvent(::gnutella_signature_found, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr http_signature_found; 
void BifEvent::generate_http_signature_found(analyzer::Analyzer* analyzer, Connection* c)
	{
	// Note that it is intentional that here we do not
	// check if ::http_signature_found is NULL, which should happen *before*
	// BifEvent::generate_http_signature_found is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());

	mgr.QueueEvent(::http_signature_found, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr irc_signature_found; 
void BifEvent::generate_irc_signature_found(analyzer::Analyzer* analyzer, Connection* c)
	{
	// Note that it is intentional that here we do not
	// check if ::irc_signature_found is NULL, which should happen *before*
	// BifEvent::generate_irc_signature_found is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());

	mgr.QueueEvent(::irc_signature_found, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr telnet_signature_found; 
void BifEvent::generate_telnet_signature_found(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t len)
	{
	// Note that it is intentional that here we do not
	// check if ::telnet_signature_found is NULL, which should happen *before*
	// BifEvent::generate_telnet_signature_found is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(len, TYPE_COUNT));

	mgr.QueueEvent(::telnet_signature_found, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr ssh_signature_found; 
void BifEvent::generate_ssh_signature_found(analyzer::Analyzer* analyzer, Connection* c, int is_orig)
	{
	// Note that it is intentional that here we do not
	// check if ::ssh_signature_found is NULL, which should happen *before*
	// BifEvent::generate_ssh_signature_found is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));

	mgr.QueueEvent(::ssh_signature_found, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr rlogin_signature_found; 
void BifEvent::generate_rlogin_signature_found(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t num_null, bro_uint_t len)
	{
	// Note that it is intentional that here we do not
	// check if ::rlogin_signature_found is NULL, which should happen *before*
	// BifEvent::generate_rlogin_signature_found is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(num_null, TYPE_COUNT));
	vl->append(new Val(len, TYPE_COUNT));

	mgr.QueueEvent(::rlogin_signature_found, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr smtp_signature_found; 
void BifEvent::generate_smtp_signature_found(analyzer::Analyzer* analyzer, Connection* c)
	{
	// Note that it is intentional that here we do not
	// check if ::smtp_signature_found is NULL, which should happen *before*
	// BifEvent::generate_smtp_signature_found is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());

	mgr.QueueEvent(::smtp_signature_found, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr http_proxy_signature_found; 
void BifEvent::generate_http_proxy_signature_found(analyzer::Analyzer* analyzer, Connection* c)
	{
	// Note that it is intentional that here we do not
	// check if ::http_proxy_signature_found is NULL, which should happen *before*
	// BifEvent::generate_http_proxy_signature_found is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());

	mgr.QueueEvent(::http_proxy_signature_found, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation

// This file is automatically generated from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb.pac.

#ifndef _home_benjamin_Bro_bro_2_3_1_src_analyzer_protocol_smb_smb_pac_h
#define _home_benjamin_Bro_bro_2_3_1_src_analyzer_protocol_smb_smb_pac_h

#include <vector>

#include "binpac.h"


#include "binpac_bro.h"


#include "events.bif.h"

namespace binpac {

namespace SMB {
class ContextSMB;
enum TransactionType {
	SMB_MAILSLOT_BROWSE,
	SMB_MAILSLOT_LANMAN,
	SMB_PIPE,
	SMB_RAP,
	SMB_UNKNOWN,
};
class SMB_dos_error;
class SMB_error;
class SMB_header;
class SMB_body;
class SMB_ascii_string;
class SMB_unicode_string;
class SMB_string;
class SMB_time;
class SMB_date;
class SMB_andx;
class SMB_generic_andx;
class SMB_dialect;
class SMB_negotiate;
class SMB_negotiate_response;
class SMB_negotiate_response_long;
class SMB_setup_andx_basic;
class SMB_setup_andx_basic_response;
class SMB_setup_andx_ext;
class SMB_setup_andx_ext_response;
class SMB_logoff_andx;
class SMB_tree_connect_andx;
class SMB_close;
class SMB_tree_disconnect;
class SMB_nt_create_andx;
class SMB_read_andx;
class SMB_read_andx_response;
class SMB_write_andx;
class SMB_write_andx_response;
class SMB_transaction_data;
class SMB_transaction;
class SMB_transaction_secondary;
class SMB_transaction_response;
class SMB_get_dfs_referral;
enum SMB_MailSlot_opcode {
	HOST_ANNOUNCEMENT = 1,
	ANNOUCEMENT_REQUEST = 2,
	REQUEST_ELECTION = 8,
	GET_BACKUP_LIST_REQUEST = 9,
	GET_BACKUP_LIST_RESPONSE = 10,
	BECOME_BACKUP_REQUEST = 11,
	DOMAIN_ANNOUNCEMENT = 12,
	MASTER_ANNOUNCEMENT = 13,
	RESET_BROWSER_STATE = 14,
	LOCAL_MASTER_ANNOUNCEMENT = 15,
};
class SMB_MailSlot_message;
class SMB_MailSlot_command;
class SMB_MailSlot_host_announcement;
class SMB_MailSlot_announcement_request;
class SMB_MailSlot_request_election;
class SMB_MailSlot_get_backup_list_request;
class SMB_MailSlot_get_backup_list_response;
class SMB_MailSlot_domain_announcement;
class SMB_MailSlot_local_master_announcement;
class SMB_Pipe_message;
class SMB_RAP_message;
} // namespace SMB

int bytestring_to_int(const_bytestring const & s, int base);
double bytestring_to_double(const_bytestring const & s);
int bytestring_casecmp(const_bytestring const & s1, const_charptr const & s2);
bool bytestring_caseprefix(const_bytestring const & s1, const_charptr const & s2);
double network_time();
namespace SMB {

class ContextSMB
{
public:
	ContextSMB();
	~ContextSMB();
	
	// Member access functions
	
protected:
};

const_bytestring extract_string(SMB_string * s);
TransactionType determine_transaction_type(int setup_count, SMB_string * name);
SMB_string * name_string(SMB_transaction * trans);

class SMB_dos_error
{
public:
	SMB_dos_error();
	~SMB_dos_error();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder);
	
	// Member access functions
	uint8 error_class() const { return error_class_; }
	uint8 reserved() const { return reserved_; }
	uint16 error() const { return error_; }
	
protected:
	uint8 error_class_;
	uint8 reserved_;
	uint16 error_;
};


class SMB_error
{
public:
	SMB_error(int err_status_type);
	~SMB_error();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder);
	
	// Member access functions
	int val_case_index() const	{ return val_case_index_; }
	SMB_dos_error * dos_error() const
		{
		switch ( val_case_index() )
			{
			case 0:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-protocol.pac:106:dos_error", val_case_index(), "((int) 0)");
				break;
			}
		return dos_error_;
		}
	int32 status() const
		{
		switch ( val_case_index() )
			{
			case 1:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-protocol.pac:107:status", val_case_index(), "((int) 1)");
				break;
			}
		return status_;
		}
	int err_status_type() const { return err_status_type_; }
	
protected:
	int val_case_index_;
	SMB_dos_error * dos_error_;
	int32 status_;
	int err_status_type_;
};


class SMB_header
{
public:
	SMB_header();
	~SMB_header();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	bytestring const & protocol() const { return protocol_; }
	uint8 command() const { return command_; }
	SMB_error * status() const { return status_; }
	uint8 flags() const { return flags_; }
	uint16 flags2() const { return flags2_; }
	uint16 tid() const { return tid_; }
	uint16 pid() const { return pid_; }
	uint16 uid() const { return uid_; }
	uint16 mid() const { return mid_; }
	int byteorder() const { return byteorder_; }
	int err_status_type() const { return err_status_type_; }
	int unicode() const { return unicode_; }
	
protected:
	bytestring protocol_;
	uint8 command_;
	SMB_error * status_;
	uint8 flags_;
	uint16 flags2_;
	uint16 tid_;
	uint16 pid_;
	uint16 uid_;
	uint16 mid_;
	int byteorder_;
	int err_status_type_;
	int unicode_;
};

extern int const smb_header_length;

class SMB_body
{
public:
	SMB_body();
	~SMB_body();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 word_count() const { return word_count_; }
	vector<uint16> * parameter_words() const { return parameter_words_; }
	uint16 byte_count() const { return byte_count_; }
	int byteorder() const { return byteorder_; }
	int body_length() const { return body_length_; }
	
protected:
	uint8 word_count_;
	vector<uint16> * parameter_words_;
	uint16 parameter_words__elem_;
	uint16 byte_count_;
	int byteorder_;
	int body_length_;
};


class SMB_ascii_string
{
public:
	SMB_ascii_string();
	~SMB_ascii_string();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	vector<uint8> * val() const { return val_; }
	int size() const	{ return val() ? val()->size() : 0; }
	uint8 operator[](int index) const { BINPAC_ASSERT(val()); return (*val())[index]; }
	
protected:
	vector<uint8> * val_;
	uint8 val__elem_;
};


class SMB_unicode_string
{
public:
	SMB_unicode_string(int offset);
	~SMB_unicode_string();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder);
	
	// Member access functions
	vector<uint16> * s() const { return s_; }
	int offset() const { return offset_; }
	
protected:
	vector<uint16> * s_;
	uint16 s__elem_;
	int offset_;
};


class SMB_string
{
public:
	SMB_string(bool unicode, int offset);
	~SMB_string();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder);
	
	// Member access functions
	int val_case_index() const	{ return val_case_index_; }
	SMB_unicode_string * u() const
		{
		switch ( val_case_index() )
			{
			case 1:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-protocol.pac:146:u", val_case_index(), "true");
				break;
			}
		return u_;
		}
	SMB_ascii_string * a() const
		{
		switch ( val_case_index() )
			{
			case 0:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-protocol.pac:147:a", val_case_index(), "false");
				break;
			}
		return a_;
		}
	bool unicode() const { return unicode_; }
	int offset() const { return offset_; }
	
protected:
	int val_case_index_;
	SMB_unicode_string * u_;
	SMB_ascii_string * a_;
	bool unicode_;
	int offset_;
};


class SMB_time
{
public:
	SMB_time();
	~SMB_time();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint16 two_seconds() const { return two_seconds_; }
	uint16 minutes() const { return minutes_; }
	uint16 hours() const { return hours_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint16 two_seconds_;
	uint16 minutes_;
	uint16 hours_;
	int byteorder_;
};


class SMB_date
{
public:
	SMB_date();
	~SMB_date();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint16 day() const { return day_; }
	uint16 month() const { return month_; }
	uint16 year() const { return year_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint16 day_;
	uint16 month_;
	uint16 year_;
	int byteorder_;
};


class SMB_andx : public binpac::RefCount
{
public:
	SMB_andx();
	~SMB_andx();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder);
	
	// Member access functions
	uint8 command() const { return command_; }
	uint8 reserved() const { return reserved_; }
	uint16 offset() const { return offset_; }
	
protected:
	uint8 command_;
	uint8 reserved_;
	uint16 offset_;
};


class SMB_generic_andx
{
public:
	SMB_generic_andx();
	~SMB_generic_andx();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 word_count() const { return word_count_; }
	int andx_u_case_index() const	{ return andx_u_case_index_; }
	SMB_andx * andx() const
		{
		return andx_;
		}
	bytestring const & data() const { return data_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 word_count_;
	int andx_u_case_index_;
	SMB_andx * andx_;
	bytestring data_;
	int byteorder_;
};


class SMB_dialect
{
public:
	SMB_dialect();
	~SMB_dialect();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 bufferformat() const { return bufferformat_; }
	SMB_ascii_string * dialectname() const { return dialectname_; }
	
protected:
	uint8 bufferformat_;
	SMB_ascii_string * dialectname_;
};


class SMB_negotiate
{
public:
	SMB_negotiate();
	~SMB_negotiate();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 word_count() const { return word_count_; }
	uint16 byte_count() const { return byte_count_; }
	vector<SMB_dialect *> * dialects() const { return dialects_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 word_count_;
	uint16 byte_count_;
	vector<SMB_dialect *> * dialects_;
	SMB_dialect * dialects__elem_;
	int byteorder_;
};


class SMB_negotiate_response
{
public:
	SMB_negotiate_response();
	~SMB_negotiate_response();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 word_count() const { return word_count_; }
	uint16 dialect_index() const { return dialect_index_; }
	uint16 byte_count() const { return byte_count_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 word_count_;
	uint16 dialect_index_;
	uint16 byte_count_;
	int byteorder_;
};


class SMB_negotiate_response_long
{
public:
	SMB_negotiate_response_long(bool unicode);
	~SMB_negotiate_response_long();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 word_count() const { return word_count_; }
	uint16 dialect_index() const { return dialect_index_; }
	uint16 security_mode() const { return security_mode_; }
	uint16 max_buffer_size() const { return max_buffer_size_; }
	uint16 max_mpx_count() const { return max_mpx_count_; }
	uint16 max_number_vcs() const { return max_number_vcs_; }
	uint16 raw_mode() const { return raw_mode_; }
	uint32 session_key() const { return session_key_; }
	SMB_time * server_time() const { return server_time_; }
	SMB_date * server_date() const { return server_date_; }
	uint16 server_tz() const { return server_tz_; }
	uint16 enc_key_len() const { return enc_key_len_; }
	uint16 reserved() const { return reserved_; }
	uint16 byte_count() const { return byte_count_; }
	vector<uint8> * encryption_key() const { return encryption_key_; }
	SMB_string * primary_domain() const { return primary_domain_; }
	bool unicode() const { return unicode_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 word_count_;
	uint16 dialect_index_;
	uint16 security_mode_;
	uint16 max_buffer_size_;
	uint16 max_mpx_count_;
	uint16 max_number_vcs_;
	uint16 raw_mode_;
	uint32 session_key_;
	SMB_time * server_time_;
	SMB_date * server_date_;
	uint16 server_tz_;
	uint16 enc_key_len_;
	uint16 reserved_;
	uint16 byte_count_;
	vector<uint8> * encryption_key_;
	uint8 encryption_key__elem_;
	SMB_string * primary_domain_;
	bool unicode_;
	int byteorder_;
};


class SMB_setup_andx_basic
{
public:
	SMB_setup_andx_basic(bool unicode);
	~SMB_setup_andx_basic();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 word_count() const { return word_count_; }
	SMB_andx * andx() const { return andx_; }
	uint16 max_buffer_size() const { return max_buffer_size_; }
	uint16 max_mpx_count() const { return max_mpx_count_; }
	uint16 vc_number() const { return vc_number_; }
	uint32 session_key() const { return session_key_; }
	uint8 passwd_length() const { return passwd_length_; }
	uint32 reserved() const { return reserved_; }
	uint8 byte_count() const { return byte_count_; }
	vector<uint8> * password() const { return password_; }
	SMB_string * name() const { return name_; }
	SMB_string * domain() const { return domain_; }
	SMB_string * native_os() const { return native_os_; }
	SMB_string * native_lanman() const { return native_lanman_; }
	bool unicode() const { return unicode_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 word_count_;
	SMB_andx * andx_;
	uint16 max_buffer_size_;
	uint16 max_mpx_count_;
	uint16 vc_number_;
	uint32 session_key_;
	uint8 passwd_length_;
	uint32 reserved_;
	uint8 byte_count_;
	vector<uint8> * password_;
	uint8 password__elem_;
	SMB_string * name_;
	SMB_string * domain_;
	SMB_string * native_os_;
	SMB_string * native_lanman_;
	bool unicode_;
	int byteorder_;
};


class SMB_setup_andx_basic_response
{
public:
	SMB_setup_andx_basic_response(bool unicode);
	~SMB_setup_andx_basic_response();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 word_count() const { return word_count_; }
	SMB_andx * andx() const { return andx_; }
	uint8 action() const { return action_; }
	uint8 byte_count() const { return byte_count_; }
	SMB_string * native_os() const { return native_os_; }
	SMB_string * native_lanman() const { return native_lanman_; }
	SMB_string * primary_domain() const { return primary_domain_; }
	bool unicode() const { return unicode_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 word_count_;
	SMB_andx * andx_;
	uint8 action_;
	uint8 byte_count_;
	SMB_string * native_os_;
	SMB_string * native_lanman_;
	SMB_string * primary_domain_;
	bool unicode_;
	int byteorder_;
};


class SMB_setup_andx_ext
{
public:
	SMB_setup_andx_ext(bool unicode);
	~SMB_setup_andx_ext();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 word_count() const { return word_count_; }
	SMB_andx * andx() const { return andx_; }
	uint16 max_buffer_size() const { return max_buffer_size_; }
	uint16 max_mpx_count() const { return max_mpx_count_; }
	uint16 vc_number() const { return vc_number_; }
	uint32 session_key() const { return session_key_; }
	uint8 security_length() const { return security_length_; }
	uint32 reserved() const { return reserved_; }
	uint32 capabilities() const { return capabilities_; }
	uint8 byte_count() const { return byte_count_; }
	vector<uint8> * security_blob() const { return security_blob_; }
	SMB_string * native_os() const { return native_os_; }
	SMB_string * native_lanman() const { return native_lanman_; }
	bool unicode() const { return unicode_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 word_count_;
	SMB_andx * andx_;
	uint16 max_buffer_size_;
	uint16 max_mpx_count_;
	uint16 vc_number_;
	uint32 session_key_;
	uint8 security_length_;
	uint32 reserved_;
	uint32 capabilities_;
	uint8 byte_count_;
	vector<uint8> * security_blob_;
	uint8 security_blob__elem_;
	SMB_string * native_os_;
	SMB_string * native_lanman_;
	bool unicode_;
	int byteorder_;
};


class SMB_setup_andx_ext_response
{
public:
	SMB_setup_andx_ext_response(bool unicode);
	~SMB_setup_andx_ext_response();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 word_count() const { return word_count_; }
	SMB_andx * andx() const { return andx_; }
	uint8 action() const { return action_; }
	uint8 security_length() const { return security_length_; }
	uint8 byte_count() const { return byte_count_; }
	vector<uint8> * security_blob() const { return security_blob_; }
	SMB_string * native_os() const { return native_os_; }
	SMB_string * native_lanman() const { return native_lanman_; }
	SMB_string * primary_domain() const { return primary_domain_; }
	bool unicode() const { return unicode_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 word_count_;
	SMB_andx * andx_;
	uint8 action_;
	uint8 security_length_;
	uint8 byte_count_;
	vector<uint8> * security_blob_;
	uint8 security_blob__elem_;
	SMB_string * native_os_;
	SMB_string * native_lanman_;
	SMB_string * primary_domain_;
	bool unicode_;
	int byteorder_;
};


class SMB_logoff_andx
{
public:
	SMB_logoff_andx(bool unicode);
	~SMB_logoff_andx();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 word_count() const { return word_count_; }
	SMB_andx * andx() const { return andx_; }
	uint16 byte_count() const { return byte_count_; }
	bool unicode() const { return unicode_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 word_count_;
	SMB_andx * andx_;
	uint16 byte_count_;
	bool unicode_;
	int byteorder_;
};


class SMB_tree_connect_andx
{
public:
	SMB_tree_connect_andx(bool unicode);
	~SMB_tree_connect_andx();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 word_count() const { return word_count_; }
	SMB_andx * andx() const { return andx_; }
	uint16 flags() const { return flags_; }
	uint16 password_length() const { return password_length_; }
	uint16 byte_count() const { return byte_count_; }
	vector<uint8> * password() const { return password_; }
	SMB_string * path() const { return path_; }
	SMB_ascii_string * service() const { return service_; }
	bool unicode() const { return unicode_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 word_count_;
	SMB_andx * andx_;
	uint16 flags_;
	uint16 password_length_;
	uint16 byte_count_;
	vector<uint8> * password_;
	uint8 password__elem_;
	SMB_string * path_;
	SMB_ascii_string * service_;
	bool unicode_;
	int byteorder_;
};


class SMB_close
{
public:
	SMB_close(bool unicode);
	~SMB_close();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 word_count() const { return word_count_; }
	uint16 fid() const { return fid_; }
	SMB_time * time() const { return time_; }
	uint16 byte_count() const { return byte_count_; }
	bool unicode() const { return unicode_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 word_count_;
	uint16 fid_;
	SMB_time * time_;
	uint16 byte_count_;
	bool unicode_;
	int byteorder_;
};


class SMB_tree_disconnect
{
public:
	SMB_tree_disconnect(bool unicode);
	~SMB_tree_disconnect();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 word_count() const { return word_count_; }
	uint16 byte_count() const { return byte_count_; }
	bool unicode() const { return unicode_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 word_count_;
	uint16 byte_count_;
	bool unicode_;
	int byteorder_;
};


class SMB_nt_create_andx
{
public:
	SMB_nt_create_andx(bool unicode);
	~SMB_nt_create_andx();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 word_count() const { return word_count_; }
	SMB_andx * andx() const { return andx_; }
	uint8 reserved() const { return reserved_; }
	uint16 name_length() const { return name_length_; }
	uint32 flags() const { return flags_; }
	vector<uint8> * rest_words() const { return rest_words_; }
	uint16 byte_count() const { return byte_count_; }
	SMB_string * name() const { return name_; }
	bool unicode() const { return unicode_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 word_count_;
	SMB_andx * andx_;
	uint8 reserved_;
	uint16 name_length_;
	uint32 flags_;
	vector<uint8> * rest_words_;
	uint8 rest_words__elem_;
	uint16 byte_count_;
	SMB_string * name_;
	bool unicode_;
	int byteorder_;
};


class SMB_read_andx
{
public:
	SMB_read_andx();
	~SMB_read_andx();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 word_count() const { return word_count_; }
	SMB_andx * andx() const { return andx_; }
	uint16 fid() const { return fid_; }
	uint32 offset() const { return offset_; }
	uint16 max_count() const { return max_count_; }
	uint16 min_count() const { return min_count_; }
	uint16 max_count_high() const { return max_count_high_; }
	uint16 remaining() const { return remaining_; }
	int offset_high_u_case_index() const	{ return offset_high_u_case_index_; }
	uint32 offset_high() const
		{
		switch ( offset_high_u_case_index() )
			{
			case 12:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-protocol.pac:320:offset_high", offset_high_u_case_index(), "((int) 12)");
				break;
			}
		return offset_high_;
		}
	uint16 byte_count() const { return byte_count_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 word_count_;
	SMB_andx * andx_;
	uint16 fid_;
	uint32 offset_;
	uint16 max_count_;
	uint16 min_count_;
	uint16 max_count_high_;
	uint16 remaining_;
	int offset_high_u_case_index_;
	uint32 offset_high_;
	uint16 byte_count_;
	int byteorder_;
};


class SMB_read_andx_response
{
public:
	SMB_read_andx_response();
	~SMB_read_andx_response();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 word_count() const { return word_count_; }
	SMB_andx * andx() const { return andx_; }
	uint16 remaining() const { return remaining_; }
	uint16 data_compact() const { return data_compact_; }
	uint16 reserved() const { return reserved_; }
	uint16 data_len() const { return data_len_; }
	uint16 data_offset() const { return data_offset_; }
	uint16 data_len_high() const { return data_len_high_; }
	vector<uint16> * reserved2() const { return reserved2_; }
	uint16 byte_count() const { return byte_count_; }
	bytestring const & data() const { return data_; }
	int byteorder() const { return byteorder_; }
	int data_length() const { return data_length_; }
	int padding_length() const { return padding_length_; }
	
protected:
	uint8 word_count_;
	SMB_andx * andx_;
	uint16 remaining_;
	uint16 data_compact_;
	uint16 reserved_;
	uint16 data_len_;
	uint16 data_offset_;
	uint16 data_len_high_;
	vector<uint16> * reserved2_;
	uint16 reserved2__elem_;
	uint16 byte_count_;
	bytestring data_;
	int byteorder_;
	int data_length_;
	int padding_length_;
};


class SMB_write_andx
{
public:
	SMB_write_andx();
	~SMB_write_andx();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 word_count() const { return word_count_; }
	SMB_andx * andx() const { return andx_; }
	uint16 fid() const { return fid_; }
	uint32 offset() const { return offset_; }
	uint32 reserved() const { return reserved_; }
	uint16 write_mode() const { return write_mode_; }
	uint16 remaining() const { return remaining_; }
	uint16 data_len_high() const { return data_len_high_; }
	uint16 data_len() const { return data_len_; }
	uint16 data_offset() const { return data_offset_; }
	vector<uint8> * rest_words() const { return rest_words_; }
	uint16 byte_count() const { return byte_count_; }
	bytestring const & data() const { return data_; }
	int byteorder() const { return byteorder_; }
	int data_length() const { return data_length_; }
	
protected:
	uint8 word_count_;
	SMB_andx * andx_;
	uint16 fid_;
	uint32 offset_;
	uint32 reserved_;
	uint16 write_mode_;
	uint16 remaining_;
	uint16 data_len_high_;
	uint16 data_len_;
	uint16 data_offset_;
	vector<uint8> * rest_words_;
	uint8 rest_words__elem_;
	uint16 byte_count_;
	bytestring data_;
	int byteorder_;
	int data_length_;
};


class SMB_write_andx_response
{
public:
	SMB_write_andx_response();
	~SMB_write_andx_response();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 word_count() const { return word_count_; }
	SMB_andx * andx() const { return andx_; }
	uint16 count() const { return count_; }
	uint16 remaining() const { return remaining_; }
	uint32 reserved() const { return reserved_; }
	uint16 byte_count() const { return byte_count_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 word_count_;
	SMB_andx * andx_;
	uint16 count_;
	uint16 remaining_;
	uint32 reserved_;
	uint16 byte_count_;
	int byteorder_;
};


class SMB_transaction_data
{
public:
	SMB_transaction_data(bool unicode, uint16 count, uint16 sub_cmd, TransactionType trans_type);
	~SMB_transaction_data();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	int val_case_index() const	{ return val_case_index_; }
	SMB_MailSlot_message * mailslot() const
		{
		switch ( val_case_index() )
			{
			case 0:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-protocol.pac:380:mailslot", val_case_index(), "SMB_MAILSLOT_BROWSE");
				break;
			}
		return mailslot_;
		}
	SMB_MailSlot_message * lanman() const
		{
		switch ( val_case_index() )
			{
			case 1:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-protocol.pac:381:lanman", val_case_index(), "SMB_MAILSLOT_LANMAN");
				break;
			}
		return lanman_;
		}
	SMB_Pipe_message * rap() const
		{
		switch ( val_case_index() )
			{
			case 3:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-protocol.pac:382:rap", val_case_index(), "SMB_RAP");
				break;
			}
		return rap_;
		}
	SMB_Pipe_message * pipe() const
		{
		switch ( val_case_index() )
			{
			case 2:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-protocol.pac:383:pipe", val_case_index(), "SMB_PIPE");
				break;
			}
		return pipe_;
		}
	bytestring const & unknown() const
		{
		switch ( val_case_index() )
			{
			case 4:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-protocol.pac:384:unknown", val_case_index(), "SMB_UNKNOWN");
				break;
			}
		return unknown_;
		}
	bytestring const & data() const
		{
		return data_;
		}
	bool unicode() const { return unicode_; }
	uint16 count() const { return count_; }
	uint16 sub_cmd() const { return sub_cmd_; }
	TransactionType trans_type() const { return trans_type_; }
	
protected:
	int val_case_index_;
	SMB_MailSlot_message * mailslot_;
	SMB_MailSlot_message * lanman_;
	SMB_Pipe_message * rap_;
	SMB_Pipe_message * pipe_;
	bytestring unknown_;
	bytestring data_;
	bool unicode_;
	uint16 count_;
	uint16 sub_cmd_;
	TransactionType trans_type_;
};


class SMB_transaction
{
public:
	SMB_transaction(int trans_type, bool unicode);
	~SMB_transaction();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 word_count() const { return word_count_; }
	uint16 total_param_count() const { return total_param_count_; }
	uint16 total_data_count() const { return total_data_count_; }
	uint16 max_param_count() const { return max_param_count_; }
	uint16 max_data_count() const { return max_data_count_; }
	uint8 max_setup_count() const { return max_setup_count_; }
	uint8 reserved() const { return reserved_; }
	uint16 flags() const { return flags_; }
	uint32 timeout() const { return timeout_; }
	uint16 reserved2() const { return reserved2_; }
	uint16 param_count() const { return param_count_; }
	uint16 param_offset() const { return param_offset_; }
	uint16 data_count() const { return data_count_; }
	uint16 data_offset() const { return data_offset_; }
	uint8 setup_count() const { return setup_count_; }
	uint8 reserved3() const { return reserved3_; }
	vector<uint16> * setup() const { return setup_; }
	uint16 byte_count() const { return byte_count_; }
	int name_u_case_index() const	{ return name_u_case_index_; }
	SMB_string * name() const
		{
		switch ( name_u_case_index() )
			{
			case 1:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-protocol.pac:409:name", name_u_case_index(), "((int) 1)");
				break;
			}
		return name_;
		}
	bytestring const & parameters() const { return parameters_; }
	SMB_transaction_data * data() const { return data_; }
	int trans_type() const { return trans_type_; }
	bool unicode() const { return unicode_; }
	int byteorder() const { return byteorder_; }
	uint16 sub_cmd() const { return sub_cmd_; }
	
protected:
	uint8 word_count_;
	uint16 total_param_count_;
	uint16 total_data_count_;
	uint16 max_param_count_;
	uint16 max_data_count_;
	uint8 max_setup_count_;
	uint8 reserved_;
	uint16 flags_;
	uint32 timeout_;
	uint16 reserved2_;
	uint16 param_count_;
	uint16 param_offset_;
	uint16 data_count_;
	uint16 data_offset_;
	uint8 setup_count_;
	uint8 reserved3_;
	vector<uint16> * setup_;
	uint16 setup__elem_;
	uint16 byte_count_;
	int name_u_case_index_;
	SMB_string * name_;
	bytestring parameters_;
	SMB_transaction_data * data_;
	int trans_type_;
	bool unicode_;
	int byteorder_;
	uint16 sub_cmd_;
};


class SMB_transaction_secondary
{
public:
	SMB_transaction_secondary(bool unicode);
	~SMB_transaction_secondary();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 word_count() const { return word_count_; }
	uint16 total_param_count() const { return total_param_count_; }
	uint16 total_data_count() const { return total_data_count_; }
	uint16 param_count() const { return param_count_; }
	uint16 param_offset() const { return param_offset_; }
	uint16 param_displacement() const { return param_displacement_; }
	uint16 data_count() const { return data_count_; }
	uint16 data_offset() const { return data_offset_; }
	uint16 data_displacement() const { return data_displacement_; }
	uint16 fid() const { return fid_; }
	uint16 byte_count() const { return byte_count_; }
	bytestring const & parameters() const { return parameters_; }
	SMB_transaction_data * data() const { return data_; }
	bool unicode() const { return unicode_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 word_count_;
	uint16 total_param_count_;
	uint16 total_data_count_;
	uint16 param_count_;
	uint16 param_offset_;
	uint16 param_displacement_;
	uint16 data_count_;
	uint16 data_offset_;
	uint16 data_displacement_;
	uint16 fid_;
	uint16 byte_count_;
	bytestring parameters_;
	SMB_transaction_data * data_;
	bool unicode_;
	int byteorder_;
};


class SMB_transaction_response
{
public:
	SMB_transaction_response(bool unicode);
	~SMB_transaction_response();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 word_count() const { return word_count_; }
	uint16 total_param_count() const { return total_param_count_; }
	uint16 total_data_count() const { return total_data_count_; }
	uint16 reserved() const { return reserved_; }
	uint16 param_count() const { return param_count_; }
	uint16 param_offset() const { return param_offset_; }
	uint16 param_displacement() const { return param_displacement_; }
	uint16 data_count() const { return data_count_; }
	uint16 data_offset() const { return data_offset_; }
	uint16 data_displacement() const { return data_displacement_; }
	uint8 setup_count() const { return setup_count_; }
	uint8 reserved2() const { return reserved2_; }
	vector<uint16> * setup() const { return setup_; }
	uint16 byte_count() const { return byte_count_; }
	bytestring const & parameters() const { return parameters_; }
	SMB_transaction_data * data() const { return data_; }
	bool unicode() const { return unicode_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 word_count_;
	uint16 total_param_count_;
	uint16 total_data_count_;
	uint16 reserved_;
	uint16 param_count_;
	uint16 param_offset_;
	uint16 param_displacement_;
	uint16 data_count_;
	uint16 data_offset_;
	uint16 data_displacement_;
	uint8 setup_count_;
	uint8 reserved2_;
	vector<uint16> * setup_;
	uint16 setup__elem_;
	uint16 byte_count_;
	bytestring parameters_;
	SMB_transaction_data * data_;
	bool unicode_;
	int byteorder_;
};


class SMB_get_dfs_referral
{
public:
	SMB_get_dfs_referral(bool unicode);
	~SMB_get_dfs_referral();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint16 max_referral_level() const { return max_referral_level_; }
	SMB_string * file_name() const { return file_name_; }
	bool unicode() const { return unicode_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint16 max_referral_level_;
	SMB_string * file_name_;
	bool unicode_;
	int byteorder_;
};


class SMB_MailSlot_message
{
public:
	SMB_MailSlot_message(bool unicode, uint16 byte_count);
	~SMB_MailSlot_message();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 opcode() const { return opcode_; }
	SMB_MailSlot_command * data() const { return data_; }
	bool unicode() const { return unicode_; }
	uint16 byte_count() const { return byte_count_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 opcode_;
	SMB_MailSlot_command * data_;
	bool unicode_;
	uint16 byte_count_;
	int byteorder_;
};


class SMB_MailSlot_command
{
public:
	SMB_MailSlot_command(bool unicode, uint8 code, uint16 byte_count);
	~SMB_MailSlot_command();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	int val_case_index() const	{ return val_case_index_; }
	SMB_MailSlot_host_announcement * announce() const
		{
		switch ( val_case_index() )
			{
			case 1:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-mailslot.pac:23:announce", val_case_index(), "HOST_ANNOUNCEMENT");
				break;
			}
		return announce_;
		}
	SMB_MailSlot_announcement_request * announce_req() const
		{
		switch ( val_case_index() )
			{
			case 2:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-mailslot.pac:24:announce_req", val_case_index(), "ANNOUCEMENT_REQUEST");
				break;
			}
		return announce_req_;
		}
	SMB_MailSlot_request_election * election_req() const
		{
		switch ( val_case_index() )
			{
			case 8:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-mailslot.pac:25:election_req", val_case_index(), "REQUEST_ELECTION");
				break;
			}
		return election_req_;
		}
	SMB_MailSlot_get_backup_list_request * get_backup_req() const
		{
		switch ( val_case_index() )
			{
			case 9:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-mailslot.pac:26:get_backup_req", val_case_index(), "GET_BACKUP_LIST_REQUEST");
				break;
			}
		return get_backup_req_;
		}
	SMB_MailSlot_get_backup_list_response * get_backup_resp() const
		{
		switch ( val_case_index() )
			{
			case 10:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-mailslot.pac:27:get_backup_resp", val_case_index(), "GET_BACKUP_LIST_RESPONSE");
				break;
			}
		return get_backup_resp_;
		}
	SMB_MailSlot_domain_announcement * domain_announce() const
		{
		switch ( val_case_index() )
			{
			case 12:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-mailslot.pac:28:domain_announce", val_case_index(), "DOMAIN_ANNOUNCEMENT");
				break;
			}
		return domain_announce_;
		}
	SMB_MailSlot_local_master_announcement * lm_announce() const
		{
		switch ( val_case_index() )
			{
			case 15:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-mailslot.pac:29:lm_announce", val_case_index(), "LOCAL_MASTER_ANNOUNCEMENT");
				break;
			}
		return lm_announce_;
		}
	bytestring const & data() const
		{
		return data_;
		}
	bool unicode() const { return unicode_; }
	uint8 code() const { return code_; }
	uint16 byte_count() const { return byte_count_; }
	int byteorder() const { return byteorder_; }
	
protected:
	int val_case_index_;
	SMB_MailSlot_host_announcement * announce_;
	SMB_MailSlot_announcement_request * announce_req_;
	SMB_MailSlot_request_election * election_req_;
	SMB_MailSlot_get_backup_list_request * get_backup_req_;
	SMB_MailSlot_get_backup_list_response * get_backup_resp_;
	SMB_MailSlot_domain_announcement * domain_announce_;
	SMB_MailSlot_local_master_announcement * lm_announce_;
	bytestring data_;
	bool unicode_;
	uint8 code_;
	uint16 byte_count_;
	int byteorder_;
};


class SMB_MailSlot_host_announcement
{
public:
	SMB_MailSlot_host_announcement(bool unicode);
	~SMB_MailSlot_host_announcement();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 update_count() const { return update_count_; }
	uint32 periodicity() const { return periodicity_; }
	SMB_string * server_name() const { return server_name_; }
	uint8 os_major_ver() const { return os_major_ver_; }
	uint8 os_minor_ver() const { return os_minor_ver_; }
	uint32 server_type() const { return server_type_; }
	uint8 bro_major_ver() const { return bro_major_ver_; }
	uint8 bro_minor_ver() const { return bro_minor_ver_; }
	uint16 signature() const { return signature_; }
	SMB_string * comment() const { return comment_; }
	bool unicode() const { return unicode_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 update_count_;
	uint32 periodicity_;
	SMB_string * server_name_;
	uint8 os_major_ver_;
	uint8 os_minor_ver_;
	uint32 server_type_;
	uint8 bro_major_ver_;
	uint8 bro_minor_ver_;
	uint16 signature_;
	SMB_string * comment_;
	bool unicode_;
	int byteorder_;
};


class SMB_MailSlot_announcement_request
{
public:
	SMB_MailSlot_announcement_request(bool unicode);
	~SMB_MailSlot_announcement_request();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 unused() const { return unused_; }
	SMB_string * response_name() const { return response_name_; }
	bool unicode() const { return unicode_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 unused_;
	SMB_string * response_name_;
	bool unicode_;
	int byteorder_;
};


class SMB_MailSlot_request_election
{
public:
	SMB_MailSlot_request_election(bool unicode);
	~SMB_MailSlot_request_election();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 version() const { return version_; }
	uint32 criteria() const { return criteria_; }
	uint32 uptime() const { return uptime_; }
	uint32 reserved() const { return reserved_; }
	SMB_string * server_name() const { return server_name_; }
	bool unicode() const { return unicode_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 version_;
	uint32 criteria_;
	uint32 uptime_;
	uint32 reserved_;
	SMB_string * server_name_;
	bool unicode_;
	int byteorder_;
};


class SMB_MailSlot_get_backup_list_request
{
public:
	SMB_MailSlot_get_backup_list_request(bool unicode);
	~SMB_MailSlot_get_backup_list_request();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 req_count() const { return req_count_; }
	uint32 token() const { return token_; }
	bool unicode() const { return unicode_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 req_count_;
	uint32 token_;
	bool unicode_;
	int byteorder_;
};


class SMB_MailSlot_get_backup_list_response
{
public:
	SMB_MailSlot_get_backup_list_response(bool unicode);
	~SMB_MailSlot_get_backup_list_response();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 backup_count() const { return backup_count_; }
	uint32 token() const { return token_; }
	SMB_string * backup_list() const { return backup_list_; }
	bool unicode() const { return unicode_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 backup_count_;
	uint32 token_;
	SMB_string * backup_list_;
	bool unicode_;
	int byteorder_;
};


class SMB_MailSlot_domain_announcement
{
public:
	SMB_MailSlot_domain_announcement(bool unicode);
	~SMB_MailSlot_domain_announcement();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 update_count() const { return update_count_; }
	uint32 periodicity() const { return periodicity_; }
	SMB_string * server_name() const { return server_name_; }
	uint8 os_major_ver() const { return os_major_ver_; }
	uint8 os_minor_ver() const { return os_minor_ver_; }
	uint32 server_type() const { return server_type_; }
	uint8 bro_major_ver() const { return bro_major_ver_; }
	uint8 bro_minor_ver() const { return bro_minor_ver_; }
	uint16 signature() const { return signature_; }
	SMB_string * comment() const { return comment_; }
	bool unicode() const { return unicode_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 update_count_;
	uint32 periodicity_;
	SMB_string * server_name_;
	uint8 os_major_ver_;
	uint8 os_minor_ver_;
	uint32 server_type_;
	uint8 bro_major_ver_;
	uint8 bro_minor_ver_;
	uint16 signature_;
	SMB_string * comment_;
	bool unicode_;
	int byteorder_;
};


class SMB_MailSlot_local_master_announcement
{
public:
	SMB_MailSlot_local_master_announcement(bool unicode);
	~SMB_MailSlot_local_master_announcement();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 update_count() const { return update_count_; }
	uint32 periodicity() const { return periodicity_; }
	SMB_string * server_name() const { return server_name_; }
	uint8 os_major_ver() const { return os_major_ver_; }
	uint8 os_minor_ver() const { return os_minor_ver_; }
	uint32 server_type() const { return server_type_; }
	uint8 bro_major_ver() const { return bro_major_ver_; }
	uint8 bro_minor_ver() const { return bro_minor_ver_; }
	uint16 signature() const { return signature_; }
	SMB_string * comment() const { return comment_; }
	bool unicode() const { return unicode_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 update_count_;
	uint32 periodicity_;
	SMB_string * server_name_;
	uint8 os_major_ver_;
	uint8 os_minor_ver_;
	uint32 server_type_;
	uint8 bro_major_ver_;
	uint8 bro_minor_ver_;
	uint16 signature_;
	SMB_string * comment_;
	bool unicode_;
	int byteorder_;
};


class SMB_Pipe_message
{
public:
	SMB_Pipe_message(bool unicode, uint16 byte_count, uint16 sub_cmd);
	~SMB_Pipe_message();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	bytestring const & data() const { return data_; }
	bool unicode() const { return unicode_; }
	uint16 byte_count() const { return byte_count_; }
	uint16 sub_cmd() const { return sub_cmd_; }
	int byteorder() const { return byteorder_; }
	
protected:
	bytestring data_;
	bool unicode_;
	uint16 byte_count_;
	uint16 sub_cmd_;
	int byteorder_;
};


class SMB_RAP_message
{
public:
	SMB_RAP_message(bool unicode, uint16 byte_count);
	~SMB_RAP_message();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint16 rap_code() const { return rap_code_; }
	SMB_string * param_desc() const { return param_desc_; }
	SMB_string * data_desc() const { return data_desc_; }
	bytestring const & data() const { return data_; }
	bool unicode() const { return unicode_; }
	uint16 byte_count() const { return byte_count_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint16 rap_code_;
	SMB_string * param_desc_;
	SMB_string * data_desc_;
	bytestring data_;
	bool unicode_;
	uint16 byte_count_;
	int byteorder_;
};

} // namespace SMB
}  // namespace binpac
#endif /* _home_benjamin_Bro_bro_2_3_1_src_analyzer_protocol_smb_smb_pac_h */

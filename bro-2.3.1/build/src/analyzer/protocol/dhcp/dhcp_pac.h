// This file is automatically generated from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dhcp/dhcp.pac.

#ifndef _home_benjamin_Bro_bro_2_3_1_src_analyzer_protocol_dhcp_dhcp_pac_h
#define _home_benjamin_Bro_bro_2_3_1_src_analyzer_protocol_dhcp_dhcp_pac_h

#include <vector>

#include "binpac.h"


#include "binpac_bro.h"


#include "events.bif.h"

namespace binpac {

namespace DHCP {
class ContextDHCP;
enum OP_type {
	BOOTREQUEST = 1,
	BOOTREPLY = 2,
};
enum OPTION_type {
	SUBNET_OPTION = 1,
	ROUTER_OPTION = 3,
	HOST_NAME_OPTION = 12,
	REQ_IP_OPTION = 50,
	LEASE_OPTION = 51,
	MSG_TYPE_OPTION = 53,
	SERV_ID_OPTION = 54,
	END_OPTION = 255,
};
enum DHCP_message_type {
	DHCPDISCOVER = 1,
	DHCPOFFER = 2,
	DHCPREQUEST = 3,
	DHCPDECLINE = 4,
	DHCPACK = 5,
	DHCPNAK = 6,
	DHCPRELEASE = 7,
	DHCPINFORM = 8,
};
class Option_Info;
class DHCP_Option;
class DHCP_Message;
class DHCP_Conn;
class DHCP_Flow;
} // namespace DHCP

int bytestring_to_int(const_bytestring const & s, int base);
double bytestring_to_double(const_bytestring const & s);
int bytestring_casecmp(const_bytestring const & s1, const_charptr const & s2);
bool bytestring_caseprefix(const_bytestring const & s1, const_charptr const & s2);
double network_time();
namespace DHCP {

class ContextDHCP
{
public:
	ContextDHCP(DHCP_Conn * connection, DHCP_Flow * flow);
	~ContextDHCP();
	
	// Member access functions
	DHCP_Conn * connection() const { return connection_; }
	DHCP_Flow * flow() const { return flow_; }
	
protected:
	DHCP_Conn * connection_;
	DHCP_Flow * flow_;
};


class Option_Info
{
public:
	Option_Info(uint8 code);
	~Option_Info();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder);
	
	// Member access functions
	uint8 length() const { return length_; }
	int value_case_index() const	{ return value_case_index_; }
	uint32 mask() const
		{
		switch ( value_case_index() )
			{
			case 1:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dhcp/dhcp-protocol.pac:38:mask", value_case_index(), "SUBNET_OPTION");
				break;
			}
		return mask_;
		}
	vector<uint32> * router_list() const
		{
		switch ( value_case_index() )
			{
			case 3:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dhcp/dhcp-protocol.pac:39:router_list", value_case_index(), "ROUTER_OPTION");
				break;
			}
		return router_list_;
		}
	uint32 req_addr() const
		{
		switch ( value_case_index() )
			{
			case 50:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dhcp/dhcp-protocol.pac:40:req_addr", value_case_index(), "REQ_IP_OPTION");
				break;
			}
		return req_addr_;
		}
	uint32 lease() const
		{
		switch ( value_case_index() )
			{
			case 51:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dhcp/dhcp-protocol.pac:41:lease", value_case_index(), "LEASE_OPTION");
				break;
			}
		return lease_;
		}
	uint8 msg_type() const
		{
		switch ( value_case_index() )
			{
			case 53:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dhcp/dhcp-protocol.pac:42:msg_type", value_case_index(), "MSG_TYPE_OPTION");
				break;
			}
		return msg_type_;
		}
	uint32 serv_addr() const
		{
		switch ( value_case_index() )
			{
			case 54:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dhcp/dhcp-protocol.pac:43:serv_addr", value_case_index(), "SERV_ID_OPTION");
				break;
			}
		return serv_addr_;
		}
	bytestring const & host_name() const
		{
		switch ( value_case_index() )
			{
			case 12:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dhcp/dhcp-protocol.pac:44:host_name", value_case_index(), "HOST_NAME_OPTION");
				break;
			}
		return host_name_;
		}
	bytestring const & other() const
		{
		return other_;
		}
	uint8 code() const { return code_; }
	
protected:
	uint8 length_;
	int value_case_index_;
	uint32 mask_;
	vector<uint32> * router_list_;
	uint32 router_list__elem_;
	uint32 req_addr_;
	uint32 lease_;
	uint8 msg_type_;
	uint32 serv_addr_;
	bytestring host_name_;
	bytestring other_;
	uint8 code_;
};


class DHCP_Option
{
public:
	DHCP_Option();
	~DHCP_Option();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder);
	
	// Member access functions
	uint8 code() const { return code_; }
	int data_case_index() const	{ return data_case_index_; }
	Option_Info * info() const
		{
		return info_;
		}
	bool last() const { return last_; }
	
protected:
	uint8 code_;
	int data_case_index_;
	Option_Info * info_;
	bool last_;
};


class DHCP_Message
{
public:
	DHCP_Message();
	~DHCP_Message();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDHCP * t_context);
	
	// Member access functions
	uint8 op() const { return op_; }
	uint8 htype() const { return htype_; }
	uint8 hlen() const { return hlen_; }
	uint8 hops() const { return hops_; }
	uint32 xid() const { return xid_; }
	uint16 secs() const { return secs_; }
	uint16 flags() const { return flags_; }
	uint32 ciaddr() const { return ciaddr_; }
	uint32 yiaddr() const { return yiaddr_; }
	uint32 siaddr() const { return siaddr_; }
	uint32 giaddr() const { return giaddr_; }
	bytestring const & chaddr() const { return chaddr_; }
	bytestring const & sname() const { return sname_; }
	bytestring const & file() const { return file_; }
	uint32 cookie() const { return cookie_; }
	vector<DHCP_Option *> * options() const { return options_; }
	int byteorder() const { return byteorder_; }
	uint8 type() const { return type_; }
	int proc_dhcp_message() const { return proc_dhcp_message_; }
	
protected:
	uint8 op_;
	uint8 htype_;
	uint8 hlen_;
	uint8 hops_;
	uint32 xid_;
	uint16 secs_;
	uint16 flags_;
	uint32 ciaddr_;
	uint32 yiaddr_;
	uint32 siaddr_;
	uint32 giaddr_;
	bytestring chaddr_;
	bytestring sname_;
	bytestring file_;
	uint32 cookie_;
	vector<DHCP_Option *> * options_;
	DHCP_Option * options__elem_;
	int byteorder_;
	uint8 type_;
	int proc_dhcp_message_;
};


class DHCP_Conn : public binpac::ConnectionAnalyzer
{
public:
	DHCP_Conn(BroAnalyzer const & bro_analyzer);
	~DHCP_Conn();
	
	// Member access functions
	DHCP_Flow * upflow() const { return upflow_; }
	DHCP_Flow * downflow() const { return downflow_; }
	BroAnalyzer const & bro_analyzer() const { return bro_analyzer_; }
	
	void NewData(bool is_orig, const_byteptr begin, const_byteptr end);
	void NewGap(bool is_orig, int gap_length);
	void FlowEOF(bool is_orig);
	
protected:
	DHCP_Flow * upflow_;
	DHCP_Flow * downflow_;
	BroAnalyzer bro_analyzer_;
};


class DHCP_Flow : public binpac::FlowAnalyzer
{
public:
	DHCP_Flow(DHCP_Conn * connection, bool is_orig);
	~DHCP_Flow();
	
	// Member access functions
	DHCP_Conn * connection() const { return connection_; }
	bool is_orig() const { return is_orig_; }
	
	void NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data);
	void NewGap(int gap_length);
	void FlowEOF();
	
	// Functions
	uint8 get_dhcp_msgtype(vector<DHCP_Option *> * options);
	bool parse_request(vector<DHCP_Option *> * options, uint8 type);
	bool parse_reply(vector<DHCP_Option *> * options, uint8 type);
	bool process_dhcp_message(DHCP_Message * msg);
	
protected:
	DHCP_Message * dataunit_;
	ContextDHCP * context_;
	
	// Additional members

		BroVal dhcp_msg_val_;
	
	DHCP_Conn * connection_;
	bool is_orig_;
};

} // namespace DHCP
}  // namespace binpac
#endif /* _home_benjamin_Bro_bro_2_3_1_src_analyzer_protocol_dhcp_dhcp_pac_h */

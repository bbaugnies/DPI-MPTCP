// This file was automatically generated by bifcl from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dns/events.bif (plugin mode).


#include "events.bif.h"

EventHandlerPtr dns_message; 
void BifEvent::generate_dns_message(analyzer::Analyzer* analyzer, Connection* c, int is_orig, Val* msg, bro_uint_t len)
	{
	// Note that it is intentional that here we do not
	// check if ::dns_message is NULL, which should happen *before*
	// BifEvent::generate_dns_message is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(msg);
	vl->append(new Val(len, TYPE_COUNT));

	mgr.QueueEvent(::dns_message, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dns_request; 
void BifEvent::generate_dns_request(analyzer::Analyzer* analyzer, Connection* c, Val* msg, StringVal* query, bro_uint_t qtype, bro_uint_t qclass)
	{
	// Note that it is intentional that here we do not
	// check if ::dns_request is NULL, which should happen *before*
	// BifEvent::generate_dns_request is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(msg);
	vl->append(query);
	vl->append(new Val(qtype, TYPE_COUNT));
	vl->append(new Val(qclass, TYPE_COUNT));

	mgr.QueueEvent(::dns_request, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dns_rejected; 
void BifEvent::generate_dns_rejected(analyzer::Analyzer* analyzer, Connection* c, Val* msg, StringVal* query, bro_uint_t qtype, bro_uint_t qclass)
	{
	// Note that it is intentional that here we do not
	// check if ::dns_rejected is NULL, which should happen *before*
	// BifEvent::generate_dns_rejected is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(msg);
	vl->append(query);
	vl->append(new Val(qtype, TYPE_COUNT));
	vl->append(new Val(qclass, TYPE_COUNT));

	mgr.QueueEvent(::dns_rejected, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dns_query_reply; 
void BifEvent::generate_dns_query_reply(analyzer::Analyzer* analyzer, Connection* c, Val* msg, StringVal* query, bro_uint_t qtype, bro_uint_t qclass)
	{
	// Note that it is intentional that here we do not
	// check if ::dns_query_reply is NULL, which should happen *before*
	// BifEvent::generate_dns_query_reply is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(msg);
	vl->append(query);
	vl->append(new Val(qtype, TYPE_COUNT));
	vl->append(new Val(qclass, TYPE_COUNT));

	mgr.QueueEvent(::dns_query_reply, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dns_A_reply; 
void BifEvent::generate_dns_A_reply(analyzer::Analyzer* analyzer, Connection* c, Val* msg, Val* ans, AddrVal* a)
	{
	// Note that it is intentional that here we do not
	// check if ::dns_A_reply is NULL, which should happen *before*
	// BifEvent::generate_dns_A_reply is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(msg);
	vl->append(ans);
	vl->append(a);

	mgr.QueueEvent(::dns_A_reply, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dns_AAAA_reply; 
void BifEvent::generate_dns_AAAA_reply(analyzer::Analyzer* analyzer, Connection* c, Val* msg, Val* ans, AddrVal* a)
	{
	// Note that it is intentional that here we do not
	// check if ::dns_AAAA_reply is NULL, which should happen *before*
	// BifEvent::generate_dns_AAAA_reply is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(msg);
	vl->append(ans);
	vl->append(a);

	mgr.QueueEvent(::dns_AAAA_reply, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dns_A6_reply; 
void BifEvent::generate_dns_A6_reply(analyzer::Analyzer* analyzer, Connection* c, Val* msg, Val* ans, AddrVal* a)
	{
	// Note that it is intentional that here we do not
	// check if ::dns_A6_reply is NULL, which should happen *before*
	// BifEvent::generate_dns_A6_reply is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(msg);
	vl->append(ans);
	vl->append(a);

	mgr.QueueEvent(::dns_A6_reply, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dns_NS_reply; 
void BifEvent::generate_dns_NS_reply(analyzer::Analyzer* analyzer, Connection* c, Val* msg, Val* ans, StringVal* name)
	{
	// Note that it is intentional that here we do not
	// check if ::dns_NS_reply is NULL, which should happen *before*
	// BifEvent::generate_dns_NS_reply is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(msg);
	vl->append(ans);
	vl->append(name);

	mgr.QueueEvent(::dns_NS_reply, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dns_CNAME_reply; 
void BifEvent::generate_dns_CNAME_reply(analyzer::Analyzer* analyzer, Connection* c, Val* msg, Val* ans, StringVal* name)
	{
	// Note that it is intentional that here we do not
	// check if ::dns_CNAME_reply is NULL, which should happen *before*
	// BifEvent::generate_dns_CNAME_reply is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(msg);
	vl->append(ans);
	vl->append(name);

	mgr.QueueEvent(::dns_CNAME_reply, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dns_PTR_reply; 
void BifEvent::generate_dns_PTR_reply(analyzer::Analyzer* analyzer, Connection* c, Val* msg, Val* ans, StringVal* name)
	{
	// Note that it is intentional that here we do not
	// check if ::dns_PTR_reply is NULL, which should happen *before*
	// BifEvent::generate_dns_PTR_reply is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(msg);
	vl->append(ans);
	vl->append(name);

	mgr.QueueEvent(::dns_PTR_reply, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dns_SOA_reply; 
void BifEvent::generate_dns_SOA_reply(analyzer::Analyzer* analyzer, Connection* c, Val* msg, Val* ans, Val* soa)
	{
	// Note that it is intentional that here we do not
	// check if ::dns_SOA_reply is NULL, which should happen *before*
	// BifEvent::generate_dns_SOA_reply is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(msg);
	vl->append(ans);
	vl->append(soa);

	mgr.QueueEvent(::dns_SOA_reply, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dns_WKS_reply; 
void BifEvent::generate_dns_WKS_reply(analyzer::Analyzer* analyzer, Connection* c, Val* msg, Val* ans)
	{
	// Note that it is intentional that here we do not
	// check if ::dns_WKS_reply is NULL, which should happen *before*
	// BifEvent::generate_dns_WKS_reply is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(msg);
	vl->append(ans);

	mgr.QueueEvent(::dns_WKS_reply, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dns_HINFO_reply; 
void BifEvent::generate_dns_HINFO_reply(analyzer::Analyzer* analyzer, Connection* c, Val* msg, Val* ans)
	{
	// Note that it is intentional that here we do not
	// check if ::dns_HINFO_reply is NULL, which should happen *before*
	// BifEvent::generate_dns_HINFO_reply is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(msg);
	vl->append(ans);

	mgr.QueueEvent(::dns_HINFO_reply, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dns_MX_reply; 
void BifEvent::generate_dns_MX_reply(analyzer::Analyzer* analyzer, Connection* c, Val* msg, Val* ans, StringVal* name, bro_uint_t preference)
	{
	// Note that it is intentional that here we do not
	// check if ::dns_MX_reply is NULL, which should happen *before*
	// BifEvent::generate_dns_MX_reply is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(msg);
	vl->append(ans);
	vl->append(name);
	vl->append(new Val(preference, TYPE_COUNT));

	mgr.QueueEvent(::dns_MX_reply, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dns_TXT_reply; 
void BifEvent::generate_dns_TXT_reply(analyzer::Analyzer* analyzer, Connection* c, Val* msg, Val* ans, Val* strs)
	{
	// Note that it is intentional that here we do not
	// check if ::dns_TXT_reply is NULL, which should happen *before*
	// BifEvent::generate_dns_TXT_reply is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(msg);
	vl->append(ans);
	vl->append(strs);

	mgr.QueueEvent(::dns_TXT_reply, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dns_SRV_reply; 
void BifEvent::generate_dns_SRV_reply(analyzer::Analyzer* analyzer, Connection* c, Val* msg, Val* ans, StringVal* target, bro_uint_t priority, bro_uint_t weight, bro_uint_t p)
	{
	// Note that it is intentional that here we do not
	// check if ::dns_SRV_reply is NULL, which should happen *before*
	// BifEvent::generate_dns_SRV_reply is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(msg);
	vl->append(ans);
	vl->append(target);
	vl->append(new Val(priority, TYPE_COUNT));
	vl->append(new Val(weight, TYPE_COUNT));
	vl->append(new Val(p, TYPE_COUNT));

	mgr.QueueEvent(::dns_SRV_reply, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dns_unknown_reply; 
void BifEvent::generate_dns_unknown_reply(analyzer::Analyzer* analyzer, Connection* c, Val* msg, Val* ans)
	{
	// Note that it is intentional that here we do not
	// check if ::dns_unknown_reply is NULL, which should happen *before*
	// BifEvent::generate_dns_unknown_reply is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(msg);
	vl->append(ans);

	mgr.QueueEvent(::dns_unknown_reply, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dns_EDNS_addl; 
void BifEvent::generate_dns_EDNS_addl(analyzer::Analyzer* analyzer, Connection* c, Val* msg, Val* ans)
	{
	// Note that it is intentional that here we do not
	// check if ::dns_EDNS_addl is NULL, which should happen *before*
	// BifEvent::generate_dns_EDNS_addl is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(msg);
	vl->append(ans);

	mgr.QueueEvent(::dns_EDNS_addl, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dns_TSIG_addl; 
void BifEvent::generate_dns_TSIG_addl(analyzer::Analyzer* analyzer, Connection* c, Val* msg, Val* ans)
	{
	// Note that it is intentional that here we do not
	// check if ::dns_TSIG_addl is NULL, which should happen *before*
	// BifEvent::generate_dns_TSIG_addl is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(msg);
	vl->append(ans);

	mgr.QueueEvent(::dns_TSIG_addl, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dns_end; 
void BifEvent::generate_dns_end(analyzer::Analyzer* analyzer, Connection* c, Val* msg)
	{
	// Note that it is intentional that here we do not
	// check if ::dns_end is NULL, which should happen *before*
	// BifEvent::generate_dns_end is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(msg);

	mgr.QueueEvent(::dns_end, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dns_full_request; 
void BifEvent::generate_dns_full_request(analyzer::Analyzer* analyzer)
	{
	// Note that it is intentional that here we do not
	// check if ::dns_full_request is NULL, which should happen *before*
	// BifEvent::generate_dns_full_request is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;


	mgr.QueueEvent(::dns_full_request, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
EventHandlerPtr non_dns_request; 
void BifEvent::generate_non_dns_request(analyzer::Analyzer* analyzer, Connection* c, StringVal* msg)
	{
	// Note that it is intentional that here we do not
	// check if ::non_dns_request is NULL, which should happen *before*
	// BifEvent::generate_non_dns_request is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(msg);

	mgr.QueueEvent(::non_dns_request, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation

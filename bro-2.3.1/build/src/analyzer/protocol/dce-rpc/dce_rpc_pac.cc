// This file is automatically generated from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dce-rpc/dce_rpc.pac.


#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include "/home/benjamin/Bro/bro-2.3.1/build/src/analyzer/protocol/dce-rpc/dce_rpc_pac.h"

namespace binpac {






namespace DCE_RPC {
ContextDCE_RPC::ContextDCE_RPC(DCE_RPC_Conn * connection, DCE_RPC_Flow * flow, FlowBuffer * flow_buffer)
	{
	connection_ = connection;
	flow_ = flow;
	flow_buffer_ = flow_buffer;
	}

ContextDCE_RPC::~ContextDCE_RPC()
	{
	}

context_handle::context_handle()
	{
	cxt_attributes_ = 0;
	}

context_handle::~context_handle()
	{
	cxt_uuid_.free();
	}

int context_handle::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "context_handle:cxt_attributes"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("context_handle:cxt_attributes",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "cxt_attributes"
	cxt_attributes_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "cxt_uuid"
	// Checking out-of-bound for "context_handle:cxt_uuid"
	if ( (t_begin_of_data + 4) + (16) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("context_handle:cxt_uuid",
			(4) + (16), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 4) + 16;
	int t_cxt_uuid_string_length;
	t_cxt_uuid_string_length = 16;
	int t_cxt_uuid__size;
	t_cxt_uuid__size = t_cxt_uuid_string_length;
	cxt_uuid_.init((t_begin_of_data + 4), t_cxt_uuid_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_context_handle__size;
	const_byteptr const t_dataptr_after_cxt_uuid = (t_begin_of_data + 4) + (16);
	BINPAC_ASSERT(t_dataptr_after_cxt_uuid <= t_end_of_data);
	t_context_handle__size = t_dataptr_after_cxt_uuid - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_context_handle__size) <= t_end_of_data);
	return t_context_handle__size;
	}

rpc_if_id_t::rpc_if_id_t()
	{
	vers_major_ = 0;
	vers_minor_ = 0;
	}

rpc_if_id_t::~rpc_if_id_t()
	{
	if_uuid_.free();
	}

int rpc_if_id_t::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Parse "if_uuid"
	// Checking out-of-bound for "rpc_if_id_t:if_uuid"
	if ( t_begin_of_data + (16) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("rpc_if_id_t:if_uuid",
			(0) + (16), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + 16;
	int t_if_uuid_string_length;
	t_if_uuid_string_length = 16;
	int t_if_uuid__size;
	t_if_uuid__size = t_if_uuid_string_length;
	if_uuid_.init(t_begin_of_data, t_if_uuid_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_if_uuid = t_begin_of_data + (16);
	BINPAC_ASSERT(t_dataptr_after_if_uuid <= t_end_of_data);
	// Checking out-of-bound for "rpc_if_id_t:vers_minor"
	if ( (t_dataptr_after_if_uuid + 2) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("rpc_if_id_t:vers_minor",
			(((t_dataptr_after_if_uuid + 2) - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "vers_major"
	vers_major_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_dataptr_after_if_uuid)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "vers_minor"
	vers_minor_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_dataptr_after_if_uuid + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	int t_rpc_if_id_t__size;
	t_rpc_if_id_t__size = (t_dataptr_after_if_uuid + 4) - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_rpc_if_id_t__size) <= t_end_of_data);
	return t_rpc_if_id_t__size;
	}

NDR_Format::NDR_Format()
	{
	intchar_ = 0;
	floatspec_ = 0;
	byteorder_ = 0;
	}

NDR_Format::~NDR_Format()
	{
	}

int NDR_Format::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "NDR_Format"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NDR_Format",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "intchar"
	intchar_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "floatspec"
	floatspec_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	
	// Evaluate 'let' and 'withinput' fields
	byteorder_ =  ( intchar() >> 4 )  ? littleendian : bigendian;
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

DCE_RPC_Header::DCE_RPC_Header()
	{
	rpc_vers_ = 0;
	rpc_vers_minor_ = 0;
	PTYPE_ = 0;
	pfc_flags_ = 0;
	packed_drep_ = 0;
	frag_length_ = 0;
	auth_length_ = 0;
	call_id_ = 0;
	byteorder_ = 0;
	frag_ = 0;
	lastfrag_ = 0;
	}

DCE_RPC_Header::~DCE_RPC_Header()
	{
	delete packed_drep_;
	packed_drep_ = 0;
	}

int DCE_RPC_Header::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "DCE_RPC_Header"
	if ( t_begin_of_data + (16) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DCE_RPC_Header",
			(0) + (16), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "rpc_vers"
	rpc_vers_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "rpc_vers_minor"
	rpc_vers_minor_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "PTYPE"
	PTYPE_ = *((uint8 const *) ((t_begin_of_data + 2)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "pfc_flags"
	pfc_flags_ = *((uint8 const *) ((t_begin_of_data + 3)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "packed_drep"
	packed_drep_ = new NDR_Format();
	packed_drep_->Parse((t_begin_of_data + 4), t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "frag_length"
	byteorder_ = packed_drep()->byteorder();
	frag_length_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 8))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "auth_length"
	auth_length_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 10))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "call_id"
	call_id_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 12))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	frag_ = pfc_flags() & 4;
	lastfrag_ =  ( ! frag() )  ||  ( pfc_flags() & 2 ) ;
	BINPAC_ASSERT(t_begin_of_data + (16) <= t_end_of_data);
	return 16;
	}

p_context_id_t::p_context_id_t()
	{
	val_ = 0;
	}

p_context_id_t::~p_context_id_t()
	{
	}

int p_context_id_t::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "p_context_id_t:val"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("p_context_id_t:val",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	val_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (2) <= t_end_of_data);
	return 2;
	}

p_syntax_id_t::p_syntax_id_t()
	{
	if_version_ = 0;
	}

p_syntax_id_t::~p_syntax_id_t()
	{
	if_uuid_.free();
	}

int p_syntax_id_t::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Parse "if_uuid"
	// Checking out-of-bound for "p_syntax_id_t:if_uuid"
	if ( t_begin_of_data + (16) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("p_syntax_id_t:if_uuid",
			(0) + (16), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + 16;
	int t_if_uuid_string_length;
	t_if_uuid_string_length = 16;
	int t_if_uuid__size;
	t_if_uuid__size = t_if_uuid_string_length;
	if_uuid_.init(t_begin_of_data, t_if_uuid_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_if_uuid = t_begin_of_data + (16);
	BINPAC_ASSERT(t_dataptr_after_if_uuid <= t_end_of_data);
	// Checking out-of-bound for "p_syntax_id_t:if_version"
	if ( t_dataptr_after_if_uuid + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("p_syntax_id_t:if_version",
			((t_dataptr_after_if_uuid - t_begin_of_data)) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "if_version"
	if_version_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_dataptr_after_if_uuid)));
	// Evaluate 'let' and 'withinput' fields
	
	int t_p_syntax_id_t__size;
	t_p_syntax_id_t__size = (t_dataptr_after_if_uuid + 4) - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_p_syntax_id_t__size) <= t_end_of_data);
	return t_p_syntax_id_t__size;
	}

p_cont_elem_t::p_cont_elem_t()
	{
	p_cont_id_ = 0;
	n_transfer_syn_ = 0;
	abstract_syntax_ = 0;
	transfer_syntaxes_ = 0;
	transfer_syntaxes__elem_ = 0;
	}

p_cont_elem_t::~p_cont_elem_t()
	{
	delete abstract_syntax_;
	abstract_syntax_ = 0;
	delete transfer_syntaxes__elem_;
	transfer_syntaxes__elem_ = 0;
	if ( transfer_syntaxes() )
		{
		for ( int i = 0; i < (int) transfer_syntaxes()->size(); ++i )
			{
			p_syntax_id_t * transfer_syntaxes__elem_ = (*transfer_syntaxes_)[i];
			delete transfer_syntaxes__elem_;
			transfer_syntaxes__elem_ = 0;
			}
		}
	delete transfer_syntaxes_;
	}

int p_cont_elem_t::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "p_cont_elem_t:reserved"
	if ( (t_begin_of_data + 3) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("p_cont_elem_t:reserved",
			(3) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "p_cont_id"
	p_cont_id_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "n_transfer_syn"
	n_transfer_syn_ = *((uint8 const *) ((t_begin_of_data + 2)));
	// Evaluate 'let' and 'withinput' fields
	
	
	// Parse "abstract_syntax"
	abstract_syntax_ = new p_syntax_id_t();
	int t_abstract_syntax__size;
	t_abstract_syntax__size = abstract_syntax_->Parse((t_begin_of_data + 4), t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_abstract_syntax = (t_begin_of_data + 4) + (t_abstract_syntax__size);
	BINPAC_ASSERT(t_dataptr_after_abstract_syntax <= t_end_of_data);
	// Parse "transfer_syntaxes"
	int t_transfer_syntaxes__arraylength;
	t_transfer_syntaxes__arraylength = 0;
	t_transfer_syntaxes__arraylength = n_transfer_syn();
	if ( t_begin_of_data + t_transfer_syntaxes__arraylength > t_end_of_data + 1 )
		{
		t_transfer_syntaxes__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_transfer_syntaxes__arraylength < 0 )
		{
		t_transfer_syntaxes__arraylength = 0;
		}
	transfer_syntaxes__elem_ = 0;
	int t_transfer_syntaxes__elem__it;
	t_transfer_syntaxes__elem__it = 0;
	int t_transfer_syntaxes__size;
	transfer_syntaxes_ = new vector<p_syntax_id_t *>;
	transfer_syntaxes_->reserve(t_transfer_syntaxes__arraylength);
	const_byteptr t_transfer_syntaxes__elem__dataptr = t_dataptr_after_abstract_syntax;
	for (; t_transfer_syntaxes__elem__it < t_transfer_syntaxes__arraylength; ++t_transfer_syntaxes__elem__it)
		{
		// Check &until(transfer_syntaxes__elem__dataptr >= end_of_data)
		if ( t_transfer_syntaxes__elem__dataptr >= t_end_of_data )
			{
			transfer_syntaxes__elem_ = 0;
			goto end_of_transfer_syntaxes;
			}
		transfer_syntaxes__elem_ = new p_syntax_id_t();
		int t_transfer_syntaxes__elem__size;
		t_transfer_syntaxes__elem__size = transfer_syntaxes__elem_->Parse(t_transfer_syntaxes__elem__dataptr, t_end_of_data, t_byteorder);
		// Evaluate 'let' and 'withinput' fields
		transfer_syntaxes_->push_back(transfer_syntaxes__elem_);
		t_transfer_syntaxes__elem__dataptr += t_transfer_syntaxes__elem__size;
		BINPAC_ASSERT(t_transfer_syntaxes__elem__dataptr <= t_end_of_data);
		transfer_syntaxes__elem_ = 0;
		}
end_of_transfer_syntaxes: ;
	t_transfer_syntaxes__size = t_transfer_syntaxes__elem__dataptr - (t_dataptr_after_abstract_syntax);
	// Evaluate 'let' and 'withinput' fields
	
	int t_p_cont_elem_t__size;
	const_byteptr const t_dataptr_after_transfer_syntaxes = t_dataptr_after_abstract_syntax + (t_transfer_syntaxes__size);
	BINPAC_ASSERT(t_dataptr_after_transfer_syntaxes <= t_end_of_data);
	t_p_cont_elem_t__size = t_dataptr_after_transfer_syntaxes - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_p_cont_elem_t__size) <= t_end_of_data);
	return t_p_cont_elem_t__size;
	}

p_cont_list_t::p_cont_list_t()
	{
	n_context_elem_ = 0;
	p_cont_elem_ = 0;
	p_cont_elem__elem_ = 0;
	}

p_cont_list_t::~p_cont_list_t()
	{
	delete p_cont_elem__elem_;
	p_cont_elem__elem_ = 0;
	if ( p_cont_elem() )
		{
		for ( int i = 0; i < (int) p_cont_elem()->size(); ++i )
			{
			p_cont_elem_t * p_cont_elem__elem_ = (*p_cont_elem_)[i];
			delete p_cont_elem__elem_;
			p_cont_elem__elem_ = 0;
			}
		}
	delete p_cont_elem_;
	}

int p_cont_list_t::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "p_cont_list_t:reserved"
	if ( (t_begin_of_data + 1) + (3) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("p_cont_list_t:reserved",
			(1) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "n_context_elem"
	n_context_elem_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	
	// Parse "p_cont_elem"
	int t_p_cont_elem__arraylength;
	t_p_cont_elem__arraylength = 0;
	t_p_cont_elem__arraylength = n_context_elem();
	if ( t_begin_of_data + t_p_cont_elem__arraylength > t_end_of_data + 1 )
		{
		t_p_cont_elem__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_p_cont_elem__arraylength < 0 )
		{
		t_p_cont_elem__arraylength = 0;
		}
	p_cont_elem__elem_ = 0;
	int t_p_cont_elem__elem__it;
	t_p_cont_elem__elem__it = 0;
	int t_p_cont_elem__size;
	p_cont_elem_ = new vector<p_cont_elem_t *>;
	p_cont_elem_->reserve(t_p_cont_elem__arraylength);
	const_byteptr t_p_cont_elem__elem__dataptr = (t_begin_of_data + 4);
	for (; t_p_cont_elem__elem__it < t_p_cont_elem__arraylength; ++t_p_cont_elem__elem__it)
		{
		// Check &until(p_cont_elem__elem__dataptr >= end_of_data)
		if ( t_p_cont_elem__elem__dataptr >= t_end_of_data )
			{
			p_cont_elem__elem_ = 0;
			goto end_of_p_cont_elem;
			}
		p_cont_elem__elem_ = new p_cont_elem_t();
		int t_p_cont_elem__elem__size;
		t_p_cont_elem__elem__size = p_cont_elem__elem_->Parse(t_p_cont_elem__elem__dataptr, t_end_of_data, t_byteorder);
		// Evaluate 'let' and 'withinput' fields
		p_cont_elem_->push_back(p_cont_elem__elem_);
		t_p_cont_elem__elem__dataptr += t_p_cont_elem__elem__size;
		BINPAC_ASSERT(t_p_cont_elem__elem__dataptr <= t_end_of_data);
		p_cont_elem__elem_ = 0;
		}
end_of_p_cont_elem: ;
	t_p_cont_elem__size = t_p_cont_elem__elem__dataptr - ((t_begin_of_data + 4));
	// Evaluate 'let' and 'withinput' fields
	
	int t_p_cont_list_t__size;
	const_byteptr const t_dataptr_after_p_cont_elem = (t_begin_of_data + 4) + (t_p_cont_elem__size);
	BINPAC_ASSERT(t_dataptr_after_p_cont_elem <= t_end_of_data);
	t_p_cont_list_t__size = t_dataptr_after_p_cont_elem - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_p_cont_list_t__size) <= t_end_of_data);
	return t_p_cont_list_t__size;
	}

DCE_RPC_Bind::DCE_RPC_Bind()
	{
	max_xmit_frag_ = 0;
	max_recv_frag_ = 0;
	assoc_group_id_ = 0;
	p_context_elem_ = 0;
	}

DCE_RPC_Bind::~DCE_RPC_Bind()
	{
	delete p_context_elem_;
	p_context_elem_ = 0;
	}

int DCE_RPC_Bind::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "DCE_RPC_Bind:assoc_group_id"
	if ( (t_begin_of_data + 4) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DCE_RPC_Bind:assoc_group_id",
			(4) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "max_xmit_frag"
	max_xmit_frag_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "max_recv_frag"
	max_recv_frag_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "assoc_group_id"
	assoc_group_id_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "p_context_elem"
	p_context_elem_ = new p_cont_list_t();
	int t_p_context_elem__size;
	t_p_context_elem__size = p_context_elem_->Parse((t_begin_of_data + 8), t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	int t_DCE_RPC_Bind__size;
	const_byteptr const t_dataptr_after_p_context_elem = (t_begin_of_data + 8) + (t_p_context_elem__size);
	BINPAC_ASSERT(t_dataptr_after_p_context_elem <= t_end_of_data);
	t_DCE_RPC_Bind__size = t_dataptr_after_p_context_elem - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_DCE_RPC_Bind__size) <= t_end_of_data);
	return t_DCE_RPC_Bind__size;
	}

DCE_RPC_AlterContext::DCE_RPC_AlterContext()
	{
	max_xmit_frag_ = 0;
	max_recv_frag_ = 0;
	assoc_group_id_ = 0;
	p_context_elem_ = 0;
	}

DCE_RPC_AlterContext::~DCE_RPC_AlterContext()
	{
	delete p_context_elem_;
	p_context_elem_ = 0;
	}

int DCE_RPC_AlterContext::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "DCE_RPC_AlterContext:assoc_group_id"
	if ( (t_begin_of_data + 4) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DCE_RPC_AlterContext:assoc_group_id",
			(4) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "max_xmit_frag"
	max_xmit_frag_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "max_recv_frag"
	max_recv_frag_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "assoc_group_id"
	assoc_group_id_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "p_context_elem"
	p_context_elem_ = new p_cont_list_t();
	int t_p_context_elem__size;
	t_p_context_elem__size = p_context_elem_->Parse((t_begin_of_data + 8), t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	int t_DCE_RPC_AlterContext__size;
	const_byteptr const t_dataptr_after_p_context_elem = (t_begin_of_data + 8) + (t_p_context_elem__size);
	BINPAC_ASSERT(t_dataptr_after_p_context_elem <= t_end_of_data);
	t_DCE_RPC_AlterContext__size = t_dataptr_after_p_context_elem - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_DCE_RPC_AlterContext__size) <= t_end_of_data);
	return t_DCE_RPC_AlterContext__size;
	}

DCE_RPC_Request::DCE_RPC_Request()
	{
	alloc_hint_ = 0;
	p_cont_id_ = 0;
	opnum_ = 0;
	}

DCE_RPC_Request::~DCE_RPC_Request()
	{
	stub_.free();
	}

int DCE_RPC_Request::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "DCE_RPC_Request:opnum"
	if ( (t_begin_of_data + 6) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DCE_RPC_Request:opnum",
			(6) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "alloc_hint"
	alloc_hint_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "p_cont_id"
	p_cont_id_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "opnum"
	opnum_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 6))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "stub"
	int t_stub_string_length;
	t_stub_string_length = (t_end_of_data) - ((t_begin_of_data + 8));
	int t_stub__size;
	t_stub__size = t_stub_string_length;
	// check for negative sizes
	if ( t_stub_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dce-rpc/dce_rpc-protocol.pac:104", t_stub_string_length);
	stub_.init((t_begin_of_data + 8), t_stub_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_DCE_RPC_Request__size;
	const_byteptr const t_dataptr_after_stub = (t_begin_of_data + 8) + (t_stub__size);
	BINPAC_ASSERT(t_dataptr_after_stub <= t_end_of_data);
	t_DCE_RPC_Request__size = t_dataptr_after_stub - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_DCE_RPC_Request__size) <= t_end_of_data);
	return t_DCE_RPC_Request__size;
	}

DCE_RPC_Response::DCE_RPC_Response()
	{
	alloc_hint_ = 0;
	p_cont_id_ = 0;
	cancel_count_ = 0;
	reserved_ = 0;
	}

DCE_RPC_Response::~DCE_RPC_Response()
	{
	stub_.free();
	}

int DCE_RPC_Response::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "DCE_RPC_Response:reserved"
	if ( (t_begin_of_data + 7) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DCE_RPC_Response:reserved",
			(7) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "alloc_hint"
	alloc_hint_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "p_cont_id"
	p_cont_id_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "cancel_count"
	cancel_count_ = *((uint8 const *) ((t_begin_of_data + 6)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "reserved"
	reserved_ = *((uint8 const *) ((t_begin_of_data + 7)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "stub"
	int t_stub_string_length;
	t_stub_string_length = (t_end_of_data) - ((t_begin_of_data + 8));
	int t_stub__size;
	t_stub__size = t_stub_string_length;
	// check for negative sizes
	if ( t_stub_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dce-rpc/dce_rpc-protocol.pac:113", t_stub_string_length);
	stub_.init((t_begin_of_data + 8), t_stub_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_DCE_RPC_Response__size;
	const_byteptr const t_dataptr_after_stub = (t_begin_of_data + 8) + (t_stub__size);
	BINPAC_ASSERT(t_dataptr_after_stub <= t_end_of_data);
	t_DCE_RPC_Response__size = t_dataptr_after_stub - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_DCE_RPC_Response__size) <= t_end_of_data);
	return t_DCE_RPC_Response__size;
	}

DCE_RPC_Body::DCE_RPC_Body(DCE_RPC_Header * header)
	{
	val_case_index_ = -1;
	bind_ = 0;
	request_ = 0;
	response_ = 0;
	header_ = header;
	}

DCE_RPC_Body::~DCE_RPC_Body()
	{
	switch ( val_case_index() )
		{
		case 11:
			// Clean up "bind"
			{
			delete bind_;
			bind_ = 0;
			}
			break;
		case 0:
			// Clean up "request"
			{
			delete request_;
			request_ = 0;
			}
			break;
		case 2:
			// Clean up "response"
			{
			delete response_;
			response_ = 0;
			}
			break;
		default:
			// Clean up "other"
			{
			other_.free();
			}
			break;
		}
	}

int DCE_RPC_Body::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	int t_val__size;
	val_case_index_ = header()->PTYPE();
	switch ( val_case_index() )
		{
		case 11:
			// Parse "bind"
			{
			bind_ = new DCE_RPC_Bind();
			int t_bind__size;
			t_bind__size = bind_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_bind__size;
			}
			break;
		case 0:
			// Parse "request"
			{
			request_ = new DCE_RPC_Request();
			int t_request__size;
			t_request__size = request_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_request__size;
			}
			break;
		case 2:
			// Parse "response"
			{
			response_ = new DCE_RPC_Response();
			int t_response__size;
			t_response__size = response_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_response__size;
			}
			break;
		default:
			// Parse "other"
			{
			int t_other_string_length;
			t_other_string_length = (t_end_of_data) - (t_begin_of_data);
			int t_other__size;
			t_other__size = t_other_string_length;
			// check for negative sizes
			if ( t_other_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dce-rpc/dce_rpc-protocol.pac:120", t_other_string_length);
			other_.init(t_begin_of_data, t_other_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_other__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

DCE_RPC_Auth::DCE_RPC_Auth(DCE_RPC_Header * header)
	{
	val_ = 0;
	header_ = header;
	val__elem_ = 0;
	}

DCE_RPC_Auth::~DCE_RPC_Auth()
	{
	delete val_;
	}

int DCE_RPC_Auth::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	int t_val__arraylength;
	t_val__arraylength = 0;
	t_val__arraylength = header()->auth_length();
	if ( t_begin_of_data + t_val__arraylength > t_end_of_data + 1 )
		{
		t_val__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_val__arraylength < 0 )
		{
		t_val__arraylength = 0;
		}
	val__elem_ = 0;
	int t_val__elem__it;
	t_val__elem__it = 0;
	int t_val__size;
	val_ = new vector<uint8>;
	val_->reserve(t_val__arraylength);
	const_byteptr t_val__elem__dataptr = t_begin_of_data;
	for (; t_val__elem__it < t_val__arraylength; ++t_val__elem__it)
		{
		// Check &until(val__elem__dataptr >= end_of_data)
		if ( t_val__elem__dataptr >= t_end_of_data )
			{
			goto end_of_val;
			}
		// Checking out-of-bound for "DCE_RPC_Auth:val__elem"
		if ( t_val__elem__dataptr + (1) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("DCE_RPC_Auth:val__elem",
				((t_val__elem__dataptr - t_begin_of_data)) + (1), 
				(t_end_of_data) - (t_begin_of_data));
			}
		val__elem_ = *((uint8 const *) (t_val__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		val_->push_back(val__elem_);
		t_val__elem__dataptr += 1;
		BINPAC_ASSERT(t_val__elem__dataptr <= t_end_of_data);
		}
end_of_val: ;
	t_val__size = t_val__elem__dataptr - (t_begin_of_data);
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

epmapper_lookup_req::epmapper_lookup_req()
	{
	inquiry_type_ = 0;
	object_ = 0;
	interface_id_ = 0;
	vers_option_ = 0;
	entry_handle_ = 0;
	}

epmapper_lookup_req::~epmapper_lookup_req()
	{
	delete entry_handle_;
	entry_handle_ = 0;
	}

int epmapper_lookup_req::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "epmapper_lookup_req:vers_option"
	if ( (t_begin_of_data + 12) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("epmapper_lookup_req:vers_option",
			(12) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "inquiry_type"
	inquiry_type_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "object"
	object_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "interface_id"
	interface_id_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 8))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "vers_option"
	vers_option_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 12))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "entry_handle"
	entry_handle_ = new context_handle();
	int t_entry_handle__size;
	t_entry_handle__size = entry_handle_->Parse((t_begin_of_data + 16), t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	int t_epmapper_lookup_req__size;
	const_byteptr const t_dataptr_after_entry_handle = (t_begin_of_data + 16) + (t_entry_handle__size);
	BINPAC_ASSERT(t_dataptr_after_entry_handle <= t_end_of_data);
	t_epmapper_lookup_req__size = t_dataptr_after_entry_handle - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_epmapper_lookup_req__size) <= t_end_of_data);
	return t_epmapper_lookup_req__size;
	}

epmapper_map_req::epmapper_map_req()
	{
	}

epmapper_map_req::~epmapper_map_req()
	{
	}

int epmapper_map_req::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "epmapper_map_req"
	if ( t_begin_of_data + (0) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("epmapper_map_req",
			(0) + (0), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (0) <= t_end_of_data);
	return 0;
	}

epm_uuid::epm_uuid()
	{
	if_version_ = 0;
	byteorder_ = littleendian;
	}

epm_uuid::~epm_uuid()
	{
	if_uuid_.free();
	}

int epm_uuid::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "if_uuid"
	// Checking out-of-bound for "epm_uuid:if_uuid"
	if ( t_begin_of_data + (16) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("epm_uuid:if_uuid",
			(0) + (16), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + 16;
	int t_if_uuid_string_length;
	t_if_uuid_string_length = 16;
	int t_if_uuid__size;
	t_if_uuid__size = t_if_uuid_string_length;
	if_uuid_.init(t_begin_of_data, t_if_uuid_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_if_uuid = t_begin_of_data + (16);
	BINPAC_ASSERT(t_dataptr_after_if_uuid <= t_end_of_data);
	// Checking out-of-bound for "epm_uuid:if_version"
	if ( t_dataptr_after_if_uuid + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("epm_uuid:if_version",
			((t_dataptr_after_if_uuid - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "if_version"
	if_version_ = FixByteOrder(byteorder(), *((uint16 const *) (t_dataptr_after_if_uuid)));
	// Evaluate 'let' and 'withinput' fields
	
	int t_epm_uuid__size;
	t_epm_uuid__size = (t_dataptr_after_if_uuid + 2) - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_epm_uuid__size) <= t_end_of_data);
	return t_epm_uuid__size;
	}

epm_port::epm_port()
	{
	val_ = 0;
	byteorder_ = bigendian;
	}

epm_port::~epm_port()
	{
	}

int epm_port::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "epm_port:val"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("epm_port:val",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	val_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (2) <= t_end_of_data);
	return 2;
	}

epm_ip::epm_ip()
	{
	val_ = 0;
	byteorder_ = bigendian;
	}

epm_ip::~epm_ip()
	{
	}

int epm_ip::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "epm_ip:val"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("epm_ip:val",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	val_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

epm_lhs_data::epm_lhs_data(uint16 length, uint8 protocol)
	{
	val_case_index_ = -1;
	uuid_ = 0;
	length_ = length;
	protocol_ = protocol;
	}

epm_lhs_data::~epm_lhs_data()
	{
	switch ( val_case_index() )
		{
		case 13:
			// Clean up "uuid"
			{
			delete uuid_;
			uuid_ = 0;
			}
			break;
		default:
			// Clean up "other"
			{
			other_.free();
			}
			break;
		}
	}

int epm_lhs_data::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	int t_val__size;
	val_case_index_ = protocol();
	switch ( val_case_index() )
		{
		case 13:
			// Parse "uuid"
			{
			uuid_ = new epm_uuid();
			int t_uuid__size;
			t_uuid__size = uuid_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_uuid__size;
			}
			break;
		default:
			// Parse "other"
			{
			int t_other__size;
			t_other__size = length();
			// Checking out-of-bound for "epm_lhs_data:other"
			if ( t_begin_of_data + (t_other__size) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("epm_lhs_data:other",
					(0) + (t_other__size), 
					(t_end_of_data) - (t_begin_of_data));
				}
			{
			// Setting t_end_of_data with &length
			const_byteptr t_end_of_data = t_begin_of_data + t_other__size;
			int t_other_string_length;
			t_other_string_length = length();
			// check for negative sizes
			if ( t_other_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dce-rpc/epmapper.pac:31", t_other_string_length);
			other_.init(t_begin_of_data, t_other_string_length);
			// Evaluate 'let' and 'withinput' fields
			}
			t_val__size = t_other__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

epm_rhs_data::epm_rhs_data(uint16 length, uint8 protocol)
	{
	val_case_index_ = -1;
	tcp_ = 0;
	udp_ = 0;
	ip_ = 0;
	length_ = length;
	protocol_ = protocol;
	}

epm_rhs_data::~epm_rhs_data()
	{
	switch ( val_case_index() )
		{
		case 7:
			// Clean up "tcp"
			{
			}
			break;
		case 8:
			// Clean up "udp"
			{
			}
			break;
		case 9:
			// Clean up "ip"
			{
			}
			break;
		default:
			// Clean up "other"
			{
			other_.free();
			}
			break;
		}
	}

int epm_rhs_data::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	int t_val__size;
	val_case_index_ = protocol();
	switch ( val_case_index() )
		{
		case 7:
			// Parse "tcp"
			{
			// Checking out-of-bound for "epm_rhs_data:tcp"
			if ( t_begin_of_data + (2) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("epm_rhs_data:tcp",
					(0) + (2), 
					(t_end_of_data) - (t_begin_of_data));
				}
			tcp_ = FixByteOrder(bigendian, *((uint16 const *) (t_begin_of_data)));
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 2;
			}
			break;
		case 8:
			// Parse "udp"
			{
			// Checking out-of-bound for "epm_rhs_data:udp"
			if ( t_begin_of_data + (2) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("epm_rhs_data:udp",
					(0) + (2), 
					(t_end_of_data) - (t_begin_of_data));
				}
			udp_ = FixByteOrder(bigendian, *((uint16 const *) (t_begin_of_data)));
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 2;
			}
			break;
		case 9:
			// Parse "ip"
			{
			// Checking out-of-bound for "epm_rhs_data:ip"
			if ( t_begin_of_data + (4) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("epm_rhs_data:ip",
					(0) + (4), 
					(t_end_of_data) - (t_begin_of_data));
				}
			ip_ = FixByteOrder(bigendian, *((uint32 const *) (t_begin_of_data)));
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 4;
			}
			break;
		default:
			// Parse "other"
			{
			int t_other__size;
			t_other__size = length();
			// Checking out-of-bound for "epm_rhs_data:other"
			if ( t_begin_of_data + (t_other__size) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("epm_rhs_data:other",
					(0) + (t_other__size), 
					(t_end_of_data) - (t_begin_of_data));
				}
			{
			// Setting t_end_of_data with &length
			const_byteptr t_end_of_data = t_begin_of_data + t_other__size;
			int t_other_string_length;
			t_other_string_length = length();
			// check for negative sizes
			if ( t_other_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dce-rpc/epmapper.pac:38", t_other_string_length);
			other_.init(t_begin_of_data, t_other_string_length);
			// Evaluate 'let' and 'withinput' fields
			}
			t_val__size = t_other__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

epm_lhs::epm_lhs()
	{
	length_ = 0;
	protocol_ = 0;
	data_ = 0;
	byteorder_ = littleendian;
	}

epm_lhs::~epm_lhs()
	{
	delete data_;
	data_ = 0;
	}

int epm_lhs::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "epm_lhs:protocol"
	if ( (t_begin_of_data + 2) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("epm_lhs:protocol",
			(2) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "protocol"
	protocol_ = *((uint8 const *) ((t_begin_of_data + 2)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data"
	data_ = new epm_lhs_data(length() - 1, protocol());
	int t_data__size;
	t_data__size = data_->Parse((t_begin_of_data + 3), t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_epm_lhs__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 3) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_epm_lhs__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_epm_lhs__size) <= t_end_of_data);
	return t_epm_lhs__size;
	}

epm_rhs::epm_rhs(uint8 protocol)
	{
	length_ = 0;
	data_ = 0;
	protocol_ = protocol;
	byteorder_ = littleendian;
	}

epm_rhs::~epm_rhs()
	{
	delete data_;
	data_ = 0;
	}

int epm_rhs::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "epm_rhs:length"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("epm_rhs:length",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data"
	data_ = new epm_rhs_data(length(), protocol());
	int t_data__size;
	t_data__size = data_->Parse((t_begin_of_data + 2), t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_epm_rhs__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 2) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_epm_rhs__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_epm_rhs__size) <= t_end_of_data);
	return t_epm_rhs__size;
	}

epm_floor::epm_floor()
	{
	lhs_ = 0;
	rhs_ = 0;
	protocol_ = 0;
	}

epm_floor::~epm_floor()
	{
	delete lhs_;
	lhs_ = 0;
	delete rhs_;
	rhs_ = 0;
	}

int epm_floor::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "lhs"
	lhs_ = new epm_lhs();
	int t_lhs__size;
	t_lhs__size = lhs_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_lhs = t_begin_of_data + (t_lhs__size);
	BINPAC_ASSERT(t_dataptr_after_lhs <= t_end_of_data);
	// Parse "rhs"
	protocol_ = lhs()->protocol();
	rhs_ = new epm_rhs(protocol());
	int t_rhs__size;
	t_rhs__size = rhs_->Parse(t_dataptr_after_lhs, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_epm_floor__size;
	const_byteptr const t_dataptr_after_rhs = t_dataptr_after_lhs + (t_rhs__size);
	BINPAC_ASSERT(t_dataptr_after_rhs <= t_end_of_data);
	t_epm_floor__size = t_dataptr_after_rhs - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_epm_floor__size) <= t_end_of_data);
	return t_epm_floor__size;
	}

epm_tower::epm_tower()
	{
	num_floors_ = 0;
	floors_ = 0;
	floors__elem_ = 0;
	byteorder_ = littleendian;
	}

epm_tower::~epm_tower()
	{
	delete floors__elem_;
	floors__elem_ = 0;
	if ( floors() )
		{
		for ( int i = 0; i < (int) floors()->size(); ++i )
			{
			epm_floor * floors__elem_ = (*floors_)[i];
			delete floors__elem_;
			floors__elem_ = 0;
			}
		}
	delete floors_;
	}

int epm_tower::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "epm_tower:num_floors"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("epm_tower:num_floors",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "num_floors"
	num_floors_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "floors"
	int t_floors__arraylength;
	t_floors__arraylength = 0;
	t_floors__arraylength = num_floors();
	if ( t_begin_of_data + t_floors__arraylength > t_end_of_data + 1 )
		{
		t_floors__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_floors__arraylength < 0 )
		{
		t_floors__arraylength = 0;
		}
	floors__elem_ = 0;
	int t_floors__elem__it;
	t_floors__elem__it = 0;
	int t_floors__size;
	floors_ = new vector<epm_floor *>;
	floors_->reserve(t_floors__arraylength);
	const_byteptr t_floors__elem__dataptr = (t_begin_of_data + 2);
	for (; t_floors__elem__it < t_floors__arraylength; ++t_floors__elem__it)
		{
		// Check &until(floors__elem__dataptr >= end_of_data)
		if ( t_floors__elem__dataptr >= t_end_of_data )
			{
			floors__elem_ = 0;
			goto end_of_floors;
			}
		floors__elem_ = new epm_floor();
		int t_floors__elem__size;
		t_floors__elem__size = floors__elem_->Parse(t_floors__elem__dataptr, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		floors_->push_back(floors__elem_);
		t_floors__elem__dataptr += t_floors__elem__size;
		BINPAC_ASSERT(t_floors__elem__dataptr <= t_end_of_data);
		floors__elem_ = 0;
		}
end_of_floors: ;
	t_floors__size = t_floors__elem__dataptr - ((t_begin_of_data + 2));
	// Evaluate 'let' and 'withinput' fields
	
	int t_epm_tower__size;
	const_byteptr const t_dataptr_after_floors = (t_begin_of_data + 2) + (t_floors__size);
	BINPAC_ASSERT(t_dataptr_after_floors <= t_end_of_data);
	t_epm_tower__size = t_dataptr_after_floors - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_epm_tower__size) <= t_end_of_data);
	return t_epm_tower__size;
	}

epm_twr_p::epm_twr_p()
	{
	ref_ = 0;
	length_ = 0;
	tower_length_ = 0;
	tower_ = 0;
	}

epm_twr_p::~epm_twr_p()
	{
	delete tower_;
	tower_ = 0;
	}

int epm_twr_p::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "epm_twr_p:tower_length"
	if ( (t_begin_of_data + 8) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("epm_twr_p:tower_length",
			(8) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "ref"
	ref_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "length"
	length_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "tower_length"
	tower_length_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 8))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "tower"
	tower_ = new epm_tower();
	int t_tower__size;
	t_tower__size = tower_length();
	// Checking out-of-bound for "epm_twr_p:tower"
	if ( (t_begin_of_data + 12) + (t_tower__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("epm_twr_p:tower",
			(12) + (t_tower__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 12) + t_tower__size;
	tower_->Parse((t_begin_of_data + 12), t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_epm_twr_p__size;
	const_byteptr const t_dataptr_after_tower = (t_begin_of_data + 12) + (t_tower__size);
	BINPAC_ASSERT(t_dataptr_after_tower <= t_end_of_data);
	t_epm_twr_p__size = t_dataptr_after_tower - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_epm_twr_p__size) <= t_end_of_data);
	return t_epm_twr_p__size;
	}

epm_tower_array::epm_tower_array()
	{
	max_count_ = 0;
	offset_ = 0;
	actual_count_ = 0;
	towers_ = 0;
	towers__elem_ = 0;
	}

epm_tower_array::~epm_tower_array()
	{
	delete towers__elem_;
	towers__elem_ = 0;
	if ( towers() )
		{
		for ( int i = 0; i < (int) towers()->size(); ++i )
			{
			epm_twr_p * towers__elem_ = (*towers_)[i];
			delete towers__elem_;
			towers__elem_ = 0;
			}
		}
	delete towers_;
	}

int epm_tower_array::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "epm_tower_array:actual_count"
	if ( (t_begin_of_data + 8) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("epm_tower_array:actual_count",
			(8) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "max_count"
	max_count_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "offset"
	offset_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "actual_count"
	actual_count_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 8))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "towers"
	int t_towers__arraylength;
	t_towers__arraylength = 0;
	t_towers__arraylength = actual_count();
	if ( t_begin_of_data + t_towers__arraylength > t_end_of_data + 1 )
		{
		t_towers__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_towers__arraylength < 0 )
		{
		t_towers__arraylength = 0;
		}
	towers__elem_ = 0;
	int t_towers__elem__it;
	t_towers__elem__it = 0;
	int t_towers__size;
	towers_ = new vector<epm_twr_p *>;
	towers_->reserve(t_towers__arraylength);
	const_byteptr t_towers__elem__dataptr = (t_begin_of_data + 12);
	for (; t_towers__elem__it < t_towers__arraylength; ++t_towers__elem__it)
		{
		// Check &until(towers__elem__dataptr >= end_of_data)
		if ( t_towers__elem__dataptr >= t_end_of_data )
			{
			towers__elem_ = 0;
			goto end_of_towers;
			}
		towers__elem_ = new epm_twr_p();
		int t_towers__elem__size;
		t_towers__elem__size = towers__elem_->Parse(t_towers__elem__dataptr, t_end_of_data, t_byteorder);
		// Evaluate 'let' and 'withinput' fields
		towers_->push_back(towers__elem_);
		t_towers__elem__dataptr += t_towers__elem__size;
		BINPAC_ASSERT(t_towers__elem__dataptr <= t_end_of_data);
		towers__elem_ = 0;
		}
end_of_towers: ;
	t_towers__size = t_towers__elem__dataptr - ((t_begin_of_data + 12));
	// Evaluate 'let' and 'withinput' fields
	
	int t_epm_tower_array__size;
	const_byteptr const t_dataptr_after_towers = (t_begin_of_data + 12) + (t_towers__size);
	BINPAC_ASSERT(t_dataptr_after_towers <= t_end_of_data);
	t_epm_tower_array__size = t_dataptr_after_towers - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_epm_tower_array__size) <= t_end_of_data);
	return t_epm_tower_array__size;
	}

epmapper_map_resp::epmapper_map_resp()
	{
	entry_handle_ = 0;
	num_towers_ = 0;
	towers_ = 0;
	return_code_ = 0;
	}

epmapper_map_resp::~epmapper_map_resp()
	{
	delete entry_handle_;
	entry_handle_ = 0;
	delete towers_;
	towers_ = 0;
	}

int epmapper_map_resp::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Parse "entry_handle"
	entry_handle_ = new context_handle();
	int t_entry_handle__size;
	t_entry_handle__size = entry_handle_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_entry_handle = t_begin_of_data + (t_entry_handle__size);
	BINPAC_ASSERT(t_dataptr_after_entry_handle <= t_end_of_data);
	// Checking out-of-bound for "epmapper_map_resp:num_towers"
	if ( t_dataptr_after_entry_handle + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("epmapper_map_resp:num_towers",
			((t_dataptr_after_entry_handle - t_begin_of_data)) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "num_towers"
	num_towers_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_dataptr_after_entry_handle)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "towers"
	towers_ = new epm_tower_array();
	int t_towers__size;
	t_towers__size = towers_->Parse((t_dataptr_after_entry_handle + 4), t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_towers = (t_dataptr_after_entry_handle + 4) + (t_towers__size);
	BINPAC_ASSERT(t_dataptr_after_towers <= t_end_of_data);
	// Checking out-of-bound for "epmapper_map_resp:return_code"
	if ( t_dataptr_after_towers + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("epmapper_map_resp:return_code",
			((t_dataptr_after_towers - t_begin_of_data)) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "return_code"
	return_code_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_dataptr_after_towers)));
	// Evaluate 'let' and 'withinput' fields
	
	int t_epmapper_map_resp__size;
	t_epmapper_map_resp__size = (t_dataptr_after_towers + 4) - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_epmapper_map_resp__size) <= t_end_of_data);
	return t_epmapper_map_resp__size;
	}

DCE_RPC_PDU::DCE_RPC_PDU()
	{
	header_ = 0;
	auth_ = 0;
	byteorder_ = 0;
	body_length_ = 0;
	frag_reassembled_ = 0;
	body_ = 0;
	has_body_ = 0;
	buffering_state_ = 0;
	buffering_state_ = 0;
	}

DCE_RPC_PDU::~DCE_RPC_PDU()
	{
	delete header_;
	header_ = 0;
	frag_.free();
	delete auth_;
	auth_ = 0;
	delete body_;
	body_ = 0;
	}

bool DCE_RPC_PDU::ParseBuffer(flow_buffer_t t_flow_buffer, ContextDCE_RPC * t_context)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	const_byteptr t_begin_of_data = t_flow_buffer->begin();
	const_byteptr t_end_of_data = t_flow_buffer->end();
	switch ( buffering_state_ )
		{
		case 0:
			if ( buffering_state_ == 0 )
				{
				t_flow_buffer->NewFrame(16, false);
				buffering_state_ = 1;
				}
			buffering_state_ = 1;
			break;
		case 1:
			{
			buffering_state_ = 2;
			// Checking out-of-bound for "DCE_RPC_PDU:header"
			if ( t_begin_of_data + (16) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("DCE_RPC_PDU:header",
					(0) + (16), 
					(t_end_of_data) - (t_begin_of_data));
				}
			// Parse "header"
			header_ = new DCE_RPC_Header();
			header_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_flow_buffer->GrowFrame(header()->frag_length());
			}
			break;
		case 2:
			BINPAC_ASSERT(t_flow_buffer->ready());
			if ( t_flow_buffer->ready() )
				{
				
				// Parse "frag"
				int t_frag__size;
				body_length_ = header()->frag_length() - 16 - header()->auth_length();
				t_frag__size = body_length();
				// Checking out-of-bound for "DCE_RPC_PDU:frag"
				if ( (t_begin_of_data + 16) + (t_frag__size) > t_end_of_data )
					{
					// Handle out-of-bound condition
					throw binpac::ExceptionOutOfBound("DCE_RPC_PDU:frag",
						(16) + (t_frag__size), 
						(t_end_of_data) - (t_begin_of_data));
					}
				{
				// Setting t_end_of_data with &length
				const_byteptr t_end_of_data = (t_begin_of_data + 16) + t_frag__size;
				int t_frag_string_length;
				t_frag_string_length = body_length();
				// check for negative sizes
				if ( t_frag_string_length < 0 )
				throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dce-rpc/dce_rpc-analyzer.pac:7", t_frag_string_length);
				frag_.init((t_begin_of_data + 16), t_frag_string_length);
				// Evaluate 'let' and 'withinput' fields
				}
				
				const_byteptr const t_dataptr_after_frag = (t_begin_of_data + 16) + (t_frag__size);
				BINPAC_ASSERT(t_dataptr_after_frag <= t_end_of_data);
				// Parse "auth"
				auth_ = new DCE_RPC_Auth(header());
				int t_auth__size;
				t_auth__size = auth_->Parse(t_dataptr_after_frag, t_end_of_data);
				// Evaluate 'let' and 'withinput' fields
				
				t_val_parsing_complete = true;
				if ( t_val_parsing_complete )
					{
					// Evaluate 'let' and 'withinput' fields
					byteorder_ = header()->byteorder();
					frag_reassembled_ = t_context->flow()->reassemble_fragment(frag(), header()->lastfrag());
					// Parse "body"
					has_body_ = frag_reassembled();
					if ( has_body() )
						{
						body_ = new DCE_RPC_Body(header());
						const_byteptr t_begin_of_data, t_end_of_data;
						get_pointers(t_context->flow()->reassembled_body(), &t_begin_of_data, &t_end_of_data);
						int t_body__size;
						t_body__size = body_->Parse(t_begin_of_data, t_end_of_data, byteorder());
						// Evaluate 'let' and 'withinput' fields
						}
					}
				BINPAC_ASSERT(t_val_parsing_complete);
				buffering_state_ = 0;
				}
			break;
		default:
			BINPAC_ASSERT(buffering_state_ <= 2);
			break;
		}
	return t_val_parsing_complete;
	}

DCE_RPC_Conn::DCE_RPC_Conn(BroAnalyzer const & bro_analyzer)
	{
	upflow_ = new DCE_RPC_Flow(this, true);
	downflow_ = new DCE_RPC_Flow(this, false);
	bro_analyzer_ = bro_analyzer;
	}

DCE_RPC_Conn::~DCE_RPC_Conn()
	{
	delete upflow_;
	upflow_ = 0;
	delete downflow_;
	downflow_ = 0;
	}

void DCE_RPC_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void DCE_RPC_Conn::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void DCE_RPC_Conn::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

uint16 DCE_RPC_Conn::get_cont_id_opnum_map(uint16 cont_id)
	{

		return cont_id_opnum_map[cont_id];
		
	}

bool DCE_RPC_Conn::set_cont_id_opnum_map(uint16 cont_id, uint16 opnum)
	{

		cont_id_opnum_map[cont_id] = opnum;
		return true;
		
	}

DCE_RPC_Flow::DCE_RPC_Flow(DCE_RPC_Conn * connection, bool is_orig)
	{
	flow_buffer_ = 0;
	connection_ = connection;
	is_orig_ = is_orig;
	dataunit_ = 0;
	context_ = 0;
	flow_buffer_ = new FlowBuffer();
	}

DCE_RPC_Flow::~DCE_RPC_Flow()
	{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;
	delete flow_buffer_;
	flow_buffer_ = 0;
	}

void DCE_RPC_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		flow_buffer_->NewData(t_begin_of_data, t_end_of_data);
		while ( flow_buffer_->data_available() && 
			( !flow_buffer_->have_pending_request() || flow_buffer_->ready() ) )
			{
			if ( ! dataunit_ )
				{
				BINPAC_ASSERT(!context_);
				dataunit_ = new DCE_RPC_PDU();
				flow_buffer_->NewFrame(0, false);
				context_ = new ContextDCE_RPC(connection(), this, flow_buffer());
				}
			bool t_dataunit_parsing_complete;
			t_dataunit_parsing_complete = false;
			while ( ! t_dataunit_parsing_complete && flow_buffer_->ready() )
				{
				const_byteptr t_begin_of_data = flow_buffer()->begin();
				const_byteptr t_end_of_data = flow_buffer()->end();
				t_dataunit_parsing_complete = dataunit_->ParseBuffer(flow_buffer(), context_);
				if ( t_dataunit_parsing_complete )
					{
					// Evaluate 'let' and 'withinput' fields
					}
				}
			if ( t_dataunit_parsing_complete )
				{
				// Clean up the flow unit after parsing
				delete dataunit_;
				dataunit_ = 0;
				delete context_;
				context_ = 0;
				}
			else
				{
				// Resume upon next input segment
				BINPAC_ASSERT(!flow_buffer()->ready());
				break;
				}
			}
		}
	catch ( binpac::Exception const &e )
		{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		flow_buffer_->DiscardData();
		throw;
		}
	}

void DCE_RPC_Flow::NewGap(int gap_length)
	{
	flow_buffer_->NewGap(gap_length);
	}
void DCE_RPC_Flow::FlowEOF()
	{
	flow_buffer_->set_eof();
	NewData(0, 0);
	}
bool DCE_RPC_Flow::reassemble_fragment(bytestring const & frag, bool lastfrag)
	{

		int orig_data_length = frag_reassembler_.data_length();

		frag_reassembler_.NewData(frag.begin(), frag.end());

		int new_frame_length = orig_data_length + frag.length();
		if ( orig_data_length == 0 )
			frag_reassembler_.NewFrame(new_frame_length, false);
		else
			frag_reassembler_.GrowFrame(new_frame_length);

		return lastfrag;
		
	}

const_bytestring DCE_RPC_Flow::reassembled_body()
	{

		return const_bytestring(
			frag_reassembler_.begin(),
			frag_reassembler_.end());
		
	}

bool DCE_RPC_Flow::process_dce_rpc_bind(DCE_RPC_Bind * bind)
	{

		p_cont_list_t * t_bind_elems = bind->p_context_elem();

		if ( t_bind_elems->n_context_elem() > 1 ) {
			connection()->bro_analyzer()->Weird(
				"DCE_RPC_bind_to_multiple_interfaces");
		}

		if ( dce_rpc_bind ) {
			// Go over the elements, each having a UUID
			for ( int i = 0; i < t_bind_elems->n_context_elem(); ++i ) {
				bytestring t_if_uuid = (*(t_bind_elems->p_cont_elem()))[i]->abstract_syntax()->if_uuid();

				// Queue the event
				BifEvent::generate_dce_rpc_bind(
					connection()->bro_analyzer(),
					connection()->bro_analyzer()->Conn(),
					bytestring_to_val(t_if_uuid));

				// Set the connection's UUID
				// ${connection}->set_uuid(${if_uuid});
			}
		}

		return t_bind_elems->n_context_elem() > 0;
		
	}

bool DCE_RPC_Flow::process_dce_rpc_request(DCE_RPC_Request * req)
	{

		if ( dce_rpc_request )
			{
			BifEvent::generate_dce_rpc_request(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				req->opnum(),
				bytestring_to_val(req->stub()));
			}

		connection()->set_cont_id_opnum_map(req->p_cont_id(),
							req->opnum());

		return true;
		
	}

bool DCE_RPC_Flow::process_dce_rpc_response(DCE_RPC_Response * resp)
	{

		if ( dce_rpc_response )
			{
			BifEvent::generate_dce_rpc_response(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				connection()->get_cont_id_opnum_map(resp->p_cont_id()),
				bytestring_to_val(resp->stub()));
			}

		return true;
		
	}

} // namespace DCE_RPC
}  // namespace binpac

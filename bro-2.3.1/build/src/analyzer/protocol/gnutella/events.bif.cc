// This file was automatically generated by bifcl from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/gnutella/events.bif (plugin mode).


#include "events.bif.h"

EventHandlerPtr gnutella_text_msg; 
void BifEvent::generate_gnutella_text_msg(analyzer::Analyzer* analyzer, Connection* c, int orig, StringVal* headers)
	{
	// Note that it is intentional that here we do not
	// check if ::gnutella_text_msg is NULL, which should happen *before*
	// BifEvent::generate_gnutella_text_msg is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(orig, TYPE_BOOL));
	vl->append(headers);

	mgr.QueueEvent(::gnutella_text_msg, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr gnutella_binary_msg; 
void BifEvent::generate_gnutella_binary_msg(analyzer::Analyzer* analyzer, Connection* c, int orig, bro_uint_t msg_type, bro_uint_t ttl, bro_uint_t hops, bro_uint_t msg_len, StringVal* payload, bro_uint_t payload_len, int trunc, int complete)
	{
	// Note that it is intentional that here we do not
	// check if ::gnutella_binary_msg is NULL, which should happen *before*
	// BifEvent::generate_gnutella_binary_msg is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(orig, TYPE_BOOL));
	vl->append(new Val(msg_type, TYPE_COUNT));
	vl->append(new Val(ttl, TYPE_COUNT));
	vl->append(new Val(hops, TYPE_COUNT));
	vl->append(new Val(msg_len, TYPE_COUNT));
	vl->append(payload);
	vl->append(new Val(payload_len, TYPE_COUNT));
	vl->append(new Val(trunc, TYPE_BOOL));
	vl->append(new Val(complete, TYPE_BOOL));

	mgr.QueueEvent(::gnutella_binary_msg, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr gnutella_partial_binary_msg; 
void BifEvent::generate_gnutella_partial_binary_msg(analyzer::Analyzer* analyzer, Connection* c, int orig, StringVal* msg, bro_uint_t len)
	{
	// Note that it is intentional that here we do not
	// check if ::gnutella_partial_binary_msg is NULL, which should happen *before*
	// BifEvent::generate_gnutella_partial_binary_msg is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(orig, TYPE_BOOL));
	vl->append(msg);
	vl->append(new Val(len, TYPE_COUNT));

	mgr.QueueEvent(::gnutella_partial_binary_msg, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr gnutella_establish; 
void BifEvent::generate_gnutella_establish(analyzer::Analyzer* analyzer, Connection* c)
	{
	// Note that it is intentional that here we do not
	// check if ::gnutella_establish is NULL, which should happen *before*
	// BifEvent::generate_gnutella_establish is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());

	mgr.QueueEvent(::gnutella_establish, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr gnutella_not_establish; 
void BifEvent::generate_gnutella_not_establish(analyzer::Analyzer* analyzer, Connection* c)
	{
	// Note that it is intentional that here we do not
	// check if ::gnutella_not_establish is NULL, which should happen *before*
	// BifEvent::generate_gnutella_not_establish is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());

	mgr.QueueEvent(::gnutella_not_establish, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr gnutella_http_notify; 
void BifEvent::generate_gnutella_http_notify(analyzer::Analyzer* analyzer, Connection* c)
	{
	// Note that it is intentional that here we do not
	// check if ::gnutella_http_notify is NULL, which should happen *before*
	// BifEvent::generate_gnutella_http_notify is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());

	mgr.QueueEvent(::gnutella_http_notify, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation

// This file was automatically generated by bifcl from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/rpc/events.bif (plugin mode).


#include "events.bif.h"

EventHandlerPtr nfs_proc_null; 
void BifEvent::generate_nfs_proc_null(analyzer::Analyzer* analyzer, Connection* c, Val* info)
	{
	// Note that it is intentional that here we do not
	// check if ::nfs_proc_null is NULL, which should happen *before*
	// BifEvent::generate_nfs_proc_null is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(info);

	mgr.QueueEvent(::nfs_proc_null, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr nfs_proc_getattr; 
void BifEvent::generate_nfs_proc_getattr(analyzer::Analyzer* analyzer, Connection* c, Val* info, StringVal* fh, Val* attrs)
	{
	// Note that it is intentional that here we do not
	// check if ::nfs_proc_getattr is NULL, which should happen *before*
	// BifEvent::generate_nfs_proc_getattr is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(info);
	vl->append(fh);
	vl->append(attrs);

	mgr.QueueEvent(::nfs_proc_getattr, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr nfs_proc_lookup; 
void BifEvent::generate_nfs_proc_lookup(analyzer::Analyzer* analyzer, Connection* c, Val* info, Val* req, Val* rep)
	{
	// Note that it is intentional that here we do not
	// check if ::nfs_proc_lookup is NULL, which should happen *before*
	// BifEvent::generate_nfs_proc_lookup is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(info);
	vl->append(req);
	vl->append(rep);

	mgr.QueueEvent(::nfs_proc_lookup, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr nfs_proc_read; 
void BifEvent::generate_nfs_proc_read(analyzer::Analyzer* analyzer, Connection* c, Val* info, Val* req, Val* rep)
	{
	// Note that it is intentional that here we do not
	// check if ::nfs_proc_read is NULL, which should happen *before*
	// BifEvent::generate_nfs_proc_read is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(info);
	vl->append(req);
	vl->append(rep);

	mgr.QueueEvent(::nfs_proc_read, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr nfs_proc_readlink; 
void BifEvent::generate_nfs_proc_readlink(analyzer::Analyzer* analyzer, Connection* c, Val* info, StringVal* fh, Val* rep)
	{
	// Note that it is intentional that here we do not
	// check if ::nfs_proc_readlink is NULL, which should happen *before*
	// BifEvent::generate_nfs_proc_readlink is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(info);
	vl->append(fh);
	vl->append(rep);

	mgr.QueueEvent(::nfs_proc_readlink, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr nfs_proc_write; 
void BifEvent::generate_nfs_proc_write(analyzer::Analyzer* analyzer, Connection* c, Val* info, Val* req, Val* rep)
	{
	// Note that it is intentional that here we do not
	// check if ::nfs_proc_write is NULL, which should happen *before*
	// BifEvent::generate_nfs_proc_write is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(info);
	vl->append(req);
	vl->append(rep);

	mgr.QueueEvent(::nfs_proc_write, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr nfs_proc_create; 
void BifEvent::generate_nfs_proc_create(analyzer::Analyzer* analyzer, Connection* c, Val* info, Val* req, Val* rep)
	{
	// Note that it is intentional that here we do not
	// check if ::nfs_proc_create is NULL, which should happen *before*
	// BifEvent::generate_nfs_proc_create is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(info);
	vl->append(req);
	vl->append(rep);

	mgr.QueueEvent(::nfs_proc_create, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr nfs_proc_mkdir; 
void BifEvent::generate_nfs_proc_mkdir(analyzer::Analyzer* analyzer, Connection* c, Val* info, Val* req, Val* rep)
	{
	// Note that it is intentional that here we do not
	// check if ::nfs_proc_mkdir is NULL, which should happen *before*
	// BifEvent::generate_nfs_proc_mkdir is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(info);
	vl->append(req);
	vl->append(rep);

	mgr.QueueEvent(::nfs_proc_mkdir, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr nfs_proc_remove; 
void BifEvent::generate_nfs_proc_remove(analyzer::Analyzer* analyzer, Connection* c, Val* info, Val* req, Val* rep)
	{
	// Note that it is intentional that here we do not
	// check if ::nfs_proc_remove is NULL, which should happen *before*
	// BifEvent::generate_nfs_proc_remove is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(info);
	vl->append(req);
	vl->append(rep);

	mgr.QueueEvent(::nfs_proc_remove, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr nfs_proc_rmdir; 
void BifEvent::generate_nfs_proc_rmdir(analyzer::Analyzer* analyzer, Connection* c, Val* info, Val* req, Val* rep)
	{
	// Note that it is intentional that here we do not
	// check if ::nfs_proc_rmdir is NULL, which should happen *before*
	// BifEvent::generate_nfs_proc_rmdir is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(info);
	vl->append(req);
	vl->append(rep);

	mgr.QueueEvent(::nfs_proc_rmdir, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr nfs_proc_readdir; 
void BifEvent::generate_nfs_proc_readdir(analyzer::Analyzer* analyzer, Connection* c, Val* info, Val* req, Val* rep)
	{
	// Note that it is intentional that here we do not
	// check if ::nfs_proc_readdir is NULL, which should happen *before*
	// BifEvent::generate_nfs_proc_readdir is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(info);
	vl->append(req);
	vl->append(rep);

	mgr.QueueEvent(::nfs_proc_readdir, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr nfs_proc_not_implemented; 
void BifEvent::generate_nfs_proc_not_implemented(analyzer::Analyzer* analyzer, Connection* c, Val* info, Val* proc)
	{
	// Note that it is intentional that here we do not
	// check if ::nfs_proc_not_implemented is NULL, which should happen *before*
	// BifEvent::generate_nfs_proc_not_implemented is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(info);
	vl->append(proc);

	mgr.QueueEvent(::nfs_proc_not_implemented, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr nfs_reply_status; 
void BifEvent::generate_nfs_reply_status(analyzer::Analyzer* analyzer, Connection* n, Val* info)
	{
	// Note that it is intentional that here we do not
	// check if ::nfs_reply_status is NULL, which should happen *before*
	// BifEvent::generate_nfs_reply_status is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(n->BuildConnVal());
	vl->append(info);

	mgr.QueueEvent(::nfs_reply_status, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, n);
	} // event generation
EventHandlerPtr pm_request_null; 
void BifEvent::generate_pm_request_null(analyzer::Analyzer* analyzer, Connection* r)
	{
	// Note that it is intentional that here we do not
	// check if ::pm_request_null is NULL, which should happen *before*
	// BifEvent::generate_pm_request_null is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(r->BuildConnVal());

	mgr.QueueEvent(::pm_request_null, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, r);
	} // event generation
EventHandlerPtr pm_request_set; 
void BifEvent::generate_pm_request_set(analyzer::Analyzer* analyzer, Connection* r, Val* m, int success)
	{
	// Note that it is intentional that here we do not
	// check if ::pm_request_set is NULL, which should happen *before*
	// BifEvent::generate_pm_request_set is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(r->BuildConnVal());
	vl->append(m);
	vl->append(new Val(success, TYPE_BOOL));

	mgr.QueueEvent(::pm_request_set, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, r);
	} // event generation
EventHandlerPtr pm_request_unset; 
void BifEvent::generate_pm_request_unset(analyzer::Analyzer* analyzer, Connection* r, Val* m, int success)
	{
	// Note that it is intentional that here we do not
	// check if ::pm_request_unset is NULL, which should happen *before*
	// BifEvent::generate_pm_request_unset is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(r->BuildConnVal());
	vl->append(m);
	vl->append(new Val(success, TYPE_BOOL));

	mgr.QueueEvent(::pm_request_unset, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, r);
	} // event generation
EventHandlerPtr pm_request_getport; 
void BifEvent::generate_pm_request_getport(analyzer::Analyzer* analyzer, Connection* r, Val* pr, PortVal* p)
	{
	// Note that it is intentional that here we do not
	// check if ::pm_request_getport is NULL, which should happen *before*
	// BifEvent::generate_pm_request_getport is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(r->BuildConnVal());
	vl->append(pr);
	vl->append(p);

	mgr.QueueEvent(::pm_request_getport, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, r);
	} // event generation
EventHandlerPtr pm_request_dump; 
void BifEvent::generate_pm_request_dump(analyzer::Analyzer* analyzer, Connection* r, Val* m)
	{
	// Note that it is intentional that here we do not
	// check if ::pm_request_dump is NULL, which should happen *before*
	// BifEvent::generate_pm_request_dump is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(r->BuildConnVal());
	vl->append(m);

	mgr.QueueEvent(::pm_request_dump, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, r);
	} // event generation
EventHandlerPtr pm_request_callit; 
void BifEvent::generate_pm_request_callit(analyzer::Analyzer* analyzer, Connection* r, Val* call, PortVal* p)
	{
	// Note that it is intentional that here we do not
	// check if ::pm_request_callit is NULL, which should happen *before*
	// BifEvent::generate_pm_request_callit is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(r->BuildConnVal());
	vl->append(call);
	vl->append(p);

	mgr.QueueEvent(::pm_request_callit, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, r);
	} // event generation
EventHandlerPtr pm_attempt_null; 
void BifEvent::generate_pm_attempt_null(analyzer::Analyzer* analyzer, Connection* r, Val* status)
	{
	// Note that it is intentional that here we do not
	// check if ::pm_attempt_null is NULL, which should happen *before*
	// BifEvent::generate_pm_attempt_null is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(r->BuildConnVal());
	vl->append(status);

	mgr.QueueEvent(::pm_attempt_null, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, r);
	} // event generation
EventHandlerPtr pm_attempt_set; 
void BifEvent::generate_pm_attempt_set(analyzer::Analyzer* analyzer, Connection* r, Val* status, Val* m)
	{
	// Note that it is intentional that here we do not
	// check if ::pm_attempt_set is NULL, which should happen *before*
	// BifEvent::generate_pm_attempt_set is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(r->BuildConnVal());
	vl->append(status);
	vl->append(m);

	mgr.QueueEvent(::pm_attempt_set, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, r);
	} // event generation
EventHandlerPtr pm_attempt_unset; 
void BifEvent::generate_pm_attempt_unset(analyzer::Analyzer* analyzer, Connection* r, Val* status, Val* m)
	{
	// Note that it is intentional that here we do not
	// check if ::pm_attempt_unset is NULL, which should happen *before*
	// BifEvent::generate_pm_attempt_unset is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(r->BuildConnVal());
	vl->append(status);
	vl->append(m);

	mgr.QueueEvent(::pm_attempt_unset, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, r);
	} // event generation
EventHandlerPtr pm_attempt_getport; 
void BifEvent::generate_pm_attempt_getport(analyzer::Analyzer* analyzer, Connection* r, Val* status, Val* pr)
	{
	// Note that it is intentional that here we do not
	// check if ::pm_attempt_getport is NULL, which should happen *before*
	// BifEvent::generate_pm_attempt_getport is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(r->BuildConnVal());
	vl->append(status);
	vl->append(pr);

	mgr.QueueEvent(::pm_attempt_getport, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, r);
	} // event generation
EventHandlerPtr pm_attempt_dump; 
void BifEvent::generate_pm_attempt_dump(analyzer::Analyzer* analyzer, Connection* r, Val* status)
	{
	// Note that it is intentional that here we do not
	// check if ::pm_attempt_dump is NULL, which should happen *before*
	// BifEvent::generate_pm_attempt_dump is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(r->BuildConnVal());
	vl->append(status);

	mgr.QueueEvent(::pm_attempt_dump, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, r);
	} // event generation
EventHandlerPtr pm_attempt_callit; 
void BifEvent::generate_pm_attempt_callit(analyzer::Analyzer* analyzer, Connection* r, Val* status, Val* call)
	{
	// Note that it is intentional that here we do not
	// check if ::pm_attempt_callit is NULL, which should happen *before*
	// BifEvent::generate_pm_attempt_callit is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(r->BuildConnVal());
	vl->append(status);
	vl->append(call);

	mgr.QueueEvent(::pm_attempt_callit, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, r);
	} // event generation
EventHandlerPtr pm_bad_port; 
void BifEvent::generate_pm_bad_port(analyzer::Analyzer* analyzer, Connection* r, bro_uint_t bad_p)
	{
	// Note that it is intentional that here we do not
	// check if ::pm_bad_port is NULL, which should happen *before*
	// BifEvent::generate_pm_bad_port is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(r->BuildConnVal());
	vl->append(new Val(bad_p, TYPE_COUNT));

	mgr.QueueEvent(::pm_bad_port, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, r);
	} // event generation
EventHandlerPtr rpc_dialogue; 
void BifEvent::generate_rpc_dialogue(analyzer::Analyzer* analyzer, Connection* c, bro_uint_t prog, bro_uint_t ver, bro_uint_t proc, Val* status, double start_time, bro_uint_t call_len, bro_uint_t reply_len)
	{
	// Note that it is intentional that here we do not
	// check if ::rpc_dialogue is NULL, which should happen *before*
	// BifEvent::generate_rpc_dialogue is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(prog, TYPE_COUNT));
	vl->append(new Val(ver, TYPE_COUNT));
	vl->append(new Val(proc, TYPE_COUNT));
	vl->append(status);
	vl->append(new Val(start_time, TYPE_TIME));
	vl->append(new Val(call_len, TYPE_COUNT));
	vl->append(new Val(reply_len, TYPE_COUNT));

	mgr.QueueEvent(::rpc_dialogue, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr rpc_call; 
void BifEvent::generate_rpc_call(analyzer::Analyzer* analyzer, Connection* c, bro_uint_t xid, bro_uint_t prog, bro_uint_t ver, bro_uint_t proc, bro_uint_t call_len)
	{
	// Note that it is intentional that here we do not
	// check if ::rpc_call is NULL, which should happen *before*
	// BifEvent::generate_rpc_call is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(xid, TYPE_COUNT));
	vl->append(new Val(prog, TYPE_COUNT));
	vl->append(new Val(ver, TYPE_COUNT));
	vl->append(new Val(proc, TYPE_COUNT));
	vl->append(new Val(call_len, TYPE_COUNT));

	mgr.QueueEvent(::rpc_call, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr rpc_reply; 
void BifEvent::generate_rpc_reply(analyzer::Analyzer* analyzer, Connection* c, bro_uint_t xid, Val* status, bro_uint_t reply_len)
	{
	// Note that it is intentional that here we do not
	// check if ::rpc_reply is NULL, which should happen *before*
	// BifEvent::generate_rpc_reply is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(xid, TYPE_COUNT));
	vl->append(status);
	vl->append(new Val(reply_len, TYPE_COUNT));

	mgr.QueueEvent(::rpc_reply, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation

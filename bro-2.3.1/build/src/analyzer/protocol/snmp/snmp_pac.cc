// This file is automatically generated from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/snmp/snmp.pac.


#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include "/home/benjamin/Bro/bro-2.3.1/build/src/analyzer/protocol/snmp/snmp_pac.h"

namespace binpac {






namespace SNMP {
ContextSNMP::ContextSNMP(SNMP_Conn * connection, SNMP_Flow * flow)
	{
	connection_ = connection;
	flow_ = flow;
	}

ContextSNMP::~ContextSNMP()
	{
	}

SNMP_Conn::SNMP_Conn(BroAnalyzer const & bro_analyzer)
	{
	upflow_ = new SNMP_Flow(this, true);
	downflow_ = new SNMP_Flow(this, false);
	bro_analyzer_ = bro_analyzer;
	}

SNMP_Conn::~SNMP_Conn()
	{
	delete upflow_;
	upflow_ = 0;
	delete downflow_;
	downflow_ = 0;
	}

void SNMP_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void SNMP_Conn::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void SNMP_Conn::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

bool SNMP_Conn::proc_get_request(GetRequestPDU * pdu)
	{

		if ( ! snmp_get_request )
			return false;

		BifEvent::generate_snmp_get_request(bro_analyzer(),
		                                    bro_analyzer()->Conn(),
		                                    pdu->header()->is_orig(),
		                                    build_hdr(pdu->header()),
		                                    build_pdu(pdu->pdu()));
		return true;
		
	}

bool SNMP_Conn::proc_get_next_request(GetNextRequestPDU * pdu)
	{

		if ( ! snmp_get_next_request )
			return false;

		BifEvent::generate_snmp_get_next_request(bro_analyzer(),
		                                         bro_analyzer()->Conn(),
		                                         pdu->header()->is_orig(),
		                                         build_hdr(pdu->header()),
		                                         build_pdu(pdu->pdu()));
		return true;
		
	}

bool SNMP_Conn::proc_response(ResponsePDU * pdu)
	{

		if ( ! snmp_response )
			return false;

		BifEvent::generate_snmp_response(bro_analyzer(),
		                                 bro_analyzer()->Conn(),
		                                 pdu->header()->is_orig(),
		                                 build_hdr(pdu->header()),
		                                 build_pdu(pdu->pdu()));
		return true;
		
	}

bool SNMP_Conn::proc_set_request(SetRequestPDU * pdu)
	{

		if ( ! snmp_set_request )
			return false;

		BifEvent::generate_snmp_set_request(bro_analyzer(),
		                                    bro_analyzer()->Conn(),
		                                    pdu->header()->is_orig(),
		                                    build_hdr(pdu->header()),
		                                    build_pdu(pdu->pdu()));
		return true;
		
	}

bool SNMP_Conn::proc_trap(TrapPDU * pdu)
	{

		if ( ! snmp_trap )
			return false;

		BifEvent::generate_snmp_trap(bro_analyzer(),
		                             bro_analyzer()->Conn(),
		                             pdu->header()->is_orig(),
		                             build_hdr(pdu->header()),
		                             build_trap_pdu(pdu));
		return true;
		
	}

bool SNMP_Conn::proc_get_bulk_request(GetBulkRequestPDU * pdu)
	{

		if ( ! snmp_get_bulk_request )
			return false;

		BifEvent::generate_snmp_get_bulk_request(bro_analyzer(),
		                                         bro_analyzer()->Conn(),
		                                         pdu->header()->is_orig(),
		                                         build_hdr(pdu->header()),
		                                         build_bulk_pdu(pdu));
		return true;
		
	}

bool SNMP_Conn::proc_inform_request(InformRequestPDU * pdu)
	{

		if ( ! snmp_inform_request )
			return false;

		BifEvent::generate_snmp_inform_request(bro_analyzer(),
		                                       bro_analyzer()->Conn(),
		                                       pdu->header()->is_orig(),
		                                       build_hdr(pdu->header()),
		                                       build_pdu(pdu->pdu()));
		return true;
		
	}

bool SNMP_Conn::proc_v2_trap(v2TrapPDU * pdu)
	{

		if ( ! snmp_trapV2 )
			return false;

		BifEvent::generate_snmp_trapV2(bro_analyzer(),
		                               bro_analyzer()->Conn(),
		                               pdu->header()->is_orig(),
		                               build_hdr(pdu->header()),
		                               build_pdu(pdu->pdu()));
		return true;
		
	}

bool SNMP_Conn::proc_report(ReportPDU * pdu)
	{

		if ( ! snmp_report )
			return false;

		BifEvent::generate_snmp_report(bro_analyzer(),
		                               bro_analyzer()->Conn(),
		                               pdu->header()->is_orig(),
		                               build_hdr(pdu->header()),
		                               build_pdu(pdu->pdu()));
		return true;
		
	}

bool SNMP_Conn::proc_unknown_version_header(UnknownVersionHeader * rec)
	{

		if ( ! snmp_unknown_header_version )
			return false;

		BifEvent::generate_snmp_unknown_header_version(bro_analyzer(),
		                                               bro_analyzer()->Conn(),
		                                               rec->header()->is_orig(),
		                                               rec->header()->version());
		return true;
		
	}

bool SNMP_Conn::proc_unknown_pdu(UnknownPDU * rec)
	{

		if ( ! snmp_unknown_pdu )
			return false;

		BifEvent::generate_snmp_unknown_pdu(bro_analyzer(),
		                                    bro_analyzer()->Conn(),
		                                    rec->header()->is_orig(),
		                                    build_hdr(rec->header()),
		                                    rec->tag());
		return true;
		
	}

bool SNMP_Conn::proc_unknown_scoped_pdu(UnknownScopedPDU * rec)
	{

		if ( ! snmp_unknown_scoped_pdu )
			return false;

		BifEvent::generate_snmp_unknown_scoped_pdu(bro_analyzer(),
		                                           bro_analyzer()->Conn(),
		                                           rec->header()->is_orig(),
		                                           build_hdr(rec->header()),
		                                           rec->tag());
		return true;
		
	}

bool SNMP_Conn::proc_encrypted_pdu(EncryptedPDU * rec)
	{

		if ( ! snmp_encrypted_pdu )
			return false;

		BifEvent::generate_snmp_encrypted_pdu(bro_analyzer(),
		                                      bro_analyzer()->Conn(),
		                                      rec->header()->is_orig(),
		                                      build_hdr(rec->header()));
		return true;
		
	}

bool SNMP_Conn::proc_header(Header * rec)
	{

		if ( rec->unknown() )
			return false;

		bro_analyzer()->ProtocolConfirmation();
		return true;
		
	}

bool SNMP_Conn::proc_v3_header_data(v3HeaderData * rec)
	{

		if ( rec->flags()->encoding()->content().length() == 1 )
			return true;

		bro_analyzer()->ProtocolViolation("Invalid v3 HeaderData msgFlags");
		return false;
		
	}

bool SNMP_Conn::check_tag(ASN1EncodingMeta * rec, uint8 expect)
	{

		if ( rec->tag() == expect )
			return true;

		// Unwind now to stop parsing because it's definitely the
		// wrong protocol and parsing further could be expensive.
		// Upper layer of analyzer will catch and call ProtocolViolation().
		throw binpac::Exception(fmt("Got ASN.1 tag %d, expect %d",
		                        rec->tag(), expect));
		return false;
		
	}

bool SNMP_Conn::check_int_width(ASN1Integer * rec)
	{

		int len = rec->encoding()->content().length();

		if ( len <= 9 )
			// All integers use two's complement form, so an unsigned 64-bit
			// integer value can require 9 octets to encode if the highest
			// order bit is set.
			return true;

		throw binpac::Exception(fmt("ASN.1 integer width overflow: %d", len));
		return false;
		
	}

bool SNMP_Conn::check_int(ASN1Integer * rec)
	{

		return check_tag(rec->encoding()->meta(), ASN1_INTEGER_TAG) &&
		       check_int_width(rec);
		
	}

TopLevelMessage::TopLevelMessage(bool is_orig)
	{
	asn1_sequence_meta_ = 0;
	version_ = 0;
	header_ = 0;
	pdu_or_not_case_index_ = -1;
	pdu_ = 0;
	is_orig_ = is_orig;
	version_value_ = 0;
	}

TopLevelMessage::~TopLevelMessage()
	{
	delete asn1_sequence_meta_;
	asn1_sequence_meta_ = 0;
	delete version_;
	version_ = 0;
	delete header_;
	header_ = 0;
	switch ( pdu_or_not_case_index() )
		{
		case 0:
			// Clean up "none"
			{
			}
			break;
		case 1:
			// Clean up "pdu"
			{
			delete pdu_;
			pdu_ = 0;
			}
			break;
		}
	}

int TopLevelMessage::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "asn1_sequence_meta"
	asn1_sequence_meta_ = new ASN1SequenceMeta();
	int t_asn1_sequence_meta__size;
	t_asn1_sequence_meta__size = asn1_sequence_meta_->Parse(t_begin_of_data, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_asn1_sequence_meta = t_begin_of_data + (t_asn1_sequence_meta__size);
	BINPAC_ASSERT(t_dataptr_after_asn1_sequence_meta <= t_end_of_data);
	// Parse "version"
	version_ = new ASN1Integer();
	int t_version__size;
	t_version__size = version_->Parse(t_dataptr_after_asn1_sequence_meta, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_version = t_dataptr_after_asn1_sequence_meta + (t_version__size);
	BINPAC_ASSERT(t_dataptr_after_version <= t_end_of_data);
	// Parse "header"
	version_value_ = binary_to_int64(version()->encoding()->content());
	header_ = new Header(version_value(), is_orig());
	int t_header__size;
	t_header__size = header_->Parse(t_dataptr_after_version, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_header = t_dataptr_after_version + (t_header__size);
	BINPAC_ASSERT(t_dataptr_after_header <= t_end_of_data);
	// Parse "pdu_or_not"
	int t_pdu_or_not__size;
	pdu_or_not_case_index_ = have_plaintext_pdu(header());
	switch ( pdu_or_not_case_index() )
		{
		case 0:
			// Parse "none"
			{
			// Evaluate 'let' and 'withinput' fields
			t_pdu_or_not__size = 0;
			}
			break;
		case 1:
			// Parse "pdu"
			{
			pdu_ = new PDU_Choice(header());
			int t_pdu__size;
			t_pdu__size = pdu_->Parse(t_dataptr_after_header, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_pdu_or_not__size = t_pdu__size;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("TopLevelMessage", pdu_or_not_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_TopLevelMessage__size;
	const_byteptr const t_dataptr_after_pdu_or_not = t_dataptr_after_header + (t_pdu_or_not__size);
	BINPAC_ASSERT(t_dataptr_after_pdu_or_not <= t_end_of_data);
	t_TopLevelMessage__size = t_dataptr_after_pdu_or_not - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_TopLevelMessage__size) <= t_end_of_data);
	return t_TopLevelMessage__size;
	}

Header::Header(int64 version, bool is_orig)
	{
	val_case_index_ = -1;
	v1_ = 0;
	v2_ = 0;
	v3_ = 0;
	unknown_ = 0;
	version_ = version;
	is_orig_ = is_orig;
	proc_ = 0;
	}

Header::~Header()
	{
	switch ( val_case_index() )
		{
		case 0:
			// Clean up "v1"
			{
			delete v1_;
			v1_ = 0;
			}
			break;
		case 1:
			// Clean up "v2"
			{
			delete v2_;
			v2_ = 0;
			}
			break;
		case 3:
			// Clean up "v3"
			{
			delete v3_;
			v3_ = 0;
			}
			break;
		default:
			// Clean up "unknown"
			{
			delete unknown_;
			unknown_ = 0;
			}
			break;
		}
	}

int Header::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	int t_val__size;
	val_case_index_ = version();
	switch ( val_case_index() )
		{
		case 0:
			// Parse "v1"
			{
			v1_ = new v1Header(this);
			int t_v1__size;
			t_v1__size = v1_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_v1__size;
			}
			break;
		case 1:
			// Parse "v2"
			{
			v2_ = new v2Header(this);
			int t_v2__size;
			t_v2__size = v2_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_v2__size;
			}
			break;
		case 3:
			// Parse "v3"
			{
			v3_ = new v3Header(this);
			int t_v3__size;
			t_v3__size = v3_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_v3__size;
			}
			break;
		default:
			// Parse "unknown"
			{
			unknown_ = new UnknownVersionHeader(this);
			int t_unknown__size;
			t_unknown__size = unknown_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_unknown__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_header(this);
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

bool have_plaintext_pdu(Header * header)
	{
	int t_t_var_001;
	switch ( header->version() )
		{
		case 0:
			t_t_var_001 = true;
			break;
		case 1:
			t_t_var_001 = true;
			break;
		case 3:
			t_t_var_001 = header->v3()->next()->tag() == ASN1_SEQUENCE_TAG;
			break;
		default:
			t_t_var_001 = false;
			break;
		}
	return static_cast<bool>(t_t_var_001);
	}

PDU_Choice::PDU_Choice(Header * header)
	{
	choice_ = 0;
	pdu_ = 0;
	header_ = header;
	}

PDU_Choice::~PDU_Choice()
	{
	delete choice_;
	choice_ = 0;
	delete pdu_;
	pdu_ = 0;
	}

int PDU_Choice::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "choice"
	choice_ = new ASN1EncodingMeta();
	int t_choice__size;
	t_choice__size = choice_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_choice = t_begin_of_data + (t_choice__size);
	BINPAC_ASSERT(t_dataptr_after_choice <= t_end_of_data);
	// Parse "pdu"
	pdu_ = new PDU(choice()->tag(), header());
	int t_pdu__size;
	t_pdu__size = pdu_->Parse(t_dataptr_after_choice, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	int t_PDU_Choice__size;
	const_byteptr const t_dataptr_after_pdu = t_dataptr_after_choice + (t_pdu__size);
	BINPAC_ASSERT(t_dataptr_after_pdu <= t_end_of_data);
	t_PDU_Choice__size = t_dataptr_after_pdu - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_PDU_Choice__size) <= t_end_of_data);
	return t_PDU_Choice__size;
	}

PDU::PDU(uint8 choice, Header * header)
	{
	val_case_index_ = -1;
	unknown_ = 0;
	get_request_ = 0;
	get_next_request_ = 0;
	response_ = 0;
	set_request_ = 0;
	trap_ = 0;
	get_bulk_request_ = 0;
	inform_request_ = 0;
	v2_trap_ = 0;
	report_ = 0;
	choice_ = choice;
	header_ = header;
	}

PDU::~PDU()
	{
	switch ( val_case_index() )
		{
		case 160:
			// Clean up "get_request"
			{
			delete get_request_;
			get_request_ = 0;
			}
			break;
		case 161:
			// Clean up "get_next_request"
			{
			delete get_next_request_;
			get_next_request_ = 0;
			}
			break;
		case 162:
			// Clean up "response"
			{
			delete response_;
			response_ = 0;
			}
			break;
		case 163:
			// Clean up "set_request"
			{
			delete set_request_;
			set_request_ = 0;
			}
			break;
		case 164:
			// Clean up "trap"
			{
			delete trap_;
			trap_ = 0;
			}
			break;
		case 165:
			// Clean up "get_bulk_request"
			{
			delete get_bulk_request_;
			get_bulk_request_ = 0;
			}
			break;
		case 166:
			// Clean up "inform_request"
			{
			delete inform_request_;
			inform_request_ = 0;
			}
			break;
		case 167:
			// Clean up "v2_trap"
			{
			delete v2_trap_;
			v2_trap_ = 0;
			}
			break;
		case 168:
			// Clean up "report"
			{
			delete report_;
			report_ = 0;
			}
			break;
		default:
			// Clean up "unknown"
			{
			delete unknown_;
			unknown_ = 0;
			}
			break;
		}
	}

int PDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	int t_val__size;
	val_case_index_ = choice();
	switch ( val_case_index() )
		{
		case 160:
			// Parse "get_request"
			{
			get_request_ = new GetRequestPDU(header());
			int t_get_request__size;
			t_get_request__size = get_request_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_get_request__size;
			}
			break;
		case 161:
			// Parse "get_next_request"
			{
			get_next_request_ = new GetNextRequestPDU(header());
			int t_get_next_request__size;
			t_get_next_request__size = get_next_request_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_get_next_request__size;
			}
			break;
		case 162:
			// Parse "response"
			{
			response_ = new ResponsePDU(header());
			int t_response__size;
			t_response__size = response_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_response__size;
			}
			break;
		case 163:
			// Parse "set_request"
			{
			set_request_ = new SetRequestPDU(header());
			int t_set_request__size;
			t_set_request__size = set_request_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_set_request__size;
			}
			break;
		case 164:
			// Parse "trap"
			{
			trap_ = new TrapPDU(header());
			int t_trap__size;
			t_trap__size = trap_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_trap__size;
			}
			break;
		case 165:
			// Parse "get_bulk_request"
			{
			get_bulk_request_ = new GetBulkRequestPDU(header());
			int t_get_bulk_request__size;
			t_get_bulk_request__size = get_bulk_request_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_get_bulk_request__size;
			}
			break;
		case 166:
			// Parse "inform_request"
			{
			inform_request_ = new InformRequestPDU(header());
			int t_inform_request__size;
			t_inform_request__size = inform_request_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_inform_request__size;
			}
			break;
		case 167:
			// Parse "v2_trap"
			{
			v2_trap_ = new v2TrapPDU(header());
			int t_v2_trap__size;
			t_v2_trap__size = v2_trap_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_v2_trap__size;
			}
			break;
		case 168:
			// Parse "report"
			{
			report_ = new ReportPDU(header());
			int t_report__size;
			t_report__size = report_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_report__size;
			}
			break;
		default:
			// Parse "unknown"
			{
			unknown_ = new UnknownPDU(choice(), header());
			int t_unknown__size;
			t_unknown__size = unknown_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_unknown__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

v1Header::v1Header(Header * header)
	{
	community_ = 0;
	header_ = header;
	}

v1Header::~v1Header()
	{
	delete community_;
	community_ = 0;
	}

int v1Header::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "community"
	community_ = new ASN1OctetString();
	int t_community__size;
	t_community__size = community_->Parse(t_begin_of_data, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	int t_v1Header__size;
	const_byteptr const t_dataptr_after_community = t_begin_of_data + (t_community__size);
	BINPAC_ASSERT(t_dataptr_after_community <= t_end_of_data);
	t_v1Header__size = t_dataptr_after_community - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_v1Header__size) <= t_end_of_data);
	return t_v1Header__size;
	}

v2Header::v2Header(Header * header)
	{
	community_ = 0;
	header_ = header;
	}

v2Header::~v2Header()
	{
	delete community_;
	community_ = 0;
	}

int v2Header::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "community"
	community_ = new ASN1OctetString();
	int t_community__size;
	t_community__size = community_->Parse(t_begin_of_data, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	int t_v2Header__size;
	const_byteptr const t_dataptr_after_community = t_begin_of_data + (t_community__size);
	BINPAC_ASSERT(t_dataptr_after_community <= t_end_of_data);
	t_v2Header__size = t_dataptr_after_community - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_v2Header__size) <= t_end_of_data);
	return t_v2Header__size;
	}

v3Header::v3Header(Header * header)
	{
	global_data_ = 0;
	security_parameters_ = 0;
	next_ = 0;
	scoped_pdu_data_case_index_ = -1;
	plaintext_pdu_ = 0;
	encrypted_pdu_ = 0;
	unknown_pdu_ = 0;
	header_ = header;
	}

v3Header::~v3Header()
	{
	delete global_data_;
	global_data_ = 0;
	delete security_parameters_;
	security_parameters_ = 0;
	delete next_;
	next_ = 0;
	switch ( scoped_pdu_data_case_index() )
		{
		case 48:
			// Clean up "plaintext_pdu"
			{
			delete plaintext_pdu_;
			plaintext_pdu_ = 0;
			}
			break;
		case 4:
			// Clean up "encrypted_pdu"
			{
			delete encrypted_pdu_;
			encrypted_pdu_ = 0;
			}
			break;
		default:
			// Clean up "unknown_pdu"
			{
			delete unknown_pdu_;
			unknown_pdu_ = 0;
			}
			break;
		}
	}

int v3Header::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "global_data"
	global_data_ = new v3HeaderData();
	int t_global_data__size;
	t_global_data__size = global_data_->Parse(t_begin_of_data, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_global_data = t_begin_of_data + (t_global_data__size);
	BINPAC_ASSERT(t_dataptr_after_global_data <= t_end_of_data);
	// Parse "security_parameters"
	security_parameters_ = new ASN1OctetString();
	int t_security_parameters__size;
	t_security_parameters__size = security_parameters_->Parse(t_dataptr_after_global_data, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_security_parameters = t_dataptr_after_global_data + (t_security_parameters__size);
	BINPAC_ASSERT(t_dataptr_after_security_parameters <= t_end_of_data);
	// Parse "next"
	next_ = new ASN1EncodingMeta();
	int t_next__size;
	t_next__size = next_->Parse(t_dataptr_after_security_parameters, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_next = t_dataptr_after_security_parameters + (t_next__size);
	BINPAC_ASSERT(t_dataptr_after_next <= t_end_of_data);
	// Parse "scoped_pdu_data"
	int t_scoped_pdu_data__size;
	scoped_pdu_data_case_index_ = next()->tag();
	switch ( scoped_pdu_data_case_index() )
		{
		case 48:
			// Parse "plaintext_pdu"
			{
			plaintext_pdu_ = new v3ScopedPDU();
			int t_plaintext_pdu__size;
			t_plaintext_pdu__size = plaintext_pdu_->Parse(t_dataptr_after_next, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_scoped_pdu_data__size = t_plaintext_pdu__size;
			}
			break;
		case 4:
			// Parse "encrypted_pdu"
			{
			encrypted_pdu_ = new EncryptedPDU(header());
			int t_encrypted_pdu__size;
			t_encrypted_pdu__size = encrypted_pdu_->Parse(t_dataptr_after_next, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_scoped_pdu_data__size = t_encrypted_pdu__size;
			}
			break;
		default:
			// Parse "unknown_pdu"
			{
			unknown_pdu_ = new UnknownScopedPDU(next()->tag(), header());
			int t_unknown_pdu__size;
			t_unknown_pdu__size = unknown_pdu_->Parse(t_dataptr_after_next, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_scoped_pdu_data__size = t_unknown_pdu__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_v3Header__size;
	const_byteptr const t_dataptr_after_scoped_pdu_data = t_dataptr_after_next + (t_scoped_pdu_data__size);
	BINPAC_ASSERT(t_dataptr_after_scoped_pdu_data <= t_end_of_data);
	t_v3Header__size = t_dataptr_after_scoped_pdu_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_v3Header__size) <= t_end_of_data);
	return t_v3Header__size;
	}

v3HeaderData::v3HeaderData()
	{
	asn1_sequence_meta_ = 0;
	id_ = 0;
	max_size_ = 0;
	flags_ = 0;
	security_model_ = 0;
	proc_ = 0;
	}

v3HeaderData::~v3HeaderData()
	{
	delete asn1_sequence_meta_;
	asn1_sequence_meta_ = 0;
	delete id_;
	id_ = 0;
	delete max_size_;
	max_size_ = 0;
	delete flags_;
	flags_ = 0;
	delete security_model_;
	security_model_ = 0;
	}

int v3HeaderData::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "asn1_sequence_meta"
	asn1_sequence_meta_ = new ASN1SequenceMeta();
	int t_asn1_sequence_meta__size;
	t_asn1_sequence_meta__size = asn1_sequence_meta_->Parse(t_begin_of_data, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_asn1_sequence_meta = t_begin_of_data + (t_asn1_sequence_meta__size);
	BINPAC_ASSERT(t_dataptr_after_asn1_sequence_meta <= t_end_of_data);
	// Parse "id"
	id_ = new ASN1Integer();
	int t_id__size;
	t_id__size = id_->Parse(t_dataptr_after_asn1_sequence_meta, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_id = t_dataptr_after_asn1_sequence_meta + (t_id__size);
	BINPAC_ASSERT(t_dataptr_after_id <= t_end_of_data);
	// Parse "max_size"
	max_size_ = new ASN1Integer();
	int t_max_size__size;
	t_max_size__size = max_size_->Parse(t_dataptr_after_id, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_max_size = t_dataptr_after_id + (t_max_size__size);
	BINPAC_ASSERT(t_dataptr_after_max_size <= t_end_of_data);
	// Parse "flags"
	flags_ = new ASN1OctetString();
	int t_flags__size;
	t_flags__size = flags_->Parse(t_dataptr_after_max_size, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_flags = t_dataptr_after_max_size + (t_flags__size);
	BINPAC_ASSERT(t_dataptr_after_flags <= t_end_of_data);
	// Parse "security_model"
	security_model_ = new ASN1Integer();
	int t_security_model__size;
	t_security_model__size = security_model_->Parse(t_dataptr_after_flags, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	int t_v3HeaderData__size;
	const_byteptr const t_dataptr_after_security_model = t_dataptr_after_flags + (t_security_model__size);
	BINPAC_ASSERT(t_dataptr_after_security_model <= t_end_of_data);
	t_v3HeaderData__size = t_dataptr_after_security_model - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_v3_header_data(this);
	BINPAC_ASSERT(t_begin_of_data + (t_v3HeaderData__size) <= t_end_of_data);
	return t_v3HeaderData__size;
	}

v3ScopedPDU::v3ScopedPDU()
	{
	context_engine_id_ = 0;
	context_name_ = 0;
	}

v3ScopedPDU::~v3ScopedPDU()
	{
	delete context_engine_id_;
	context_engine_id_ = 0;
	delete context_name_;
	context_name_ = 0;
	}

int v3ScopedPDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "context_engine_id"
	context_engine_id_ = new ASN1OctetString();
	int t_context_engine_id__size;
	t_context_engine_id__size = context_engine_id_->Parse(t_begin_of_data, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_context_engine_id = t_begin_of_data + (t_context_engine_id__size);
	BINPAC_ASSERT(t_dataptr_after_context_engine_id <= t_end_of_data);
	// Parse "context_name"
	context_name_ = new ASN1OctetString();
	int t_context_name__size;
	t_context_name__size = context_name_->Parse(t_dataptr_after_context_engine_id, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	int t_v3ScopedPDU__size;
	const_byteptr const t_dataptr_after_context_name = t_dataptr_after_context_engine_id + (t_context_name__size);
	BINPAC_ASSERT(t_dataptr_after_context_name <= t_end_of_data);
	t_v3ScopedPDU__size = t_dataptr_after_context_name - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_v3ScopedPDU__size) <= t_end_of_data);
	return t_v3ScopedPDU__size;
	}

EncryptedPDU::EncryptedPDU(Header * header)
	{
	header_ = header;
	proc_ = 0;
	}

EncryptedPDU::~EncryptedPDU()
	{
	}

int EncryptedPDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/snmp/snmp-protocol.pac:106", t_data_string_length);
	data_.init(t_begin_of_data, t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_EncryptedPDU__size;
	const_byteptr const t_dataptr_after_data = t_begin_of_data + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_EncryptedPDU__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_encrypted_pdu(this);
	BINPAC_ASSERT(t_begin_of_data + (t_EncryptedPDU__size) <= t_end_of_data);
	return t_EncryptedPDU__size;
	}

UnknownScopedPDU::UnknownScopedPDU(uint8 tag, Header * header)
	{
	tag_ = tag;
	header_ = header;
	proc_ = 0;
	}

UnknownScopedPDU::~UnknownScopedPDU()
	{
	}

int UnknownScopedPDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/snmp/snmp-protocol.pac:110", t_data_string_length);
	data_.init(t_begin_of_data, t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_UnknownScopedPDU__size;
	const_byteptr const t_dataptr_after_data = t_begin_of_data + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_UnknownScopedPDU__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_unknown_scoped_pdu(this);
	BINPAC_ASSERT(t_begin_of_data + (t_UnknownScopedPDU__size) <= t_end_of_data);
	return t_UnknownScopedPDU__size;
	}

UnknownVersionHeader::UnknownVersionHeader(Header * header)
	{
	header_ = header;
	proc_ = 0;
	}

UnknownVersionHeader::~UnknownVersionHeader()
	{
	}

int UnknownVersionHeader::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/snmp/snmp-protocol.pac:114", t_data_string_length);
	data_.init(t_begin_of_data, t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_UnknownVersionHeader__size;
	const_byteptr const t_dataptr_after_data = t_begin_of_data + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_UnknownVersionHeader__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_unknown_version_header(this);
	BINPAC_ASSERT(t_begin_of_data + (t_UnknownVersionHeader__size) <= t_end_of_data);
	return t_UnknownVersionHeader__size;
	}

CommonPDU::CommonPDU(Header * header)
	{
	request_id_ = 0;
	error_status_ = 0;
	error_index_ = 0;
	var_bindings_ = 0;
	header_ = header;
	}

CommonPDU::~CommonPDU()
	{
	delete request_id_;
	request_id_ = 0;
	delete error_status_;
	error_status_ = 0;
	delete error_index_;
	error_index_ = 0;
	delete var_bindings_;
	var_bindings_ = 0;
	}

int CommonPDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "request_id"
	request_id_ = new ASN1Integer();
	int t_request_id__size;
	t_request_id__size = request_id_->Parse(t_begin_of_data, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_request_id = t_begin_of_data + (t_request_id__size);
	BINPAC_ASSERT(t_dataptr_after_request_id <= t_end_of_data);
	// Parse "error_status"
	error_status_ = new ASN1Integer();
	int t_error_status__size;
	t_error_status__size = error_status_->Parse(t_dataptr_after_request_id, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_error_status = t_dataptr_after_request_id + (t_error_status__size);
	BINPAC_ASSERT(t_dataptr_after_error_status <= t_end_of_data);
	// Parse "error_index"
	error_index_ = new ASN1Integer();
	int t_error_index__size;
	t_error_index__size = error_index_->Parse(t_dataptr_after_error_status, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_error_index = t_dataptr_after_error_status + (t_error_index__size);
	BINPAC_ASSERT(t_dataptr_after_error_index <= t_end_of_data);
	// Parse "var_bindings"
	var_bindings_ = new VarBindList();
	int t_var_bindings__size;
	t_var_bindings__size = var_bindings_->Parse(t_dataptr_after_error_index, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	int t_CommonPDU__size;
	const_byteptr const t_dataptr_after_var_bindings = t_dataptr_after_error_index + (t_var_bindings__size);
	BINPAC_ASSERT(t_dataptr_after_var_bindings <= t_end_of_data);
	t_CommonPDU__size = t_dataptr_after_var_bindings - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_CommonPDU__size) <= t_end_of_data);
	return t_CommonPDU__size;
	}

GetRequestPDU::GetRequestPDU(Header * header)
	{
	pdu_ = 0;
	header_ = header;
	proc_ = 0;
	}

GetRequestPDU::~GetRequestPDU()
	{
	delete pdu_;
	pdu_ = 0;
	}

int GetRequestPDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "pdu"
	pdu_ = new CommonPDU(header());
	int t_pdu__size;
	t_pdu__size = pdu_->Parse(t_begin_of_data, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	int t_GetRequestPDU__size;
	const_byteptr const t_dataptr_after_pdu = t_begin_of_data + (t_pdu__size);
	BINPAC_ASSERT(t_dataptr_after_pdu <= t_end_of_data);
	t_GetRequestPDU__size = t_dataptr_after_pdu - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_get_request(this);
	BINPAC_ASSERT(t_begin_of_data + (t_GetRequestPDU__size) <= t_end_of_data);
	return t_GetRequestPDU__size;
	}

GetNextRequestPDU::GetNextRequestPDU(Header * header)
	{
	pdu_ = 0;
	header_ = header;
	proc_ = 0;
	}

GetNextRequestPDU::~GetNextRequestPDU()
	{
	delete pdu_;
	pdu_ = 0;
	}

int GetNextRequestPDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "pdu"
	pdu_ = new CommonPDU(header());
	int t_pdu__size;
	t_pdu__size = pdu_->Parse(t_begin_of_data, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	int t_GetNextRequestPDU__size;
	const_byteptr const t_dataptr_after_pdu = t_begin_of_data + (t_pdu__size);
	BINPAC_ASSERT(t_dataptr_after_pdu <= t_end_of_data);
	t_GetNextRequestPDU__size = t_dataptr_after_pdu - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_get_next_request(this);
	BINPAC_ASSERT(t_begin_of_data + (t_GetNextRequestPDU__size) <= t_end_of_data);
	return t_GetNextRequestPDU__size;
	}

ResponsePDU::ResponsePDU(Header * header)
	{
	pdu_ = 0;
	header_ = header;
	proc_ = 0;
	}

ResponsePDU::~ResponsePDU()
	{
	delete pdu_;
	pdu_ = 0;
	}

int ResponsePDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "pdu"
	pdu_ = new CommonPDU(header());
	int t_pdu__size;
	t_pdu__size = pdu_->Parse(t_begin_of_data, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ResponsePDU__size;
	const_byteptr const t_dataptr_after_pdu = t_begin_of_data + (t_pdu__size);
	BINPAC_ASSERT(t_dataptr_after_pdu <= t_end_of_data);
	t_ResponsePDU__size = t_dataptr_after_pdu - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_response(this);
	BINPAC_ASSERT(t_begin_of_data + (t_ResponsePDU__size) <= t_end_of_data);
	return t_ResponsePDU__size;
	}

SetRequestPDU::SetRequestPDU(Header * header)
	{
	pdu_ = 0;
	header_ = header;
	proc_ = 0;
	}

SetRequestPDU::~SetRequestPDU()
	{
	delete pdu_;
	pdu_ = 0;
	}

int SetRequestPDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "pdu"
	pdu_ = new CommonPDU(header());
	int t_pdu__size;
	t_pdu__size = pdu_->Parse(t_begin_of_data, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	int t_SetRequestPDU__size;
	const_byteptr const t_dataptr_after_pdu = t_begin_of_data + (t_pdu__size);
	BINPAC_ASSERT(t_dataptr_after_pdu <= t_end_of_data);
	t_SetRequestPDU__size = t_dataptr_after_pdu - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_set_request(this);
	BINPAC_ASSERT(t_begin_of_data + (t_SetRequestPDU__size) <= t_end_of_data);
	return t_SetRequestPDU__size;
	}

TrapPDU::TrapPDU(Header * header)
	{
	enterprise_ = 0;
	agent_addr_ = 0;
	generic_trap_ = 0;
	specific_trap_ = 0;
	time_stamp_ = 0;
	var_bindings_ = 0;
	header_ = header;
	proc_ = 0;
	}

TrapPDU::~TrapPDU()
	{
	delete enterprise_;
	enterprise_ = 0;
	delete agent_addr_;
	agent_addr_ = 0;
	delete generic_trap_;
	generic_trap_ = 0;
	delete specific_trap_;
	specific_trap_ = 0;
	delete time_stamp_;
	time_stamp_ = 0;
	delete var_bindings_;
	var_bindings_ = 0;
	}

int TrapPDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "enterprise"
	enterprise_ = new ASN1ObjectIdentifier();
	int t_enterprise__size;
	t_enterprise__size = enterprise_->Parse(t_begin_of_data, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_enterprise = t_begin_of_data + (t_enterprise__size);
	BINPAC_ASSERT(t_dataptr_after_enterprise <= t_end_of_data);
	// Parse "agent_addr"
	agent_addr_ = new NetworkAddress();
	int t_agent_addr__size;
	t_agent_addr__size = agent_addr_->Parse(t_dataptr_after_enterprise, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_agent_addr = t_dataptr_after_enterprise + (t_agent_addr__size);
	BINPAC_ASSERT(t_dataptr_after_agent_addr <= t_end_of_data);
	// Parse "generic_trap"
	generic_trap_ = new ASN1Integer();
	int t_generic_trap__size;
	t_generic_trap__size = generic_trap_->Parse(t_dataptr_after_agent_addr, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_generic_trap = t_dataptr_after_agent_addr + (t_generic_trap__size);
	BINPAC_ASSERT(t_dataptr_after_generic_trap <= t_end_of_data);
	// Parse "specific_trap"
	specific_trap_ = new ASN1Integer();
	int t_specific_trap__size;
	t_specific_trap__size = specific_trap_->Parse(t_dataptr_after_generic_trap, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_specific_trap = t_dataptr_after_generic_trap + (t_specific_trap__size);
	BINPAC_ASSERT(t_dataptr_after_specific_trap <= t_end_of_data);
	// Parse "time_stamp"
	time_stamp_ = new TimeTicks();
	int t_time_stamp__size;
	t_time_stamp__size = time_stamp_->Parse(t_dataptr_after_specific_trap, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_time_stamp = t_dataptr_after_specific_trap + (t_time_stamp__size);
	BINPAC_ASSERT(t_dataptr_after_time_stamp <= t_end_of_data);
	// Parse "var_bindings"
	var_bindings_ = new VarBindList();
	int t_var_bindings__size;
	t_var_bindings__size = var_bindings_->Parse(t_dataptr_after_time_stamp, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	int t_TrapPDU__size;
	const_byteptr const t_dataptr_after_var_bindings = t_dataptr_after_time_stamp + (t_var_bindings__size);
	BINPAC_ASSERT(t_dataptr_after_var_bindings <= t_end_of_data);
	t_TrapPDU__size = t_dataptr_after_var_bindings - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_trap(this);
	BINPAC_ASSERT(t_begin_of_data + (t_TrapPDU__size) <= t_end_of_data);
	return t_TrapPDU__size;
	}

GetBulkRequestPDU::GetBulkRequestPDU(Header * header)
	{
	request_id_ = 0;
	non_repeaters_ = 0;
	max_repititions_ = 0;
	var_bindings_ = 0;
	header_ = header;
	proc_ = 0;
	}

GetBulkRequestPDU::~GetBulkRequestPDU()
	{
	delete request_id_;
	request_id_ = 0;
	delete non_repeaters_;
	non_repeaters_ = 0;
	delete max_repititions_;
	max_repititions_ = 0;
	delete var_bindings_;
	var_bindings_ = 0;
	}

int GetBulkRequestPDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "request_id"
	request_id_ = new ASN1Integer();
	int t_request_id__size;
	t_request_id__size = request_id_->Parse(t_begin_of_data, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_request_id = t_begin_of_data + (t_request_id__size);
	BINPAC_ASSERT(t_dataptr_after_request_id <= t_end_of_data);
	// Parse "non_repeaters"
	non_repeaters_ = new ASN1Integer();
	int t_non_repeaters__size;
	t_non_repeaters__size = non_repeaters_->Parse(t_dataptr_after_request_id, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_non_repeaters = t_dataptr_after_request_id + (t_non_repeaters__size);
	BINPAC_ASSERT(t_dataptr_after_non_repeaters <= t_end_of_data);
	// Parse "max_repititions"
	max_repititions_ = new ASN1Integer();
	int t_max_repititions__size;
	t_max_repititions__size = max_repititions_->Parse(t_dataptr_after_non_repeaters, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_max_repititions = t_dataptr_after_non_repeaters + (t_max_repititions__size);
	BINPAC_ASSERT(t_dataptr_after_max_repititions <= t_end_of_data);
	// Parse "var_bindings"
	var_bindings_ = new VarBindList();
	int t_var_bindings__size;
	t_var_bindings__size = var_bindings_->Parse(t_dataptr_after_max_repititions, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	int t_GetBulkRequestPDU__size;
	const_byteptr const t_dataptr_after_var_bindings = t_dataptr_after_max_repititions + (t_var_bindings__size);
	BINPAC_ASSERT(t_dataptr_after_var_bindings <= t_end_of_data);
	t_GetBulkRequestPDU__size = t_dataptr_after_var_bindings - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_get_bulk_request(this);
	BINPAC_ASSERT(t_begin_of_data + (t_GetBulkRequestPDU__size) <= t_end_of_data);
	return t_GetBulkRequestPDU__size;
	}

InformRequestPDU::InformRequestPDU(Header * header)
	{
	pdu_ = 0;
	header_ = header;
	proc_ = 0;
	}

InformRequestPDU::~InformRequestPDU()
	{
	delete pdu_;
	pdu_ = 0;
	}

int InformRequestPDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "pdu"
	pdu_ = new CommonPDU(header());
	int t_pdu__size;
	t_pdu__size = pdu_->Parse(t_begin_of_data, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	int t_InformRequestPDU__size;
	const_byteptr const t_dataptr_after_pdu = t_begin_of_data + (t_pdu__size);
	BINPAC_ASSERT(t_dataptr_after_pdu <= t_end_of_data);
	t_InformRequestPDU__size = t_dataptr_after_pdu - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_inform_request(this);
	BINPAC_ASSERT(t_begin_of_data + (t_InformRequestPDU__size) <= t_end_of_data);
	return t_InformRequestPDU__size;
	}

v2TrapPDU::v2TrapPDU(Header * header)
	{
	pdu_ = 0;
	header_ = header;
	proc_ = 0;
	}

v2TrapPDU::~v2TrapPDU()
	{
	delete pdu_;
	pdu_ = 0;
	}

int v2TrapPDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "pdu"
	pdu_ = new CommonPDU(header());
	int t_pdu__size;
	t_pdu__size = pdu_->Parse(t_begin_of_data, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	int t_v2TrapPDU__size;
	const_byteptr const t_dataptr_after_pdu = t_begin_of_data + (t_pdu__size);
	BINPAC_ASSERT(t_dataptr_after_pdu <= t_end_of_data);
	t_v2TrapPDU__size = t_dataptr_after_pdu - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_v2_trap(this);
	BINPAC_ASSERT(t_begin_of_data + (t_v2TrapPDU__size) <= t_end_of_data);
	return t_v2TrapPDU__size;
	}

ReportPDU::ReportPDU(Header * header)
	{
	pdu_ = 0;
	header_ = header;
	proc_ = 0;
	}

ReportPDU::~ReportPDU()
	{
	delete pdu_;
	pdu_ = 0;
	}

int ReportPDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "pdu"
	pdu_ = new CommonPDU(header());
	int t_pdu__size;
	t_pdu__size = pdu_->Parse(t_begin_of_data, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ReportPDU__size;
	const_byteptr const t_dataptr_after_pdu = t_begin_of_data + (t_pdu__size);
	BINPAC_ASSERT(t_dataptr_after_pdu <= t_end_of_data);
	t_ReportPDU__size = t_dataptr_after_pdu - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_report(this);
	BINPAC_ASSERT(t_begin_of_data + (t_ReportPDU__size) <= t_end_of_data);
	return t_ReportPDU__size;
	}

UnknownPDU::UnknownPDU(uint8 tag, Header * header)
	{
	tag_ = tag;
	header_ = header;
	proc_ = 0;
	}

UnknownPDU::~UnknownPDU()
	{
	}

int UnknownPDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/snmp/snmp-protocol.pac:171", t_data_string_length);
	data_.init(t_begin_of_data, t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_UnknownPDU__size;
	const_byteptr const t_dataptr_after_data = t_begin_of_data + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_UnknownPDU__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_unknown_pdu(this);
	BINPAC_ASSERT(t_begin_of_data + (t_UnknownPDU__size) <= t_end_of_data);
	return t_UnknownPDU__size;
	}

VarBindList::VarBindList()
	{
	asn1_sequence_meta_ = 0;
	bindings_ = 0;
	bindings__elem_ = 0;
	}

VarBindList::~VarBindList()
	{
	delete asn1_sequence_meta_;
	asn1_sequence_meta_ = 0;
	delete bindings__elem_;
	bindings__elem_ = 0;
	if ( bindings() )
		{
		for ( int i = 0; i < (int) bindings()->size(); ++i )
			{
			VarBind * bindings__elem_ = (*bindings_)[i];
			delete bindings__elem_;
			bindings__elem_ = 0;
			}
		}
	delete bindings_;
	}

int VarBindList::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "asn1_sequence_meta"
	asn1_sequence_meta_ = new ASN1SequenceMeta();
	int t_asn1_sequence_meta__size;
	t_asn1_sequence_meta__size = asn1_sequence_meta_->Parse(t_begin_of_data, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_asn1_sequence_meta = t_begin_of_data + (t_asn1_sequence_meta__size);
	BINPAC_ASSERT(t_dataptr_after_asn1_sequence_meta <= t_end_of_data);
	// Parse "bindings"
	int t_bindings__arraylength;
	t_bindings__arraylength = 0;
	bindings__elem_ = 0;
	int t_bindings__elem__it;
	t_bindings__elem__it = 0;
	int t_bindings__size;
	bindings_ = new vector<VarBind *>;
	const_byteptr t_bindings__elem__dataptr = t_dataptr_after_asn1_sequence_meta;
	for (; /* forever */; ++t_bindings__elem__it)
		{
		// Check &until(bindings__elem__dataptr >= end_of_data)
		if ( t_bindings__elem__dataptr >= t_end_of_data )
			{
			bindings__elem_ = 0;
			goto end_of_bindings;
			}
		bindings__elem_ = new VarBind();
		int t_bindings__elem__size;
		t_bindings__elem__size = bindings__elem_->Parse(t_bindings__elem__dataptr, t_end_of_data, t_context);
		// Evaluate 'let' and 'withinput' fields
		bindings_->push_back(bindings__elem_);
		t_bindings__elem__dataptr += t_bindings__elem__size;
		BINPAC_ASSERT(t_bindings__elem__dataptr <= t_end_of_data);
		bindings__elem_ = 0;
		}
end_of_bindings: ;
	t_bindings__size = t_bindings__elem__dataptr - (t_dataptr_after_asn1_sequence_meta);
	// Evaluate 'let' and 'withinput' fields
	
	int t_VarBindList__size;
	const_byteptr const t_dataptr_after_bindings = t_dataptr_after_asn1_sequence_meta + (t_bindings__size);
	BINPAC_ASSERT(t_dataptr_after_bindings <= t_end_of_data);
	t_VarBindList__size = t_dataptr_after_bindings - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_VarBindList__size) <= t_end_of_data);
	return t_VarBindList__size;
	}

VarBind::VarBind()
	{
	asn1_sequence_meta_ = 0;
	name_ = 0;
	value_ = 0;
	}

VarBind::~VarBind()
	{
	delete asn1_sequence_meta_;
	asn1_sequence_meta_ = 0;
	delete name_;
	name_ = 0;
	delete value_;
	value_ = 0;
	}

int VarBind::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "asn1_sequence_meta"
	asn1_sequence_meta_ = new ASN1SequenceMeta();
	int t_asn1_sequence_meta__size;
	t_asn1_sequence_meta__size = asn1_sequence_meta_->Parse(t_begin_of_data, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_asn1_sequence_meta = t_begin_of_data + (t_asn1_sequence_meta__size);
	BINPAC_ASSERT(t_dataptr_after_asn1_sequence_meta <= t_end_of_data);
	// Parse "name"
	name_ = new ObjectName();
	int t_name__size;
	t_name__size = name_->Parse(t_dataptr_after_asn1_sequence_meta, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_name = t_dataptr_after_asn1_sequence_meta + (t_name__size);
	BINPAC_ASSERT(t_dataptr_after_name <= t_end_of_data);
	// Parse "value"
	value_ = new ObjectSyntax();
	int t_value__size;
	t_value__size = value_->Parse(t_dataptr_after_name, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_VarBind__size;
	const_byteptr const t_dataptr_after_value = t_dataptr_after_name + (t_value__size);
	BINPAC_ASSERT(t_dataptr_after_value <= t_end_of_data);
	t_VarBind__size = t_dataptr_after_value - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_VarBind__size) <= t_end_of_data);
	return t_VarBind__size;
	}

ObjectName::ObjectName()
	{
	oid_ = 0;
	}

ObjectName::~ObjectName()
	{
	delete oid_;
	oid_ = 0;
	}

int ObjectName::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "oid"
	oid_ = new ASN1ObjectIdentifier();
	int t_oid__size;
	t_oid__size = oid_->Parse(t_begin_of_data, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ObjectName__size;
	const_byteptr const t_dataptr_after_oid = t_begin_of_data + (t_oid__size);
	BINPAC_ASSERT(t_dataptr_after_oid <= t_end_of_data);
	t_ObjectName__size = t_dataptr_after_oid - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ObjectName__size) <= t_end_of_data);
	return t_ObjectName__size;
	}

ObjectSyntax::ObjectSyntax()
	{
	encoding_ = 0;
	}

ObjectSyntax::~ObjectSyntax()
	{
	delete encoding_;
	encoding_ = 0;
	}

int ObjectSyntax::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "encoding"
	encoding_ = new ASN1Encoding();
	int t_encoding__size;
	t_encoding__size = encoding_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ObjectSyntax__size;
	const_byteptr const t_dataptr_after_encoding = t_begin_of_data + (t_encoding__size);
	BINPAC_ASSERT(t_dataptr_after_encoding <= t_end_of_data);
	t_ObjectSyntax__size = t_dataptr_after_encoding - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ObjectSyntax__size) <= t_end_of_data);
	return t_ObjectSyntax__size;
	}

NetworkAddress::NetworkAddress()
	{
	encoding_ = 0;
	valid_ = 0;
	}

NetworkAddress::~NetworkAddress()
	{
	delete encoding_;
	encoding_ = 0;
	}

int NetworkAddress::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "encoding"
	encoding_ = new ASN1Encoding();
	int t_encoding__size;
	t_encoding__size = encoding_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_NetworkAddress__size;
	const_byteptr const t_dataptr_after_encoding = t_begin_of_data + (t_encoding__size);
	BINPAC_ASSERT(t_dataptr_after_encoding <= t_end_of_data);
	t_NetworkAddress__size = t_dataptr_after_encoding - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	valid_ = t_context->connection()->check_tag(encoding()->meta(), APP_IPADDRESS_TAG);
	BINPAC_ASSERT(t_begin_of_data + (t_NetworkAddress__size) <= t_end_of_data);
	return t_NetworkAddress__size;
	}

TimeTicks::TimeTicks()
	{
	asn1_integer_ = 0;
	valid_ = 0;
	}

TimeTicks::~TimeTicks()
	{
	delete asn1_integer_;
	asn1_integer_ = 0;
	}

int TimeTicks::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "asn1_integer"
	asn1_integer_ = new ASN1Encoding();
	int t_asn1_integer__size;
	t_asn1_integer__size = asn1_integer_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_TimeTicks__size;
	const_byteptr const t_dataptr_after_asn1_integer = t_begin_of_data + (t_asn1_integer__size);
	BINPAC_ASSERT(t_dataptr_after_asn1_integer <= t_end_of_data);
	t_TimeTicks__size = t_dataptr_after_asn1_integer - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	valid_ = t_context->connection()->check_tag(asn1_integer()->meta(), APP_TIMETICKS_TAG);
	BINPAC_ASSERT(t_begin_of_data + (t_TimeTicks__size) <= t_end_of_data);
	return t_TimeTicks__size;
	}

ASN1Encoding::ASN1Encoding()
	{
	meta_ = 0;
	}

ASN1Encoding::~ASN1Encoding()
	{
	delete meta_;
	meta_ = 0;
	content_.free();
	}

int ASN1Encoding::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "meta"
	meta_ = new ASN1EncodingMeta();
	int t_meta__size;
	t_meta__size = meta_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_meta = t_begin_of_data + (t_meta__size);
	BINPAC_ASSERT(t_dataptr_after_meta <= t_end_of_data);
	// Parse "content"
	int t_content__size;
	t_content__size = meta()->length();
	// Checking out-of-bound for "ASN1Encoding:content"
	if ( t_dataptr_after_meta + (t_content__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ASN1Encoding:content",
			((t_dataptr_after_meta - t_begin_of_data)) + (t_content__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_meta + t_content__size;
	int t_content_string_length;
	t_content_string_length = meta()->length();
	// check for negative sizes
	if ( t_content_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/snmp/snmp-protocol.pac:231", t_content_string_length);
	content_.init(t_dataptr_after_meta, t_content_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_ASN1Encoding__size;
	const_byteptr const t_dataptr_after_content = t_dataptr_after_meta + (t_content__size);
	BINPAC_ASSERT(t_dataptr_after_content <= t_end_of_data);
	t_ASN1Encoding__size = t_dataptr_after_content - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ASN1Encoding__size) <= t_end_of_data);
	return t_ASN1Encoding__size;
	}

ASN1EncodingMeta::ASN1EncodingMeta()
	{
	tag_ = 0;
	len_ = 0;
	long_len_ = 0;
	length_ = 0;
	}

ASN1EncodingMeta::~ASN1EncodingMeta()
	{
	more_len_.free();
	}

int ASN1EncodingMeta::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "ASN1EncodingMeta:len"
	if ( (t_begin_of_data + 1) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ASN1EncodingMeta:len",
			(1) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "tag"
	tag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "len"
	len_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "more_len"
	int t_more_len__size;
	long_len_ = len() & 0x80;
	t_more_len__size = long_len() ? len() & 0x7f : 0;
	// Checking out-of-bound for "ASN1EncodingMeta:more_len"
	if ( (t_begin_of_data + 2) + (t_more_len__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ASN1EncodingMeta:more_len",
			(2) + (t_more_len__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 2) + t_more_len__size;
	int t_more_len_string_length;
	t_more_len_string_length = long_len() ? len() & 0x7f : 0;
	// check for negative sizes
	if ( t_more_len_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/snmp/snmp-protocol.pac:237", t_more_len_string_length);
	more_len_.init((t_begin_of_data + 2), t_more_len_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_ASN1EncodingMeta__size;
	const_byteptr const t_dataptr_after_more_len = (t_begin_of_data + 2) + (t_more_len__size);
	BINPAC_ASSERT(t_dataptr_after_more_len <= t_end_of_data);
	t_ASN1EncodingMeta__size = t_dataptr_after_more_len - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	length_ = long_len() ? binary_to_int64(more_len()) : len() & 0x7f;
	BINPAC_ASSERT(t_begin_of_data + (t_ASN1EncodingMeta__size) <= t_end_of_data);
	return t_ASN1EncodingMeta__size;
	}

ASN1SequenceMeta::ASN1SequenceMeta()
	{
	encoding_ = 0;
	valid_ = 0;
	}

ASN1SequenceMeta::~ASN1SequenceMeta()
	{
	delete encoding_;
	encoding_ = 0;
	}

int ASN1SequenceMeta::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "encoding"
	encoding_ = new ASN1EncodingMeta();
	int t_encoding__size;
	t_encoding__size = encoding_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ASN1SequenceMeta__size;
	const_byteptr const t_dataptr_after_encoding = t_begin_of_data + (t_encoding__size);
	BINPAC_ASSERT(t_dataptr_after_encoding <= t_end_of_data);
	t_ASN1SequenceMeta__size = t_dataptr_after_encoding - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	valid_ = t_context->connection()->check_tag(encoding(), ASN1_SEQUENCE_TAG);
	BINPAC_ASSERT(t_begin_of_data + (t_ASN1SequenceMeta__size) <= t_end_of_data);
	return t_ASN1SequenceMeta__size;
	}

ASN1Integer::ASN1Integer()
	{
	encoding_ = 0;
	valid_ = 0;
	}

ASN1Integer::~ASN1Integer()
	{
	delete encoding_;
	encoding_ = 0;
	}

int ASN1Integer::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "encoding"
	encoding_ = new ASN1Encoding();
	int t_encoding__size;
	t_encoding__size = encoding_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ASN1Integer__size;
	const_byteptr const t_dataptr_after_encoding = t_begin_of_data + (t_encoding__size);
	BINPAC_ASSERT(t_dataptr_after_encoding <= t_end_of_data);
	t_ASN1Integer__size = t_dataptr_after_encoding - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	valid_ = t_context->connection()->check_int(this);
	BINPAC_ASSERT(t_begin_of_data + (t_ASN1Integer__size) <= t_end_of_data);
	return t_ASN1Integer__size;
	}

ASN1OctetString::ASN1OctetString()
	{
	encoding_ = 0;
	valid_ = 0;
	}

ASN1OctetString::~ASN1OctetString()
	{
	delete encoding_;
	encoding_ = 0;
	}

int ASN1OctetString::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "encoding"
	encoding_ = new ASN1Encoding();
	int t_encoding__size;
	t_encoding__size = encoding_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ASN1OctetString__size;
	const_byteptr const t_dataptr_after_encoding = t_begin_of_data + (t_encoding__size);
	BINPAC_ASSERT(t_dataptr_after_encoding <= t_end_of_data);
	t_ASN1OctetString__size = t_dataptr_after_encoding - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	valid_ = t_context->connection()->check_tag(encoding()->meta(), ASN1_OCTET_STRING_TAG);
	BINPAC_ASSERT(t_begin_of_data + (t_ASN1OctetString__size) <= t_end_of_data);
	return t_ASN1OctetString__size;
	}

ASN1ObjectIdentifier::ASN1ObjectIdentifier()
	{
	encoding_ = 0;
	valid_ = 0;
	}

ASN1ObjectIdentifier::~ASN1ObjectIdentifier()
	{
	delete encoding_;
	encoding_ = 0;
	}

int ASN1ObjectIdentifier::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSNMP * t_context)
	{
	// Parse "encoding"
	encoding_ = new ASN1Encoding();
	int t_encoding__size;
	t_encoding__size = encoding_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ASN1ObjectIdentifier__size;
	const_byteptr const t_dataptr_after_encoding = t_begin_of_data + (t_encoding__size);
	BINPAC_ASSERT(t_dataptr_after_encoding <= t_end_of_data);
	t_ASN1ObjectIdentifier__size = t_dataptr_after_encoding - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	valid_ = t_context->connection()->check_tag(encoding()->meta(), ASN1_OBJECT_IDENTIFIER_TAG);
	BINPAC_ASSERT(t_begin_of_data + (t_ASN1ObjectIdentifier__size) <= t_end_of_data);
	return t_ASN1ObjectIdentifier__size;
	}

int64 binary_to_int64(bytestring const & bs)
	{

	int64 rval = 0;

	for ( int i = 0; i < bs.length(); ++i )
		{
		uint64 byte = bs[i];
		rval |= byte << (8 * (bs.length() - (i + 1)));
		}

	return rval;
	
	}

SNMP_Flow::SNMP_Flow(SNMP_Conn * connection, bool is_orig)
	{
	connection_ = connection;
	is_orig_ = is_orig;
	dataunit_ = 0;
	context_ = 0;
	}

SNMP_Flow::~SNMP_Flow()
	{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;
	}

void SNMP_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		dataunit_ = new TopLevelMessage(is_orig());
		context_ = new ContextSNMP(connection(), this);
		int t_dataunit__size;
		t_dataunit__size = dataunit_->Parse(t_begin_of_data, t_end_of_data, context_);
		// Evaluate 'let' and 'withinput' fields
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		}
	catch ( binpac::Exception const &e )
		{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		throw;
		}
	}

void SNMP_Flow::NewGap(int gap_length)
	{
	}
void SNMP_Flow::FlowEOF()
	{
	}


StringVal* asn1_oid_to_val(const ASN1ObjectIdentifier* oid)
	{
	return asn1_oid_to_val(oid->encoding());
	}

StringVal* asn1_oid_to_val(const ASN1Encoding* oid)
	{
	vector<uint64> oid_components;
	vector<vector<uint8> > subidentifiers;
	vector<uint64> subidentifier_values;
	vector<uint8> subidentifier;
	bytestring const& bs = oid->content();

	for ( int i = 0; i < bs.length(); ++i )
		{
		if ( bs[i] & 0x80 )
			subidentifier.push_back(bs[i] & 0x7f);
		else
			{
			subidentifier.push_back(bs[i]);
			subidentifiers.push_back(subidentifier);
			subidentifier.clear();
			}
		}

	if ( ! subidentifier.empty() || subidentifiers.size() < 1 )
		// Underflow.
		return new StringVal("");

	for ( size_t i = 0; i < subidentifiers.size(); ++i )
		{
		subidentifier = subidentifiers[i];
		uint64 value = 0;

		for ( size_t j = 0; j < subidentifier.size(); ++j )
			{
			uint64 byte = subidentifier[j];
			value |= byte << (7 * (subidentifier.size() - (j + 1)));
			}

		subidentifier_values.push_back(value);
		}

	string rval;

	for ( size_t i = 0; i < subidentifier_values.size(); ++i )
		{
		char tmp[32];

		if ( i > 0 )
			{
			rval += ".";
			snprintf(tmp, sizeof(tmp), "%"PRIu64, subidentifier_values[i]);
			rval += tmp;
			}
		else
			{
			std::div_t result = std::div(subidentifier_values[i], 40);
			snprintf(tmp, sizeof(tmp), "%d", result.quot);
			rval += tmp;
			rval += ".";
			snprintf(tmp, sizeof(tmp), "%d", result.rem);
			rval += tmp;
			}
		}

	return new StringVal(rval);
	}

Val* asn1_obj_to_val(const ASN1Encoding* obj)
	{
	RecordVal* rval = new RecordVal(BifType::Record::SNMP::ObjectValue);
	uint8 tag = obj->meta()->tag();

	rval->Assign(0, new Val(tag, TYPE_COUNT));

	switch ( tag ) {
	case VARBIND_UNSPECIFIED_TAG:
	case VARBIND_NOSUCHOBJECT_TAG:
	case VARBIND_NOSUCHINSTANCE_TAG:
	case VARBIND_ENDOFMIBVIEW_TAG:
		break;

	case ASN1_OBJECT_IDENTIFIER_TAG:
		rval->Assign(1, asn1_oid_to_val(obj));
		break;

	case ASN1_INTEGER_TAG:
		rval->Assign(2, asn1_integer_to_val(obj, TYPE_INT));
		break;

	case APP_COUNTER32_TAG:
	case APP_UNSIGNED32_TAG:
	case APP_TIMETICKS_TAG:
	case APP_COUNTER64_TAG:
		rval->Assign(3, asn1_integer_to_val(obj, TYPE_COUNT));
		break;

	case APP_IPADDRESS_TAG:
		rval->Assign(4, network_address_to_val(obj));
		break;

	case ASN1_OCTET_STRING_TAG:
	case APP_OPAQUE_TAG:
	default:
		rval->Assign(5, asn1_octet_string_to_val(obj));
		break;
	}

	return rval;
	}

StringVal* asn1_octet_string_to_val(const ASN1OctetString* s)
	{
	return asn1_octet_string_to_val(s->encoding());
	}

StringVal* asn1_octet_string_to_val(const ASN1Encoding* s)
	{
	bytestring const& bs = s->content();
	return new StringVal(bs.length(), reinterpret_cast<const char*>(bs.data()));
	}

Val* asn1_integer_to_val(const ASN1Integer* i, TypeTag t)
	{
	return asn1_integer_to_val(i->encoding(), t);
	}

Val* asn1_integer_to_val(const ASN1Encoding* i, TypeTag t)
	{
	return new Val(binary_to_int64(i->content()), t);
	}

AddrVal* network_address_to_val(const NetworkAddress* na)
	{
	return network_address_to_val(na->encoding());
	}

AddrVal* network_address_to_val(const ASN1Encoding* na)
	{
	bytestring const& bs = na->content();

	// IPv6 can probably be presumed to be a octet string of length 16,
	// but standards don't seem to currently make any provisions for IPv6,
	// so ignore anything that can't be IPv4.
	if ( bs.length() != 4 )
		return new AddrVal(IPAddr());

	const u_char* data = reinterpret_cast<const u_char*>(bs.data());
	uint32 network_order = extract_uint32(data);
	return new AddrVal(network_order);
	}

Val* time_ticks_to_val(const TimeTicks* tt)
	{
	return asn1_integer_to_val(tt->asn1_integer(), TYPE_COUNT);
	}

RecordVal* build_hdr(const Header* header)
	{
	RecordVal* rv = new RecordVal(BifType::Record::SNMP::Header);
	rv->Assign(0, new Val(header->version(), TYPE_COUNT));

	switch ( header->version() ) {
	case SNMPV1_TAG:
		{
		RecordVal* v1 = new RecordVal(BifType::Record::SNMP::HeaderV1);
		v1->Assign(0, asn1_octet_string_to_val(header->v1()->community()));
		rv->Assign(1, v1);
		}
		break;

	case SNMPV2_TAG:
		{
		RecordVal* v2 = new RecordVal(BifType::Record::SNMP::HeaderV2);
		v2->Assign(0, asn1_octet_string_to_val(header->v2()->community()));
		rv->Assign(2, v2);
		}
		break;

	case SNMPV3_TAG:
		{
		rv->Assign(3, build_hdrV3(header));
		}
		break;
	}

	return rv;
	}

RecordVal* build_hdrV3(const Header* header)
	{
	RecordVal* v3 = new RecordVal(BifType::Record::SNMP::HeaderV3);
	const v3Header* v3hdr = header->v3();
	const v3HeaderData* global_data = v3hdr->global_data();
	bytestring const& flags = global_data->flags()->encoding()->content();
	uint8 flags_byte = flags.length() > 0 ? flags[0] : 0;

	v3->Assign(0, asn1_integer_to_val(global_data->id(), TYPE_COUNT));
	v3->Assign(1, asn1_integer_to_val(global_data->max_size(),
	                                        TYPE_COUNT));
	v3->Assign(2, new Val(flags_byte, TYPE_COUNT));
	v3->Assign(3, new Val(flags_byte & 0x01, TYPE_BOOL));
	v3->Assign(4, new Val(flags_byte & 0x02, TYPE_BOOL));
	v3->Assign(5, new Val(flags_byte & 0x04, TYPE_BOOL));
	v3->Assign(6, asn1_integer_to_val(global_data->security_model(),
	                                        TYPE_COUNT));
	v3->Assign(7, asn1_octet_string_to_val(v3hdr->security_parameters()));

	if ( v3hdr->next()->tag() == ASN1_SEQUENCE_TAG )
		{
		const v3ScopedPDU* spdu = v3hdr->plaintext_pdu();
		RecordVal* rv = new RecordVal(BifType::Record::SNMP::ScopedPDU_Context);
		rv->Assign(0, asn1_octet_string_to_val(spdu->context_engine_id()));
		rv->Assign(1, asn1_octet_string_to_val(spdu->context_name()));
		v3->Assign(8, rv);
		}

	return v3;
	}

VectorVal* build_bindings(const VarBindList* vbl)
	{
	VectorVal* vv = new VectorVal(BifType::Vector::SNMP::Bindings);

	for ( size_t i = 0; i < vbl->bindings()->size(); ++i )
		{
		VarBind* vb = (*vbl->bindings())[i];
		RecordVal* binding = new RecordVal(BifType::Record::SNMP::Binding);
		binding->Assign(0, asn1_oid_to_val(vb->name()->oid()));
		binding->Assign(1, asn1_obj_to_val(vb->value()->encoding()));
		vv->Assign(i, binding);
		}

	return vv;
	}

RecordVal* build_pdu(const CommonPDU* pdu)
	{
	RecordVal* rv = new RecordVal(BifType::Record::SNMP::PDU);
	rv->Assign(0, asn1_integer_to_val(pdu->request_id(), TYPE_INT));
	rv->Assign(1, asn1_integer_to_val(pdu->error_status(), TYPE_INT));
	rv->Assign(2, asn1_integer_to_val(pdu->error_index(), TYPE_INT));
	rv->Assign(3, build_bindings(pdu->var_bindings()));
	return rv;
	}

RecordVal* build_trap_pdu(const TrapPDU* pdu)
	{
	RecordVal* rv = new RecordVal(BifType::Record::SNMP::TrapPDU);
	rv->Assign(0, asn1_oid_to_val(pdu->enterprise()));
	rv->Assign(1, network_address_to_val(pdu->agent_addr()));
	rv->Assign(2, asn1_integer_to_val(pdu->generic_trap(), TYPE_INT));
	rv->Assign(3, asn1_integer_to_val(pdu->specific_trap(), TYPE_INT));
	rv->Assign(4, time_ticks_to_val(pdu->time_stamp()));
	rv->Assign(5, build_bindings(pdu->var_bindings()));
	return rv;
	}

RecordVal* build_bulk_pdu(const GetBulkRequestPDU* pdu)
	{
	RecordVal* rv =  new RecordVal(BifType::Record::SNMP::BulkPDU);
	rv->Assign(0, asn1_integer_to_val(pdu->request_id(), TYPE_INT));
	rv->Assign(1, asn1_integer_to_val(pdu->non_repeaters(), TYPE_COUNT));
	rv->Assign(2, asn1_integer_to_val(pdu->max_repititions(), TYPE_COUNT));
	rv->Assign(3, build_bindings(pdu->var_bindings()));
	return rv;
	}

} // namespace SNMP
}  // namespace binpac

// This file was automatically generated by bifcl from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/icmp/events.bif (plugin mode).


#include "events.bif.h"

EventHandlerPtr icmp_sent; 
void BifEvent::generate_icmp_sent(analyzer::Analyzer* analyzer, Connection* c, Val* icmp)
	{
	// Note that it is intentional that here we do not
	// check if ::icmp_sent is NULL, which should happen *before*
	// BifEvent::generate_icmp_sent is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(icmp);

	mgr.QueueEvent(::icmp_sent, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr icmp_echo_request; 
void BifEvent::generate_icmp_echo_request(analyzer::Analyzer* analyzer, Connection* c, Val* icmp, bro_uint_t id, bro_uint_t seq, StringVal* payload)
	{
	// Note that it is intentional that here we do not
	// check if ::icmp_echo_request is NULL, which should happen *before*
	// BifEvent::generate_icmp_echo_request is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(icmp);
	vl->append(new Val(id, TYPE_COUNT));
	vl->append(new Val(seq, TYPE_COUNT));
	vl->append(payload);

	mgr.QueueEvent(::icmp_echo_request, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr icmp_echo_reply; 
void BifEvent::generate_icmp_echo_reply(analyzer::Analyzer* analyzer, Connection* c, Val* icmp, bro_uint_t id, bro_uint_t seq, StringVal* payload)
	{
	// Note that it is intentional that here we do not
	// check if ::icmp_echo_reply is NULL, which should happen *before*
	// BifEvent::generate_icmp_echo_reply is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(icmp);
	vl->append(new Val(id, TYPE_COUNT));
	vl->append(new Val(seq, TYPE_COUNT));
	vl->append(payload);

	mgr.QueueEvent(::icmp_echo_reply, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr icmp_error_message; 
void BifEvent::generate_icmp_error_message(analyzer::Analyzer* analyzer, Connection* c, Val* icmp, bro_uint_t code, Val* context)
	{
	// Note that it is intentional that here we do not
	// check if ::icmp_error_message is NULL, which should happen *before*
	// BifEvent::generate_icmp_error_message is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(icmp);
	vl->append(new Val(code, TYPE_COUNT));
	vl->append(context);

	mgr.QueueEvent(::icmp_error_message, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr icmp_unreachable; 
void BifEvent::generate_icmp_unreachable(analyzer::Analyzer* analyzer, Connection* c, Val* icmp, bro_uint_t code, Val* context)
	{
	// Note that it is intentional that here we do not
	// check if ::icmp_unreachable is NULL, which should happen *before*
	// BifEvent::generate_icmp_unreachable is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(icmp);
	vl->append(new Val(code, TYPE_COUNT));
	vl->append(context);

	mgr.QueueEvent(::icmp_unreachable, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr icmp_packet_too_big; 
void BifEvent::generate_icmp_packet_too_big(analyzer::Analyzer* analyzer, Connection* c, Val* icmp, bro_uint_t code, Val* context)
	{
	// Note that it is intentional that here we do not
	// check if ::icmp_packet_too_big is NULL, which should happen *before*
	// BifEvent::generate_icmp_packet_too_big is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(icmp);
	vl->append(new Val(code, TYPE_COUNT));
	vl->append(context);

	mgr.QueueEvent(::icmp_packet_too_big, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr icmp_time_exceeded; 
void BifEvent::generate_icmp_time_exceeded(analyzer::Analyzer* analyzer, Connection* c, Val* icmp, bro_uint_t code, Val* context)
	{
	// Note that it is intentional that here we do not
	// check if ::icmp_time_exceeded is NULL, which should happen *before*
	// BifEvent::generate_icmp_time_exceeded is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(icmp);
	vl->append(new Val(code, TYPE_COUNT));
	vl->append(context);

	mgr.QueueEvent(::icmp_time_exceeded, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr icmp_parameter_problem; 
void BifEvent::generate_icmp_parameter_problem(analyzer::Analyzer* analyzer, Connection* c, Val* icmp, bro_uint_t code, Val* context)
	{
	// Note that it is intentional that here we do not
	// check if ::icmp_parameter_problem is NULL, which should happen *before*
	// BifEvent::generate_icmp_parameter_problem is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(icmp);
	vl->append(new Val(code, TYPE_COUNT));
	vl->append(context);

	mgr.QueueEvent(::icmp_parameter_problem, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr icmp_router_solicitation; 
void BifEvent::generate_icmp_router_solicitation(analyzer::Analyzer* analyzer, Connection* c, Val* icmp, Val* options)
	{
	// Note that it is intentional that here we do not
	// check if ::icmp_router_solicitation is NULL, which should happen *before*
	// BifEvent::generate_icmp_router_solicitation is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(icmp);
	vl->append(options);

	mgr.QueueEvent(::icmp_router_solicitation, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr icmp_router_advertisement; 
void BifEvent::generate_icmp_router_advertisement(analyzer::Analyzer* analyzer, Connection* c, Val* icmp, bro_uint_t cur_hop_limit, int managed, int other, int home_agent, bro_uint_t pref, int proxy, bro_uint_t rsv, double router_lifetime, double reachable_time, double retrans_timer, Val* options)
	{
	// Note that it is intentional that here we do not
	// check if ::icmp_router_advertisement is NULL, which should happen *before*
	// BifEvent::generate_icmp_router_advertisement is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(icmp);
	vl->append(new Val(cur_hop_limit, TYPE_COUNT));
	vl->append(new Val(managed, TYPE_BOOL));
	vl->append(new Val(other, TYPE_BOOL));
	vl->append(new Val(home_agent, TYPE_BOOL));
	vl->append(new Val(pref, TYPE_COUNT));
	vl->append(new Val(proxy, TYPE_BOOL));
	vl->append(new Val(rsv, TYPE_COUNT));
	vl->append(new IntervalVal(router_lifetime, Seconds));
	vl->append(new IntervalVal(reachable_time, Seconds));
	vl->append(new IntervalVal(retrans_timer, Seconds));
	vl->append(options);

	mgr.QueueEvent(::icmp_router_advertisement, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr icmp_neighbor_solicitation; 
void BifEvent::generate_icmp_neighbor_solicitation(analyzer::Analyzer* analyzer, Connection* c, Val* icmp, AddrVal* tgt, Val* options)
	{
	// Note that it is intentional that here we do not
	// check if ::icmp_neighbor_solicitation is NULL, which should happen *before*
	// BifEvent::generate_icmp_neighbor_solicitation is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(icmp);
	vl->append(tgt);
	vl->append(options);

	mgr.QueueEvent(::icmp_neighbor_solicitation, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr icmp_neighbor_advertisement; 
void BifEvent::generate_icmp_neighbor_advertisement(analyzer::Analyzer* analyzer, Connection* c, Val* icmp, int router, int solicited, int override, AddrVal* tgt, Val* options)
	{
	// Note that it is intentional that here we do not
	// check if ::icmp_neighbor_advertisement is NULL, which should happen *before*
	// BifEvent::generate_icmp_neighbor_advertisement is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(icmp);
	vl->append(new Val(router, TYPE_BOOL));
	vl->append(new Val(solicited, TYPE_BOOL));
	vl->append(new Val(override, TYPE_BOOL));
	vl->append(tgt);
	vl->append(options);

	mgr.QueueEvent(::icmp_neighbor_advertisement, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr icmp_redirect; 
void BifEvent::generate_icmp_redirect(analyzer::Analyzer* analyzer, Connection* c, Val* icmp, AddrVal* tgt, AddrVal* dest, Val* options)
	{
	// Note that it is intentional that here we do not
	// check if ::icmp_redirect is NULL, which should happen *before*
	// BifEvent::generate_icmp_redirect is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(icmp);
	vl->append(tgt);
	vl->append(dest);
	vl->append(options);

	mgr.QueueEvent(::icmp_redirect, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation

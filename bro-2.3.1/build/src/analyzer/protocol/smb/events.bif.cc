// This file was automatically generated by bifcl from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/events.bif (plugin mode).


#include "events.bif.h"

EventHandlerPtr smb_message; 
void BifEvent::generate_smb_message(analyzer::Analyzer* analyzer, Connection* c, Val* hdr, int is_orig, StringVal* cmd, bro_uint_t body_length, StringVal* body)
	{
	// Note that it is intentional that here we do not
	// check if ::smb_message is NULL, which should happen *before*
	// BifEvent::generate_smb_message is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(hdr);
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(cmd);
	vl->append(new Val(body_length, TYPE_COUNT));
	vl->append(body);

	mgr.QueueEvent(::smb_message, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr smb_com_tree_connect_andx; 
void BifEvent::generate_smb_com_tree_connect_andx(analyzer::Analyzer* analyzer, Connection* c, Val* hdr, StringVal* path, StringVal* service)
	{
	// Note that it is intentional that here we do not
	// check if ::smb_com_tree_connect_andx is NULL, which should happen *before*
	// BifEvent::generate_smb_com_tree_connect_andx is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(hdr);
	vl->append(path);
	vl->append(service);

	mgr.QueueEvent(::smb_com_tree_connect_andx, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr smb_com_tree_disconnect; 
void BifEvent::generate_smb_com_tree_disconnect(analyzer::Analyzer* analyzer, Connection* c, Val* hdr)
	{
	// Note that it is intentional that here we do not
	// check if ::smb_com_tree_disconnect is NULL, which should happen *before*
	// BifEvent::generate_smb_com_tree_disconnect is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(hdr);

	mgr.QueueEvent(::smb_com_tree_disconnect, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr smb_com_nt_create_andx; 
void BifEvent::generate_smb_com_nt_create_andx(analyzer::Analyzer* analyzer, Connection* c, Val* hdr, StringVal* name)
	{
	// Note that it is intentional that here we do not
	// check if ::smb_com_nt_create_andx is NULL, which should happen *before*
	// BifEvent::generate_smb_com_nt_create_andx is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(hdr);
	vl->append(name);

	mgr.QueueEvent(::smb_com_nt_create_andx, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr smb_com_transaction; 
void BifEvent::generate_smb_com_transaction(analyzer::Analyzer* analyzer, Connection* c, Val* hdr, Val* trans, Val* data, int is_orig)
	{
	// Note that it is intentional that here we do not
	// check if ::smb_com_transaction is NULL, which should happen *before*
	// BifEvent::generate_smb_com_transaction is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(hdr);
	vl->append(trans);
	vl->append(data);
	vl->append(new Val(is_orig, TYPE_BOOL));

	mgr.QueueEvent(::smb_com_transaction, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr smb_com_transaction2; 
void BifEvent::generate_smb_com_transaction2(analyzer::Analyzer* analyzer, Connection* c, Val* hdr, Val* trans, Val* data, int is_orig)
	{
	// Note that it is intentional that here we do not
	// check if ::smb_com_transaction2 is NULL, which should happen *before*
	// BifEvent::generate_smb_com_transaction2 is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(hdr);
	vl->append(trans);
	vl->append(data);
	vl->append(new Val(is_orig, TYPE_BOOL));

	mgr.QueueEvent(::smb_com_transaction2, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr smb_com_trans_mailslot; 
void BifEvent::generate_smb_com_trans_mailslot(analyzer::Analyzer* analyzer, Connection* c, Val* hdr, Val* trans, Val* data, int is_orig)
	{
	// Note that it is intentional that here we do not
	// check if ::smb_com_trans_mailslot is NULL, which should happen *before*
	// BifEvent::generate_smb_com_trans_mailslot is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(hdr);
	vl->append(trans);
	vl->append(data);
	vl->append(new Val(is_orig, TYPE_BOOL));

	mgr.QueueEvent(::smb_com_trans_mailslot, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr smb_com_trans_rap; 
void BifEvent::generate_smb_com_trans_rap(analyzer::Analyzer* analyzer, Connection* c, Val* hdr, Val* trans, Val* data, int is_orig)
	{
	// Note that it is intentional that here we do not
	// check if ::smb_com_trans_rap is NULL, which should happen *before*
	// BifEvent::generate_smb_com_trans_rap is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(hdr);
	vl->append(trans);
	vl->append(data);
	vl->append(new Val(is_orig, TYPE_BOOL));

	mgr.QueueEvent(::smb_com_trans_rap, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr smb_com_trans_pipe; 
void BifEvent::generate_smb_com_trans_pipe(analyzer::Analyzer* analyzer, Connection* c, Val* hdr, Val* trans, Val* data, int is_orig)
	{
	// Note that it is intentional that here we do not
	// check if ::smb_com_trans_pipe is NULL, which should happen *before*
	// BifEvent::generate_smb_com_trans_pipe is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(hdr);
	vl->append(trans);
	vl->append(data);
	vl->append(new Val(is_orig, TYPE_BOOL));

	mgr.QueueEvent(::smb_com_trans_pipe, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr smb_com_read_andx; 
void BifEvent::generate_smb_com_read_andx(analyzer::Analyzer* analyzer, Connection* c, Val* hdr, StringVal* data)
	{
	// Note that it is intentional that here we do not
	// check if ::smb_com_read_andx is NULL, which should happen *before*
	// BifEvent::generate_smb_com_read_andx is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(hdr);
	vl->append(data);

	mgr.QueueEvent(::smb_com_read_andx, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr smb_com_write_andx; 
void BifEvent::generate_smb_com_write_andx(analyzer::Analyzer* analyzer, Connection* c, Val* hdr, StringVal* data)
	{
	// Note that it is intentional that here we do not
	// check if ::smb_com_write_andx is NULL, which should happen *before*
	// BifEvent::generate_smb_com_write_andx is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(hdr);
	vl->append(data);

	mgr.QueueEvent(::smb_com_write_andx, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr smb_get_dfs_referral; 
void BifEvent::generate_smb_get_dfs_referral(analyzer::Analyzer* analyzer, Connection* c, Val* hdr, bro_uint_t max_referral_level, StringVal* file_name)
	{
	// Note that it is intentional that here we do not
	// check if ::smb_get_dfs_referral is NULL, which should happen *before*
	// BifEvent::generate_smb_get_dfs_referral is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(hdr);
	vl->append(new Val(max_referral_level, TYPE_COUNT));
	vl->append(file_name);

	mgr.QueueEvent(::smb_get_dfs_referral, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr smb_com_negotiate; 
void BifEvent::generate_smb_com_negotiate(analyzer::Analyzer* analyzer, Connection* c, Val* hdr)
	{
	// Note that it is intentional that here we do not
	// check if ::smb_com_negotiate is NULL, which should happen *before*
	// BifEvent::generate_smb_com_negotiate is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(hdr);

	mgr.QueueEvent(::smb_com_negotiate, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr smb_com_negotiate_response; 
void BifEvent::generate_smb_com_negotiate_response(analyzer::Analyzer* analyzer, Connection* c, Val* hdr, bro_uint_t dialect_index)
	{
	// Note that it is intentional that here we do not
	// check if ::smb_com_negotiate_response is NULL, which should happen *before*
	// BifEvent::generate_smb_com_negotiate_response is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(hdr);
	vl->append(new Val(dialect_index, TYPE_COUNT));

	mgr.QueueEvent(::smb_com_negotiate_response, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr smb_com_setup_andx; 
void BifEvent::generate_smb_com_setup_andx(analyzer::Analyzer* analyzer, Connection* c, Val* hdr)
	{
	// Note that it is intentional that here we do not
	// check if ::smb_com_setup_andx is NULL, which should happen *before*
	// BifEvent::generate_smb_com_setup_andx is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(hdr);

	mgr.QueueEvent(::smb_com_setup_andx, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr smb_com_generic_andx; 
void BifEvent::generate_smb_com_generic_andx(analyzer::Analyzer* analyzer, Connection* c, Val* hdr)
	{
	// Note that it is intentional that here we do not
	// check if ::smb_com_generic_andx is NULL, which should happen *before*
	// BifEvent::generate_smb_com_generic_andx is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(hdr);

	mgr.QueueEvent(::smb_com_generic_andx, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr smb_com_close; 
void BifEvent::generate_smb_com_close(analyzer::Analyzer* analyzer, Connection* c, Val* hdr)
	{
	// Note that it is intentional that here we do not
	// check if ::smb_com_close is NULL, which should happen *before*
	// BifEvent::generate_smb_com_close is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(hdr);

	mgr.QueueEvent(::smb_com_close, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr smb_com_logoff_andx; 
void BifEvent::generate_smb_com_logoff_andx(analyzer::Analyzer* analyzer, Connection* c, Val* hdr)
	{
	// Note that it is intentional that here we do not
	// check if ::smb_com_logoff_andx is NULL, which should happen *before*
	// BifEvent::generate_smb_com_logoff_andx is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(hdr);

	mgr.QueueEvent(::smb_com_logoff_andx, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr smb_error; 
void BifEvent::generate_smb_error(analyzer::Analyzer* analyzer, Connection* c, Val* hdr, bro_uint_t cmd, StringVal* cmd_str, StringVal* data)
	{
	// Note that it is intentional that here we do not
	// check if ::smb_error is NULL, which should happen *before*
	// BifEvent::generate_smb_error is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(hdr);
	vl->append(new Val(cmd, TYPE_COUNT));
	vl->append(cmd_str);
	vl->append(data);

	mgr.QueueEvent(::smb_error, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation

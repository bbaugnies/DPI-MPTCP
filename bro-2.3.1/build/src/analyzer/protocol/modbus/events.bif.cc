// This file was automatically generated by bifcl from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/events.bif (plugin mode).


#include "events.bif.h"

EventHandlerPtr modbus_message; 
void BifEvent::generate_modbus_message(analyzer::Analyzer* analyzer, Connection* c, Val* headers, int is_orig)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_message is NULL, which should happen *before*
	// BifEvent::generate_modbus_message is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);
	vl->append(new Val(is_orig, TYPE_BOOL));

	mgr.QueueEvent(::modbus_message, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr modbus_exception; 
void BifEvent::generate_modbus_exception(analyzer::Analyzer* analyzer, Connection* c, Val* headers, bro_uint_t code)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_exception is NULL, which should happen *before*
	// BifEvent::generate_modbus_exception is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);
	vl->append(new Val(code, TYPE_COUNT));

	mgr.QueueEvent(::modbus_exception, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr modbus_read_coils_request; 
void BifEvent::generate_modbus_read_coils_request(analyzer::Analyzer* analyzer, Connection* c, Val* headers, bro_uint_t start_address, bro_uint_t quantity)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_read_coils_request is NULL, which should happen *before*
	// BifEvent::generate_modbus_read_coils_request is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);
	vl->append(new Val(start_address, TYPE_COUNT));
	vl->append(new Val(quantity, TYPE_COUNT));

	mgr.QueueEvent(::modbus_read_coils_request, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr modbus_read_coils_response; 
void BifEvent::generate_modbus_read_coils_response(analyzer::Analyzer* analyzer, Connection* c, Val* headers, Val* coils)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_read_coils_response is NULL, which should happen *before*
	// BifEvent::generate_modbus_read_coils_response is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);
	vl->append(coils);

	mgr.QueueEvent(::modbus_read_coils_response, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr modbus_read_discrete_inputs_request; 
void BifEvent::generate_modbus_read_discrete_inputs_request(analyzer::Analyzer* analyzer, Connection* c, Val* headers, bro_uint_t start_address, bro_uint_t quantity)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_read_discrete_inputs_request is NULL, which should happen *before*
	// BifEvent::generate_modbus_read_discrete_inputs_request is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);
	vl->append(new Val(start_address, TYPE_COUNT));
	vl->append(new Val(quantity, TYPE_COUNT));

	mgr.QueueEvent(::modbus_read_discrete_inputs_request, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr modbus_read_discrete_inputs_response; 
void BifEvent::generate_modbus_read_discrete_inputs_response(analyzer::Analyzer* analyzer, Connection* c, Val* headers, Val* coils)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_read_discrete_inputs_response is NULL, which should happen *before*
	// BifEvent::generate_modbus_read_discrete_inputs_response is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);
	vl->append(coils);

	mgr.QueueEvent(::modbus_read_discrete_inputs_response, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr modbus_read_holding_registers_request; 
void BifEvent::generate_modbus_read_holding_registers_request(analyzer::Analyzer* analyzer, Connection* c, Val* headers, bro_uint_t start_address, bro_uint_t quantity)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_read_holding_registers_request is NULL, which should happen *before*
	// BifEvent::generate_modbus_read_holding_registers_request is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);
	vl->append(new Val(start_address, TYPE_COUNT));
	vl->append(new Val(quantity, TYPE_COUNT));

	mgr.QueueEvent(::modbus_read_holding_registers_request, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr modbus_read_holding_registers_response; 
void BifEvent::generate_modbus_read_holding_registers_response(analyzer::Analyzer* analyzer, Connection* c, Val* headers, Val* registers)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_read_holding_registers_response is NULL, which should happen *before*
	// BifEvent::generate_modbus_read_holding_registers_response is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);
	vl->append(registers);

	mgr.QueueEvent(::modbus_read_holding_registers_response, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr modbus_read_input_registers_request; 
void BifEvent::generate_modbus_read_input_registers_request(analyzer::Analyzer* analyzer, Connection* c, Val* headers, bro_uint_t start_address, bro_uint_t quantity)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_read_input_registers_request is NULL, which should happen *before*
	// BifEvent::generate_modbus_read_input_registers_request is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);
	vl->append(new Val(start_address, TYPE_COUNT));
	vl->append(new Val(quantity, TYPE_COUNT));

	mgr.QueueEvent(::modbus_read_input_registers_request, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr modbus_read_input_registers_response; 
void BifEvent::generate_modbus_read_input_registers_response(analyzer::Analyzer* analyzer, Connection* c, Val* headers, Val* registers)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_read_input_registers_response is NULL, which should happen *before*
	// BifEvent::generate_modbus_read_input_registers_response is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);
	vl->append(registers);

	mgr.QueueEvent(::modbus_read_input_registers_response, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr modbus_write_single_coil_request; 
void BifEvent::generate_modbus_write_single_coil_request(analyzer::Analyzer* analyzer, Connection* c, Val* headers, bro_uint_t address, int value)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_write_single_coil_request is NULL, which should happen *before*
	// BifEvent::generate_modbus_write_single_coil_request is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);
	vl->append(new Val(address, TYPE_COUNT));
	vl->append(new Val(value, TYPE_BOOL));

	mgr.QueueEvent(::modbus_write_single_coil_request, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr modbus_write_single_coil_response; 
void BifEvent::generate_modbus_write_single_coil_response(analyzer::Analyzer* analyzer, Connection* c, Val* headers, bro_uint_t address, int value)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_write_single_coil_response is NULL, which should happen *before*
	// BifEvent::generate_modbus_write_single_coil_response is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);
	vl->append(new Val(address, TYPE_COUNT));
	vl->append(new Val(value, TYPE_BOOL));

	mgr.QueueEvent(::modbus_write_single_coil_response, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr modbus_write_single_register_request; 
void BifEvent::generate_modbus_write_single_register_request(analyzer::Analyzer* analyzer, Connection* c, Val* headers, bro_uint_t address, bro_uint_t value)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_write_single_register_request is NULL, which should happen *before*
	// BifEvent::generate_modbus_write_single_register_request is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);
	vl->append(new Val(address, TYPE_COUNT));
	vl->append(new Val(value, TYPE_COUNT));

	mgr.QueueEvent(::modbus_write_single_register_request, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr modbus_write_single_register_response; 
void BifEvent::generate_modbus_write_single_register_response(analyzer::Analyzer* analyzer, Connection* c, Val* headers, bro_uint_t address, bro_uint_t value)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_write_single_register_response is NULL, which should happen *before*
	// BifEvent::generate_modbus_write_single_register_response is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);
	vl->append(new Val(address, TYPE_COUNT));
	vl->append(new Val(value, TYPE_COUNT));

	mgr.QueueEvent(::modbus_write_single_register_response, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr modbus_write_multiple_coils_request; 
void BifEvent::generate_modbus_write_multiple_coils_request(analyzer::Analyzer* analyzer, Connection* c, Val* headers, bro_uint_t start_address, Val* coils)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_write_multiple_coils_request is NULL, which should happen *before*
	// BifEvent::generate_modbus_write_multiple_coils_request is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);
	vl->append(new Val(start_address, TYPE_COUNT));
	vl->append(coils);

	mgr.QueueEvent(::modbus_write_multiple_coils_request, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr modbus_write_multiple_coils_response; 
void BifEvent::generate_modbus_write_multiple_coils_response(analyzer::Analyzer* analyzer, Connection* c, Val* headers, bro_uint_t start_address, bro_uint_t quantity)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_write_multiple_coils_response is NULL, which should happen *before*
	// BifEvent::generate_modbus_write_multiple_coils_response is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);
	vl->append(new Val(start_address, TYPE_COUNT));
	vl->append(new Val(quantity, TYPE_COUNT));

	mgr.QueueEvent(::modbus_write_multiple_coils_response, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr modbus_write_multiple_registers_request; 
void BifEvent::generate_modbus_write_multiple_registers_request(analyzer::Analyzer* analyzer, Connection* c, Val* headers, bro_uint_t start_address, Val* registers)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_write_multiple_registers_request is NULL, which should happen *before*
	// BifEvent::generate_modbus_write_multiple_registers_request is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);
	vl->append(new Val(start_address, TYPE_COUNT));
	vl->append(registers);

	mgr.QueueEvent(::modbus_write_multiple_registers_request, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr modbus_write_multiple_registers_response; 
void BifEvent::generate_modbus_write_multiple_registers_response(analyzer::Analyzer* analyzer, Connection* c, Val* headers, bro_uint_t start_address, bro_uint_t quantity)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_write_multiple_registers_response is NULL, which should happen *before*
	// BifEvent::generate_modbus_write_multiple_registers_response is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);
	vl->append(new Val(start_address, TYPE_COUNT));
	vl->append(new Val(quantity, TYPE_COUNT));

	mgr.QueueEvent(::modbus_write_multiple_registers_response, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr modbus_read_file_record_request; 
void BifEvent::generate_modbus_read_file_record_request(analyzer::Analyzer* analyzer, Connection* c, Val* headers)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_read_file_record_request is NULL, which should happen *before*
	// BifEvent::generate_modbus_read_file_record_request is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);

	mgr.QueueEvent(::modbus_read_file_record_request, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr modbus_read_file_record_response; 
void BifEvent::generate_modbus_read_file_record_response(analyzer::Analyzer* analyzer, Connection* c, Val* headers)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_read_file_record_response is NULL, which should happen *before*
	// BifEvent::generate_modbus_read_file_record_response is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);

	mgr.QueueEvent(::modbus_read_file_record_response, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr modbus_write_file_record_request; 
void BifEvent::generate_modbus_write_file_record_request(analyzer::Analyzer* analyzer, Connection* c, Val* headers)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_write_file_record_request is NULL, which should happen *before*
	// BifEvent::generate_modbus_write_file_record_request is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);

	mgr.QueueEvent(::modbus_write_file_record_request, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr modbus_write_file_record_response; 
void BifEvent::generate_modbus_write_file_record_response(analyzer::Analyzer* analyzer, Connection* c, Val* headers)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_write_file_record_response is NULL, which should happen *before*
	// BifEvent::generate_modbus_write_file_record_response is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);

	mgr.QueueEvent(::modbus_write_file_record_response, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr modbus_mask_write_register_request; 
void BifEvent::generate_modbus_mask_write_register_request(analyzer::Analyzer* analyzer, Connection* c, Val* headers, bro_uint_t address, bro_uint_t and_mask, bro_uint_t or_mask)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_mask_write_register_request is NULL, which should happen *before*
	// BifEvent::generate_modbus_mask_write_register_request is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);
	vl->append(new Val(address, TYPE_COUNT));
	vl->append(new Val(and_mask, TYPE_COUNT));
	vl->append(new Val(or_mask, TYPE_COUNT));

	mgr.QueueEvent(::modbus_mask_write_register_request, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr modbus_mask_write_register_response; 
void BifEvent::generate_modbus_mask_write_register_response(analyzer::Analyzer* analyzer, Connection* c, Val* headers, bro_uint_t address, bro_uint_t and_mask, bro_uint_t or_mask)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_mask_write_register_response is NULL, which should happen *before*
	// BifEvent::generate_modbus_mask_write_register_response is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);
	vl->append(new Val(address, TYPE_COUNT));
	vl->append(new Val(and_mask, TYPE_COUNT));
	vl->append(new Val(or_mask, TYPE_COUNT));

	mgr.QueueEvent(::modbus_mask_write_register_response, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr modbus_read_write_multiple_registers_request; 
void BifEvent::generate_modbus_read_write_multiple_registers_request(analyzer::Analyzer* analyzer, Connection* c, Val* headers, bro_uint_t read_start_address, bro_uint_t read_quantity, bro_uint_t write_start_address, Val* write_registers)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_read_write_multiple_registers_request is NULL, which should happen *before*
	// BifEvent::generate_modbus_read_write_multiple_registers_request is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);
	vl->append(new Val(read_start_address, TYPE_COUNT));
	vl->append(new Val(read_quantity, TYPE_COUNT));
	vl->append(new Val(write_start_address, TYPE_COUNT));
	vl->append(write_registers);

	mgr.QueueEvent(::modbus_read_write_multiple_registers_request, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr modbus_read_write_multiple_registers_response; 
void BifEvent::generate_modbus_read_write_multiple_registers_response(analyzer::Analyzer* analyzer, Connection* c, Val* headers, Val* written_registers)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_read_write_multiple_registers_response is NULL, which should happen *before*
	// BifEvent::generate_modbus_read_write_multiple_registers_response is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);
	vl->append(written_registers);

	mgr.QueueEvent(::modbus_read_write_multiple_registers_response, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr modbus_read_fifo_queue_request; 
void BifEvent::generate_modbus_read_fifo_queue_request(analyzer::Analyzer* analyzer, Connection* c, Val* headers, bro_uint_t start_address)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_read_fifo_queue_request is NULL, which should happen *before*
	// BifEvent::generate_modbus_read_fifo_queue_request is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);
	vl->append(new Val(start_address, TYPE_COUNT));

	mgr.QueueEvent(::modbus_read_fifo_queue_request, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr modbus_read_fifo_queue_response; 
void BifEvent::generate_modbus_read_fifo_queue_response(analyzer::Analyzer* analyzer, Connection* c, Val* headers, Val* fifos)
	{
	// Note that it is intentional that here we do not
	// check if ::modbus_read_fifo_queue_response is NULL, which should happen *before*
	// BifEvent::generate_modbus_read_fifo_queue_response is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(headers);
	vl->append(fifos);

	mgr.QueueEvent(::modbus_read_fifo_queue_response, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation

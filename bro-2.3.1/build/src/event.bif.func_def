// This file was automatically generated by bifcl from event.bif.

void BifEvent::generate_bro_init(analyzer::Analyzer* analyzer)
	{
	// Note that it is intentional that here we do not
	// check if ::bro_init is NULL, which should happen *before*
	// BifEvent::generate_bro_init is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;


	mgr.QueueEvent(::bro_init, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_bro_done(analyzer::Analyzer* analyzer)
	{
	// Note that it is intentional that here we do not
	// check if ::bro_done is NULL, which should happen *before*
	// BifEvent::generate_bro_done is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;


	mgr.QueueEvent(::bro_done, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_new_connection(analyzer::Analyzer* analyzer, Connection* c)
	{
	// Note that it is intentional that here we do not
	// check if ::new_connection is NULL, which should happen *before*
	// BifEvent::generate_new_connection is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());

	mgr.QueueEvent(::new_connection, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_tunnel_changed(analyzer::Analyzer* analyzer, Connection* c, Val* e)
	{
	// Note that it is intentional that here we do not
	// check if ::tunnel_changed is NULL, which should happen *before*
	// BifEvent::generate_tunnel_changed is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(e);

	mgr.QueueEvent(::tunnel_changed, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_connection_timeout(analyzer::Analyzer* analyzer, Connection* c)
	{
	// Note that it is intentional that here we do not
	// check if ::connection_timeout is NULL, which should happen *before*
	// BifEvent::generate_connection_timeout is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());

	mgr.QueueEvent(::connection_timeout, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_connection_state_remove(analyzer::Analyzer* analyzer, Connection* c)
	{
	// Note that it is intentional that here we do not
	// check if ::connection_state_remove is NULL, which should happen *before*
	// BifEvent::generate_connection_state_remove is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());

	mgr.QueueEvent(::connection_state_remove, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_connection_reused(analyzer::Analyzer* analyzer, Connection* c)
	{
	// Note that it is intentional that here we do not
	// check if ::connection_reused is NULL, which should happen *before*
	// BifEvent::generate_connection_reused is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());

	mgr.QueueEvent(::connection_reused, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_connection_status_update(analyzer::Analyzer* analyzer, Connection* c)
	{
	// Note that it is intentional that here we do not
	// check if ::connection_status_update is NULL, which should happen *before*
	// BifEvent::generate_connection_status_update is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());

	mgr.QueueEvent(::connection_status_update, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_connection_flow_label_changed(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t old_label, bro_uint_t new_label)
	{
	// Note that it is intentional that here we do not
	// check if ::connection_flow_label_changed is NULL, which should happen *before*
	// BifEvent::generate_connection_flow_label_changed is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(old_label, TYPE_COUNT));
	vl->append(new Val(new_label, TYPE_COUNT));

	mgr.QueueEvent(::connection_flow_label_changed, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_connection_external(analyzer::Analyzer* analyzer, Connection* c, StringVal* tag)
	{
	// Note that it is intentional that here we do not
	// check if ::connection_external is NULL, which should happen *before*
	// BifEvent::generate_connection_external is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(tag);

	mgr.QueueEvent(::connection_external, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_udp_session_done(analyzer::Analyzer* analyzer, Connection* u)
	{
	// Note that it is intentional that here we do not
	// check if ::udp_session_done is NULL, which should happen *before*
	// BifEvent::generate_udp_session_done is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(u->BuildConnVal());

	mgr.QueueEvent(::udp_session_done, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, u);
	} // event generation
void BifEvent::generate_scheduled_analyzer_applied(analyzer::Analyzer* analyzer, Connection* c, Val* a)
	{
	// Note that it is intentional that here we do not
	// check if ::scheduled_analyzer_applied is NULL, which should happen *before*
	// BifEvent::generate_scheduled_analyzer_applied is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(a);

	mgr.QueueEvent(::scheduled_analyzer_applied, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_new_packet(analyzer::Analyzer* analyzer, Connection* c, Val* p)
	{
	// Note that it is intentional that here we do not
	// check if ::new_packet is NULL, which should happen *before*
	// BifEvent::generate_new_packet is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(p);

	mgr.QueueEvent(::new_packet, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_ipv6_ext_headers(analyzer::Analyzer* analyzer, Connection* c, Val* p)
	{
	// Note that it is intentional that here we do not
	// check if ::ipv6_ext_headers is NULL, which should happen *before*
	// BifEvent::generate_ipv6_ext_headers is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(p);

	mgr.QueueEvent(::ipv6_ext_headers, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_esp_packet(analyzer::Analyzer* analyzer, Val* p)
	{
	// Note that it is intentional that here we do not
	// check if ::esp_packet is NULL, which should happen *before*
	// BifEvent::generate_esp_packet is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(p);

	mgr.QueueEvent(::esp_packet, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_mobile_ipv6_message(analyzer::Analyzer* analyzer, Val* p)
	{
	// Note that it is intentional that here we do not
	// check if ::mobile_ipv6_message is NULL, which should happen *before*
	// BifEvent::generate_mobile_ipv6_message is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(p);

	mgr.QueueEvent(::mobile_ipv6_message, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_packet_contents(analyzer::Analyzer* analyzer, Connection* c, StringVal* contents)
	{
	// Note that it is intentional that here we do not
	// check if ::packet_contents is NULL, which should happen *before*
	// BifEvent::generate_packet_contents is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(contents);

	mgr.QueueEvent(::packet_contents, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_rexmit_inconsistency(analyzer::Analyzer* analyzer, Connection* c, StringVal* t1, StringVal* t2)
	{
	// Note that it is intentional that here we do not
	// check if ::rexmit_inconsistency is NULL, which should happen *before*
	// BifEvent::generate_rexmit_inconsistency is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(t1);
	vl->append(t2);

	mgr.QueueEvent(::rexmit_inconsistency, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_ack_above_hole(analyzer::Analyzer* analyzer, Connection* c)
	{
	// Note that it is intentional that here we do not
	// check if ::ack_above_hole is NULL, which should happen *before*
	// BifEvent::generate_ack_above_hole is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());

	mgr.QueueEvent(::ack_above_hole, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_content_gap(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t seq, bro_uint_t length)
	{
	// Note that it is intentional that here we do not
	// check if ::content_gap is NULL, which should happen *before*
	// BifEvent::generate_content_gap is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(seq, TYPE_COUNT));
	vl->append(new Val(length, TYPE_COUNT));

	mgr.QueueEvent(::content_gap, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_gap_report(analyzer::Analyzer* analyzer, double dt, Val* info)
	{
	// Note that it is intentional that here we do not
	// check if ::gap_report is NULL, which should happen *before*
	// BifEvent::generate_gap_report is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(new IntervalVal(dt, Seconds));
	vl->append(info);

	mgr.QueueEvent(::gap_report, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_protocol_confirmation(analyzer::Analyzer* analyzer, Connection* c, Val* atype, bro_uint_t aid)
	{
	// Note that it is intentional that here we do not
	// check if ::protocol_confirmation is NULL, which should happen *before*
	// BifEvent::generate_protocol_confirmation is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(atype);
	vl->append(new Val(aid, TYPE_COUNT));

	mgr.QueueEvent(::protocol_confirmation, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_protocol_violation(analyzer::Analyzer* analyzer, Connection* c, Val* atype, bro_uint_t aid, StringVal* reason)
	{
	// Note that it is intentional that here we do not
	// check if ::protocol_violation is NULL, which should happen *before*
	// BifEvent::generate_protocol_violation is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(atype);
	vl->append(new Val(aid, TYPE_COUNT));
	vl->append(reason);

	mgr.QueueEvent(::protocol_violation, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_conn_stats(analyzer::Analyzer* analyzer, Connection* c, Val* os, Val* rs)
	{
	// Note that it is intentional that here we do not
	// check if ::conn_stats is NULL, which should happen *before*
	// BifEvent::generate_conn_stats is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(os);
	vl->append(rs);

	mgr.QueueEvent(::conn_stats, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_conn_weird(analyzer::Analyzer* analyzer, StringVal* name, Connection* c, StringVal* addl)
	{
	// Note that it is intentional that here we do not
	// check if ::conn_weird is NULL, which should happen *before*
	// BifEvent::generate_conn_weird is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(name);
	vl->append(c->BuildConnVal());
	vl->append(addl);

	mgr.QueueEvent(::conn_weird, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_flow_weird(analyzer::Analyzer* analyzer, StringVal* name, AddrVal* src, AddrVal* dst)
	{
	// Note that it is intentional that here we do not
	// check if ::flow_weird is NULL, which should happen *before*
	// BifEvent::generate_flow_weird is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(name);
	vl->append(src);
	vl->append(dst);

	mgr.QueueEvent(::flow_weird, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_net_weird(analyzer::Analyzer* analyzer, StringVal* name)
	{
	// Note that it is intentional that here we do not
	// check if ::net_weird is NULL, which should happen *before*
	// BifEvent::generate_net_weird is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(name);

	mgr.QueueEvent(::net_weird, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_load_sample(analyzer::Analyzer* analyzer, Val* samples, double CPU, bro_int_t dmem)
	{
	// Note that it is intentional that here we do not
	// check if ::load_sample is NULL, which should happen *before*
	// BifEvent::generate_load_sample is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(samples);
	vl->append(new IntervalVal(CPU, Seconds));
	vl->append(new Val(dmem, TYPE_BOOL));

	mgr.QueueEvent(::load_sample, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_signature_match(analyzer::Analyzer* analyzer, Val* state, StringVal* msg, StringVal* data)
	{
	// Note that it is intentional that here we do not
	// check if ::signature_match is NULL, which should happen *before*
	// BifEvent::generate_signature_match is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(state);
	vl->append(msg);
	vl->append(data);

	mgr.QueueEvent(::signature_match, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_software_version_found(analyzer::Analyzer* analyzer, Connection* c, AddrVal* host, Val* s, StringVal* descr)
	{
	// Note that it is intentional that here we do not
	// check if ::software_version_found is NULL, which should happen *before*
	// BifEvent::generate_software_version_found is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(host);
	vl->append(s);
	vl->append(descr);

	mgr.QueueEvent(::software_version_found, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_software_parse_error(analyzer::Analyzer* analyzer, Connection* c, AddrVal* host, StringVal* descr)
	{
	// Note that it is intentional that here we do not
	// check if ::software_parse_error is NULL, which should happen *before*
	// BifEvent::generate_software_parse_error is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(host);
	vl->append(descr);

	mgr.QueueEvent(::software_parse_error, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_software_unparsed_version_found(analyzer::Analyzer* analyzer, Connection* c, AddrVal* host, StringVal* str)
	{
	// Note that it is intentional that here we do not
	// check if ::software_unparsed_version_found is NULL, which should happen *before*
	// BifEvent::generate_software_unparsed_version_found is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(host);
	vl->append(str);

	mgr.QueueEvent(::software_unparsed_version_found, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_OS_version_found(analyzer::Analyzer* analyzer, Connection* c, AddrVal* host, Val* OS)
	{
	// Note that it is intentional that here we do not
	// check if ::OS_version_found is NULL, which should happen *before*
	// BifEvent::generate_OS_version_found is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(host);
	vl->append(OS);

	mgr.QueueEvent(::OS_version_found, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_remote_connection_established(analyzer::Analyzer* analyzer, Val* p)
	{
	// Note that it is intentional that here we do not
	// check if ::remote_connection_established is NULL, which should happen *before*
	// BifEvent::generate_remote_connection_established is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(p);

	mgr.QueueEvent(::remote_connection_established, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_remote_connection_closed(analyzer::Analyzer* analyzer, Val* p)
	{
	// Note that it is intentional that here we do not
	// check if ::remote_connection_closed is NULL, which should happen *before*
	// BifEvent::generate_remote_connection_closed is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(p);

	mgr.QueueEvent(::remote_connection_closed, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_remote_connection_handshake_done(analyzer::Analyzer* analyzer, Val* p)
	{
	// Note that it is intentional that here we do not
	// check if ::remote_connection_handshake_done is NULL, which should happen *before*
	// BifEvent::generate_remote_connection_handshake_done is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(p);

	mgr.QueueEvent(::remote_connection_handshake_done, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_remote_event_registered(analyzer::Analyzer* analyzer, Val* p, StringVal* name)
	{
	// Note that it is intentional that here we do not
	// check if ::remote_event_registered is NULL, which should happen *before*
	// BifEvent::generate_remote_event_registered is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(p);
	vl->append(name);

	mgr.QueueEvent(::remote_event_registered, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_remote_connection_error(analyzer::Analyzer* analyzer, Val* p, StringVal* reason)
	{
	// Note that it is intentional that here we do not
	// check if ::remote_connection_error is NULL, which should happen *before*
	// BifEvent::generate_remote_connection_error is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(p);
	vl->append(reason);

	mgr.QueueEvent(::remote_connection_error, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_remote_capture_filter(analyzer::Analyzer* analyzer, Val* p, StringVal* filter)
	{
	// Note that it is intentional that here we do not
	// check if ::remote_capture_filter is NULL, which should happen *before*
	// BifEvent::generate_remote_capture_filter is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(p);
	vl->append(filter);

	mgr.QueueEvent(::remote_capture_filter, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_finished_send_state(analyzer::Analyzer* analyzer, Val* p)
	{
	// Note that it is intentional that here we do not
	// check if ::finished_send_state is NULL, which should happen *before*
	// BifEvent::generate_finished_send_state is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(p);

	mgr.QueueEvent(::finished_send_state, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_remote_state_inconsistency(analyzer::Analyzer* analyzer, StringVal* operation, StringVal* id, StringVal* expected_old, StringVal* real_old)
	{
	// Note that it is intentional that here we do not
	// check if ::remote_state_inconsistency is NULL, which should happen *before*
	// BifEvent::generate_remote_state_inconsistency is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(operation);
	vl->append(id);
	vl->append(expected_old);
	vl->append(real_old);

	mgr.QueueEvent(::remote_state_inconsistency, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_remote_log(analyzer::Analyzer* analyzer, bro_uint_t level, bro_uint_t src, StringVal* msg)
	{
	// Note that it is intentional that here we do not
	// check if ::remote_log is NULL, which should happen *before*
	// BifEvent::generate_remote_log is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(new Val(level, TYPE_COUNT));
	vl->append(new Val(src, TYPE_COUNT));
	vl->append(msg);

	mgr.QueueEvent(::remote_log, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_remote_log_peer(analyzer::Analyzer* analyzer, Val* p, bro_uint_t level, bro_uint_t src, StringVal* msg)
	{
	// Note that it is intentional that here we do not
	// check if ::remote_log_peer is NULL, which should happen *before*
	// BifEvent::generate_remote_log_peer is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(p);
	vl->append(new Val(level, TYPE_COUNT));
	vl->append(new Val(src, TYPE_COUNT));
	vl->append(msg);

	mgr.QueueEvent(::remote_log_peer, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_remote_pong(analyzer::Analyzer* analyzer, Val* p, bro_uint_t seq, double d1, double d2, double d3)
	{
	// Note that it is intentional that here we do not
	// check if ::remote_pong is NULL, which should happen *before*
	// BifEvent::generate_remote_pong is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(p);
	vl->append(new Val(seq, TYPE_COUNT));
	vl->append(new IntervalVal(d1, Seconds));
	vl->append(new IntervalVal(d2, Seconds));
	vl->append(new IntervalVal(d3, Seconds));

	mgr.QueueEvent(::remote_pong, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_remote_state_access_performed(analyzer::Analyzer* analyzer, StringVal* id, Val* v)
	{
	// Note that it is intentional that here we do not
	// check if ::remote_state_access_performed is NULL, which should happen *before*
	// BifEvent::generate_remote_state_access_performed is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(id);
	vl->append(v);

	mgr.QueueEvent(::remote_state_access_performed, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_profiling_update(analyzer::Analyzer* analyzer, BroFile* f, int expensive)
	{
	// Note that it is intentional that here we do not
	// check if ::profiling_update is NULL, which should happen *before*
	// BifEvent::generate_profiling_update is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(new Val(f));
	vl->append(new Val(expensive, TYPE_BOOL));

	mgr.QueueEvent(::profiling_update, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
 void BifEvent::generate_reporter_info(analyzer::Analyzer* analyzer, double t, StringVal* msg, StringVal* location)
	{
	// Note that it is intentional that here we do not
	// check if ::reporter_info is NULL, which should happen *before*
	// BifEvent::generate_reporter_info is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(new Val(t, TYPE_TIME));
	vl->append(msg);
	vl->append(location);

	mgr.QueueEvent(::reporter_info, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
 void BifEvent::generate_reporter_warning(analyzer::Analyzer* analyzer, double t, StringVal* msg, StringVal* location)
	{
	// Note that it is intentional that here we do not
	// check if ::reporter_warning is NULL, which should happen *before*
	// BifEvent::generate_reporter_warning is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(new Val(t, TYPE_TIME));
	vl->append(msg);
	vl->append(location);

	mgr.QueueEvent(::reporter_warning, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
 void BifEvent::generate_reporter_error(analyzer::Analyzer* analyzer, double t, StringVal* msg, StringVal* location)
	{
	// Note that it is intentional that here we do not
	// check if ::reporter_error is NULL, which should happen *before*
	// BifEvent::generate_reporter_error is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(new Val(t, TYPE_TIME));
	vl->append(msg);
	vl->append(location);

	mgr.QueueEvent(::reporter_error, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_bro_script_loaded(analyzer::Analyzer* analyzer, StringVal* path, bro_uint_t level)
	{
	// Note that it is intentional that here we do not
	// check if ::bro_script_loaded is NULL, which should happen *before*
	// BifEvent::generate_bro_script_loaded is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(path);
	vl->append(new Val(level, TYPE_COUNT));

	mgr.QueueEvent(::bro_script_loaded, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_file_opened(analyzer::Analyzer* analyzer, BroFile* f)
	{
	// Note that it is intentional that here we do not
	// check if ::file_opened is NULL, which should happen *before*
	// BifEvent::generate_file_opened is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(new Val(f));

	mgr.QueueEvent(::file_opened, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_event_queue_flush_point(analyzer::Analyzer* analyzer)
	{
	// Note that it is intentional that here we do not
	// check if ::event_queue_flush_point is NULL, which should happen *before*
	// BifEvent::generate_event_queue_flush_point is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;


	mgr.QueueEvent(::event_queue_flush_point, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_get_file_handle(analyzer::Analyzer* analyzer, Val* tag, Connection* c, int is_orig)
	{
	// Note that it is intentional that here we do not
	// check if ::get_file_handle is NULL, which should happen *before*
	// BifEvent::generate_get_file_handle is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(tag);
	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));

	mgr.QueueEvent(::get_file_handle, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_file_new(analyzer::Analyzer* analyzer, Val* f)
	{
	// Note that it is intentional that here we do not
	// check if ::file_new is NULL, which should happen *before*
	// BifEvent::generate_file_new is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(f);

	mgr.QueueEvent(::file_new, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_file_over_new_connection(analyzer::Analyzer* analyzer, Val* f, Connection* c, int is_orig)
	{
	// Note that it is intentional that here we do not
	// check if ::file_over_new_connection is NULL, which should happen *before*
	// BifEvent::generate_file_over_new_connection is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(f);
	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));

	mgr.QueueEvent(::file_over_new_connection, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_file_timeout(analyzer::Analyzer* analyzer, Val* f)
	{
	// Note that it is intentional that here we do not
	// check if ::file_timeout is NULL, which should happen *before*
	// BifEvent::generate_file_timeout is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(f);

	mgr.QueueEvent(::file_timeout, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_file_gap(analyzer::Analyzer* analyzer, Val* f, bro_uint_t offset, bro_uint_t len)
	{
	// Note that it is intentional that here we do not
	// check if ::file_gap is NULL, which should happen *before*
	// BifEvent::generate_file_gap is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(f);
	vl->append(new Val(offset, TYPE_COUNT));
	vl->append(new Val(len, TYPE_COUNT));

	mgr.QueueEvent(::file_gap, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_file_state_remove(analyzer::Analyzer* analyzer, Val* f)
	{
	// Note that it is intentional that here we do not
	// check if ::file_state_remove is NULL, which should happen *before*
	// BifEvent::generate_file_state_remove is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(f);

	mgr.QueueEvent(::file_state_remove, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_dns_mapping_valid(analyzer::Analyzer* analyzer, Val* dm)
	{
	// Note that it is intentional that here we do not
	// check if ::dns_mapping_valid is NULL, which should happen *before*
	// BifEvent::generate_dns_mapping_valid is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(dm);

	mgr.QueueEvent(::dns_mapping_valid, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_dns_mapping_unverified(analyzer::Analyzer* analyzer, Val* dm)
	{
	// Note that it is intentional that here we do not
	// check if ::dns_mapping_unverified is NULL, which should happen *before*
	// BifEvent::generate_dns_mapping_unverified is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(dm);

	mgr.QueueEvent(::dns_mapping_unverified, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_dns_mapping_new_name(analyzer::Analyzer* analyzer, Val* dm)
	{
	// Note that it is intentional that here we do not
	// check if ::dns_mapping_new_name is NULL, which should happen *before*
	// BifEvent::generate_dns_mapping_new_name is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(dm);

	mgr.QueueEvent(::dns_mapping_new_name, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_dns_mapping_lost_name(analyzer::Analyzer* analyzer, Val* dm)
	{
	// Note that it is intentional that here we do not
	// check if ::dns_mapping_lost_name is NULL, which should happen *before*
	// BifEvent::generate_dns_mapping_lost_name is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(dm);

	mgr.QueueEvent(::dns_mapping_lost_name, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_dns_mapping_altered(analyzer::Analyzer* analyzer, Val* dm, Val* old_addrs, Val* new_addrs)
	{
	// Note that it is intentional that here we do not
	// check if ::dns_mapping_altered is NULL, which should happen *before*
	// BifEvent::generate_dns_mapping_altered is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(dm);
	vl->append(old_addrs);
	vl->append(new_addrs);

	mgr.QueueEvent(::dns_mapping_altered, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_new_event(analyzer::Analyzer* analyzer, StringVal* name, Val* params)
	{
	// Note that it is intentional that here we do not
	// check if ::new_event is NULL, which should happen *before*
	// BifEvent::generate_new_event is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(name);
	vl->append(params);

	mgr.QueueEvent(::new_event, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_root_backdoor_signature_found(analyzer::Analyzer* analyzer, Connection* c)
	{
	// Note that it is intentional that here we do not
	// check if ::root_backdoor_signature_found is NULL, which should happen *before*
	// BifEvent::generate_root_backdoor_signature_found is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());

	mgr.QueueEvent(::root_backdoor_signature_found, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_napster_signature_found(analyzer::Analyzer* analyzer, Connection* c)
	{
	// Note that it is intentional that here we do not
	// check if ::napster_signature_found is NULL, which should happen *before*
	// BifEvent::generate_napster_signature_found is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());

	mgr.QueueEvent(::napster_signature_found, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_kazaa_signature_found(analyzer::Analyzer* analyzer, Connection* c)
	{
	// Note that it is intentional that here we do not
	// check if ::kazaa_signature_found is NULL, which should happen *before*
	// BifEvent::generate_kazaa_signature_found is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());

	mgr.QueueEvent(::kazaa_signature_found, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_gaobot_signature_found(analyzer::Analyzer* analyzer, Connection* c)
	{
	// Note that it is intentional that here we do not
	// check if ::gaobot_signature_found is NULL, which should happen *before*
	// BifEvent::generate_gaobot_signature_found is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());

	mgr.QueueEvent(::gaobot_signature_found, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
void BifEvent::generate_anonymization_mapping(analyzer::Analyzer* analyzer, AddrVal* orig, AddrVal* mapped)
	{
	// Note that it is intentional that here we do not
	// check if ::anonymization_mapping is NULL, which should happen *before*
	// BifEvent::generate_anonymization_mapping is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(orig);
	vl->append(mapped);

	mgr.QueueEvent(::anonymization_mapping, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_rotate_interval(analyzer::Analyzer* analyzer, BroFile* f)
	{
	// Note that it is intentional that here we do not
	// check if ::rotate_interval is NULL, which should happen *before*
	// BifEvent::generate_rotate_interval is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(new Val(f));

	mgr.QueueEvent(::rotate_interval, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_rotate_size(analyzer::Analyzer* analyzer, BroFile* f)
	{
	// Note that it is intentional that here we do not
	// check if ::rotate_size is NULL, which should happen *before*
	// BifEvent::generate_rotate_size is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(new Val(f));

	mgr.QueueEvent(::rotate_size, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation
void BifEvent::generate_print_hook(analyzer::Analyzer* analyzer, BroFile* f, StringVal* s)
	{
	// Note that it is intentional that here we do not
	// check if ::print_hook is NULL, which should happen *before*
	// BifEvent::generate_print_hook is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(new Val(f));
	vl->append(s);

	mgr.QueueEvent(::print_hook, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr);
	} // event generation

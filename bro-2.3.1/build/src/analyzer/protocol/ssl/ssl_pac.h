// This file is automatically generated from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl.pac.

#ifndef _home_benjamin_Bro_bro_2_3_1_src_analyzer_protocol_ssl_ssl_pac_h
#define _home_benjamin_Bro_bro_2_3_1_src_analyzer_protocol_ssl_ssl_pac_h

#include <vector>

#include "binpac.h"


#include "binpac_bro.h"


#include "events.bif.h"


#include <vector>
#include <algorithm>
#include <iostream>
#include <iterator>

#include "util.h"

#include "file_analysis/Manager.h"


#include <string>
using std::string;

#include "events.bif.h"

namespace binpac {

namespace SSL {
class ContextSSL;
class SSL_Conn;
class uint24;
class SSLRecord;
class RecordText;
class PlaintextRecord;
class SSLExtension;
class ServerNameHostName;
class ServerName;
class ServerNameExt;
class EcPointFormats;
class EllipticCurves;
class ProtocolName;
class ApplicationLayerProtocolNegotiationExtension;
enum AnalyzerState {
	STATE_CLEAR,
	STATE_ENCRYPTED,
};
enum HandshakeType {
	HELLO_REQUEST = 0,
	CLIENT_HELLO = 1,
	SERVER_HELLO = 2,
	SESSION_TICKET = 4,
	CERTIFICATE = 11,
	SERVER_KEY_EXCHANGE = 12,
	CERTIFICATE_REQUEST = 13,
	SERVER_HELLO_DONE = 14,
	CERTIFICATE_VERIFY = 15,
	CLIENT_KEY_EXCHANGE = 16,
	FINISHED = 20,
	CERTIFICATE_URL = 21,
	CERTIFICATE_STATUS = 22,
};
class ChangeCipherSpec;
class Alert;
class V2Error;
class ApplicationData;
class Heartbeat;
class HelloRequest;
class ClientHello;
class V2ClientHello;
class ServerHello;
class V2ServerHello;
class X509Certificate;
class Certificate;
class CertificateStatus;
class ServerKeyExchange;
class EcServerKeyExchange;
class DhServerKeyExchange;
class CertificateRequest;
class ServerHelloDone;
class ClientKeyExchange;
class V2ClientMasterKey;
class CertificateVerify;
class Finished;
class SessionTicketHandshake;
class UnknownHandshake;
class Handshake;
class UnknownRecord;
class CiphertextRecord;
class SSLPDU;
class SSL_Flow;
enum ContentType {
	CHANGE_CIPHER_SPEC = 20,
	ALERT = 21,
	HANDSHAKE = 22,
	APPLICATION_DATA = 23,
	HEARTBEAT = 24,
	V2_ERROR = 300,
	V2_CLIENT_HELLO = 301,
	V2_CLIENT_MASTER_KEY = 302,
	V2_SERVER_HELLO = 304,
	UNKNOWN_OR_V2_ENCRYPTED = 400,
};
enum SSLVersions {
	UNKNOWN_VERSION = 0,
	SSLv20 = 2,
	SSLv30 = 768,
	TLSv10 = 769,
	TLSv11 = 770,
	TLSv12 = 771,
};
enum SSLExtensions {
	EXT_SERVER_NAME = 0,
	EXT_MAX_FRAGMENT_LENGTH = 1,
	EXT_CLIENT_CERTIFICATE_URL = 2,
	EXT_TRUSTED_CA_KEYS = 3,
	EXT_TRUNCATED_HMAC = 4,
	EXT_STATUS_REQUEST = 5,
	EXT_USER_MAPPING = 6,
	EXT_CLIENT_AUTHZ = 7,
	EXT_SERVER_AUTHZ = 8,
	EXT_CERT_TYPE = 9,
	EXT_ELLIPTIC_CURVES = 10,
	EXT_EC_POINT_FORMATS = 11,
	EXT_SRP = 12,
	EXT_SIGNATURE_ALGORITHMS = 13,
	EXT_USE_SRTP = 14,
	EXT_HEARTBEAT = 15,
	EXT_APPLICATION_LAYER_PROTOCOL_NEGOTIATION = 16,
	EXT_STATUS_REQUEST_V2 = 17,
	EXT_SIGNED_CERTIFICATE_TIMESTAMP = 18,
	EXT_SESSIONTICKET_TLS = 35,
	EXT_EXTENDED_RANDOM = 40,
	EXT_NEXT_PROTOCOL_NEGOTIATION = 13172,
	EXT_ORIGIN_BOUND_CERTIFICATES = 13175,
	EXT_ENCRYPTED_CLIENT_CERTIFICATES = 13180,
	EXT_CHANNEL_ID = 30031,
	EXT_CHANNEL_ID_NEW = 30032,
	EXT_PADDING = 35655,
	EXT_RENEGOTIATION_INFO = 65281,
};
enum ECCurveType {
	EXPLICIT_PRIME = 1,
	EXPLICIT_CHAR = 2,
	NAMED_CURVE = 3,
};
enum TLSCiphers {
	NO_CHOSEN_CIPHER = 16777215,
	TLS_NULL_WITH_NULL_NULL = 0,
	TLS_RSA_WITH_NULL_MD5 = 1,
	TLS_RSA_WITH_NULL_SHA = 2,
	TLS_RSA_EXPORT_WITH_RC4_40_MD5 = 3,
	TLS_RSA_WITH_RC4_128_MD5 = 4,
	TLS_RSA_WITH_RC4_128_SHA = 5,
	TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = 6,
	TLS_RSA_WITH_IDEA_CBC_SHA = 7,
	TLS_RSA_EXPORT_WITH_DES40_CBC_SHA = 8,
	TLS_RSA_WITH_DES_CBC_SHA = 9,
	TLS_RSA_WITH_3DES_EDE_CBC_SHA = 10,
	TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = 11,
	TLS_DH_DSS_WITH_DES_CBC_SHA = 12,
	TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = 13,
	TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = 14,
	TLS_DH_RSA_WITH_DES_CBC_SHA = 15,
	TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = 16,
	TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = 17,
	TLS_DHE_DSS_WITH_DES_CBC_SHA = 18,
	TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = 19,
	TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = 20,
	TLS_DHE_RSA_WITH_DES_CBC_SHA = 21,
	TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = 22,
	TLS_DH_ANON_EXPORT_WITH_RC4_40_MD5 = 23,
	TLS_DH_ANON_WITH_RC4_128_MD5 = 24,
	TLS_DH_ANON_EXPORT_WITH_DES40_CBC_SHA = 25,
	TLS_DH_ANON_WITH_DES_CBC_SHA = 26,
	TLS_DH_ANON_WITH_3DES_EDE_CBC_SHA = 27,
	TLS_KRB5_WITH_DES_CBC_SHA = 30,
	TLS_KRB5_WITH_3DES_EDE_CBC_SHA = 31,
	TLS_KRB5_WITH_RC4_128_SHA = 32,
	TLS_KRB5_WITH_IDEA_CBC_SHA = 33,
	TLS_KRB5_WITH_DES_CBC_MD5 = 34,
	TLS_KRB5_WITH_3DES_EDE_CBC_MD5 = 35,
	TLS_KRB5_WITH_RC4_128_MD5 = 36,
	TLS_KRB5_WITH_IDEA_CBC_MD5 = 37,
	TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA = 38,
	TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA = 39,
	TLS_KRB5_EXPORT_WITH_RC4_40_SHA = 40,
	TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 = 41,
	TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 = 42,
	TLS_KRB5_EXPORT_WITH_RC4_40_MD5 = 43,
	TLS_RSA_WITH_AES_128_CBC_SHA = 47,
	TLS_DH_DSS_WITH_AES_128_CBC_SHA = 48,
	TLS_DH_RSA_WITH_AES_128_CBC_SHA = 49,
	TLS_DHE_DSS_WITH_AES_128_CBC_SHA = 50,
	TLS_DHE_RSA_WITH_AES_128_CBC_SHA = 51,
	TLS_DH_ANON_WITH_AES_128_CBC_SHA = 52,
	TLS_RSA_WITH_AES_256_CBC_SHA = 53,
	TLS_DH_DSS_WITH_AES_256_CBC_SHA = 54,
	TLS_DH_RSA_WITH_AES_256_CBC_SHA = 55,
	TLS_DHE_DSS_WITH_AES_256_CBC_SHA = 56,
	TLS_DHE_RSA_WITH_AES_256_CBC_SHA = 57,
	TLS_DH_ANON_WITH_AES_256_CBC_SHA = 58,
	TLS_RSA_WITH_NULL_SHA256 = 59,
	TLS_RSA_WITH_AES_128_CBC_SHA256 = 60,
	TLS_RSA_WITH_AES_256_CBC_SHA256 = 61,
	TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = 62,
	TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = 63,
	TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = 64,
	TLS_RSA_WITH_CAMELLIA_128_CBC_SHA = 65,
	TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA = 66,
	TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA = 67,
	TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = 68,
	TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = 69,
	TLS_DH_ANON_WITH_CAMELLIA_128_CBC_SHA = 70,
	TLS_RSA_EXPORT1024_WITH_RC4_56_MD5 = 96,
	TLS_RSA_EXPORT1024_WITH_RC2_CBC_56_MD5 = 97,
	TLS_RSA_EXPORT1024_WITH_DES_CBC_SHA = 98,
	TLS_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA = 99,
	TLS_RSA_EXPORT1024_WITH_RC4_56_SHA = 100,
	TLS_DHE_DSS_EXPORT1024_WITH_RC4_56_SHA = 101,
	TLS_DHE_DSS_WITH_RC4_128_SHA = 102,
	TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = 103,
	TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = 104,
	TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = 105,
	TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = 106,
	TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = 107,
	TLS_DH_ANON_WITH_AES_128_CBC_SHA256 = 108,
	TLS_DH_ANON_WITH_AES_256_CBC_SHA256 = 109,
	TLS_DHE_DSS_WITH_3DES_EDE_CBC_RMD = 114,
	TLS_DHE_DSS_WITH_AES_128_CBC_RMD = 115,
	TLS_DHE_DSS_WITH_AES_256_CBC_RMD = 116,
	TLS_DHE_RSA_WITH_3DES_EDE_CBC_RMD = 119,
	TLS_DHE_RSA_WITH_AES_128_CBC_RMD = 120,
	TLS_DHE_RSA_WITH_AES_256_CBC_RMD = 121,
	TLS_RSA_WITH_3DES_EDE_CBC_RMD = 124,
	TLS_RSA_WITH_AES_128_CBC_RMD = 125,
	TLS_RSA_WITH_AES_256_CBC_RMD = 126,
	TLS_GOSTR341094_WITH_28147_CNT_IMIT = 128,
	TLS_GOSTR341001_WITH_28147_CNT_IMIT = 129,
	TLS_GOSTR341094_WITH_NULL_GOSTR3411 = 130,
	TLS_GOSTR341001_WITH_NULL_GOSTR3411 = 131,
	TLS_RSA_WITH_CAMELLIA_256_CBC_SHA = 132,
	TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA = 133,
	TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA = 134,
	TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = 135,
	TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = 136,
	TLS_DH_ANON_WITH_CAMELLIA_256_CBC_SHA = 137,
	TLS_PSK_WITH_RC4_128_SHA = 138,
	TLS_PSK_WITH_3DES_EDE_CBC_SHA = 139,
	TLS_PSK_WITH_AES_128_CBC_SHA = 140,
	TLS_PSK_WITH_AES_256_CBC_SHA = 141,
	TLS_DHE_PSK_WITH_RC4_128_SHA = 142,
	TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA = 143,
	TLS_DHE_PSK_WITH_AES_128_CBC_SHA = 144,
	TLS_DHE_PSK_WITH_AES_256_CBC_SHA = 145,
	TLS_RSA_PSK_WITH_RC4_128_SHA = 146,
	TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA = 147,
	TLS_RSA_PSK_WITH_AES_128_CBC_SHA = 148,
	TLS_RSA_PSK_WITH_AES_256_CBC_SHA = 149,
	TLS_RSA_WITH_SEED_CBC_SHA = 150,
	TLS_DH_DSS_WITH_SEED_CBC_SHA = 151,
	TLS_DH_RSA_WITH_SEED_CBC_SHA = 152,
	TLS_DHE_DSS_WITH_SEED_CBC_SHA = 153,
	TLS_DHE_RSA_WITH_SEED_CBC_SHA = 154,
	TLS_DH_ANON_WITH_SEED_CBC_SHA = 155,
	TLS_RSA_WITH_AES_128_GCM_SHA256 = 156,
	TLS_RSA_WITH_AES_256_GCM_SHA384 = 157,
	TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = 158,
	TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = 159,
	TLS_DH_RSA_WITH_AES_128_GCM_SHA256 = 160,
	TLS_DH_RSA_WITH_AES_256_GCM_SHA384 = 161,
	TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 = 162,
	TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 = 163,
	TLS_DH_DSS_WITH_AES_128_GCM_SHA256 = 164,
	TLS_DH_DSS_WITH_AES_256_GCM_SHA384 = 165,
	TLS_DH_ANON_WITH_AES_128_GCM_SHA256 = 166,
	TLS_DH_ANON_WITH_AES_256_GCM_SHA384 = 167,
	TLS_PSK_WITH_AES_128_GCM_SHA256 = 168,
	TLS_PSK_WITH_AES_256_GCM_SHA384 = 169,
	TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 = 170,
	TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 = 171,
	TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 = 172,
	TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 = 173,
	TLS_PSK_WITH_AES_128_CBC_SHA256 = 174,
	TLS_PSK_WITH_AES_256_CBC_SHA384 = 175,
	TLS_PSK_WITH_NULL_SHA256 = 176,
	TLS_PSK_WITH_NULL_SHA384 = 177,
	TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 = 178,
	TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 = 179,
	TLS_DHE_PSK_WITH_NULL_SHA256 = 180,
	TLS_DHE_PSK_WITH_NULL_SHA384 = 181,
	TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 = 182,
	TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 = 183,
	TLS_RSA_PSK_WITH_NULL_SHA256 = 184,
	TLS_RSA_PSK_WITH_NULL_SHA384 = 185,
	TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 186,
	TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 = 187,
	TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 188,
	TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 = 189,
	TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 190,
	TLS_DH_ANON_WITH_CAMELLIA_128_CBC_SHA256 = 191,
	TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 = 192,
	TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 = 193,
	TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 = 194,
	TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 = 195,
	TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = 196,
	TLS_DH_ANON_WITH_CAMELLIA_256_CBC_SHA256 = 197,
	TLS_FALLBACK_SCSV = 22016,
	TLS_ECDH_ECDSA_WITH_NULL_SHA = 49153,
	TLS_ECDH_ECDSA_WITH_RC4_128_SHA = 49154,
	TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = 49155,
	TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = 49156,
	TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = 49157,
	TLS_ECDHE_ECDSA_WITH_NULL_SHA = 49158,
	TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = 49159,
	TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = 49160,
	TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = 49161,
	TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = 49162,
	TLS_ECDH_RSA_WITH_NULL_SHA = 49163,
	TLS_ECDH_RSA_WITH_RC4_128_SHA = 49164,
	TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = 49165,
	TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = 49166,
	TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = 49167,
	TLS_ECDHE_RSA_WITH_NULL_SHA = 49168,
	TLS_ECDHE_RSA_WITH_RC4_128_SHA = 49169,
	TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = 49170,
	TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = 49171,
	TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = 49172,
	TLS_ECDH_ANON_WITH_NULL_SHA = 49173,
	TLS_ECDH_ANON_WITH_RC4_128_SHA = 49174,
	TLS_ECDH_ANON_WITH_3DES_EDE_CBC_SHA = 49175,
	TLS_ECDH_ANON_WITH_AES_128_CBC_SHA = 49176,
	TLS_ECDH_ANON_WITH_AES_256_CBC_SHA = 49177,
	TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA = 49178,
	TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = 49179,
	TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = 49180,
	TLS_SRP_SHA_WITH_AES_128_CBC_SHA = 49181,
	TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = 49182,
	TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = 49183,
	TLS_SRP_SHA_WITH_AES_256_CBC_SHA = 49184,
	TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = 49185,
	TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = 49186,
	TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = 49187,
	TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = 49188,
	TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = 49189,
	TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = 49190,
	TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = 49191,
	TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = 49192,
	TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = 49193,
	TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = 49194,
	TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = 49195,
	TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = 49196,
	TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = 49197,
	TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = 49198,
	TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = 49199,
	TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = 49200,
	TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = 49201,
	TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = 49202,
	TLS_ECDHE_PSK_WITH_RC4_128_SHA = 49203,
	TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA = 49204,
	TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA = 49205,
	TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA = 49206,
	TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 = 49207,
	TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 = 49208,
	TLS_ECDHE_PSK_WITH_NULL_SHA = 49209,
	TLS_ECDHE_PSK_WITH_NULL_SHA256 = 49210,
	TLS_ECDHE_PSK_WITH_NULL_SHA384 = 49211,
	TLS_RSA_WITH_ARIA_128_CBC_SHA256 = 49212,
	TLS_RSA_WITH_ARIA_256_CBC_SHA384 = 49213,
	TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256 = 49214,
	TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384 = 49215,
	TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256 = 49216,
	TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384 = 49217,
	TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256 = 49218,
	TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384 = 49219,
	TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256 = 49220,
	TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384 = 49221,
	TLS_DH_ANON_WITH_ARIA_128_CBC_SHA256 = 49222,
	TLS_DH_ANON_WITH_ARIA_256_CBC_SHA384 = 49223,
	TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256 = 49224,
	TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384 = 49225,
	TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256 = 49226,
	TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384 = 49227,
	TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256 = 49228,
	TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384 = 49229,
	TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256 = 49230,
	TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384 = 49231,
	TLS_RSA_WITH_ARIA_128_GCM_SHA256 = 49232,
	TLS_RSA_WITH_ARIA_256_GCM_SHA384 = 49233,
	TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256 = 49234,
	TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384 = 49235,
	TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256 = 49236,
	TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384 = 49237,
	TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256 = 49238,
	TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384 = 49239,
	TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256 = 49240,
	TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384 = 49241,
	TLS_DH_ANON_WITH_ARIA_128_GCM_SHA256 = 49242,
	TLS_DH_ANON_WITH_ARIA_256_GCM_SHA384 = 49243,
	TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 = 49244,
	TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 = 49245,
	TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 = 49246,
	TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 = 49247,
	TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 = 49248,
	TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 = 49249,
	TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 = 49250,
	TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 = 49251,
	TLS_PSK_WITH_ARIA_128_CBC_SHA256 = 49252,
	TLS_PSK_WITH_ARIA_256_CBC_SHA384 = 49253,
	TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256 = 49254,
	TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384 = 49255,
	TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256 = 49256,
	TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384 = 49257,
	TLS_PSK_WITH_ARIA_128_GCM_SHA256 = 49258,
	TLS_PSK_WITH_ARIA_256_GCM_SHA384 = 49259,
	TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256 = 49260,
	TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384 = 49261,
	TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256 = 49262,
	TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384 = 49263,
	TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256 = 49264,
	TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384 = 49265,
	TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = 49266,
	TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = 49267,
	TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = 49268,
	TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = 49269,
	TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 49270,
	TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 = 49271,
	TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 49272,
	TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 = 49273,
	TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 49274,
	TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 49275,
	TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 49276,
	TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 49277,
	TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 49278,
	TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 49279,
	TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256 = 49280,
	TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384 = 49281,
	TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 = 49282,
	TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 = 49283,
	TLS_DH_ANON_WITH_CAMELLIA_128_GCM_SHA256 = 49284,
	TLS_DH_ANON_WITH_CAMELLIA_256_GCM_SHA384 = 49285,
	TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = 49286,
	TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = 49287,
	TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = 49288,
	TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = 49289,
	TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 49290,
	TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 49291,
	TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 49292,
	TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 49293,
	TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 = 49294,
	TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 = 49295,
	TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256 = 49296,
	TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384 = 49297,
	TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 = 49298,
	TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 = 49299,
	TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 = 49300,
	TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 = 49301,
	TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = 49302,
	TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = 49303,
	TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 = 49304,
	TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 = 49305,
	TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = 49306,
	TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = 49307,
	TLS_RSA_WITH_AES_128_CCM = 49308,
	TLS_RSA_WITH_AES_256_CCM = 49309,
	TLS_DHE_RSA_WITH_AES_128_CCM = 49310,
	TLS_DHE_RSA_WITH_AES_256_CCM = 49311,
	TLS_RSA_WITH_AES_128_CCM_8 = 49312,
	TLS_RSA_WITH_AES_256_CCM_8 = 49313,
	TLS_DHE_RSA_WITH_AES_128_CCM_8 = 49314,
	TLS_DHE_RSA_WITH_AES_256_CCM_8 = 49315,
	TLS_PSK_WITH_AES_128_CCM = 49316,
	TLS_PSK_WITH_AES_256_CCM = 49317,
	TLS_DHE_PSK_WITH_AES_128_CCM = 49318,
	TLS_DHE_PSK_WITH_AES_256_CCM = 49319,
	TLS_PSK_WITH_AES_128_CCM_8 = 49320,
	TLS_PSK_WITH_AES_256_CCM_8 = 49321,
	TLS_PSK_DHE_WITH_AES_128_CCM_8 = 49322,
	TLS_PSK_DHE_WITH_AES_256_CCM_8 = 49323,
	TLS_ECDHE_ECDSA_WITH_AES_128_CCM = 49324,
	TLS_ECDHE_ECDSA_WITH_AES_256_CCM = 49325,
	TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 = 49326,
	TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 = 49327,
	TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = 52243,
	TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = 52244,
	TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = 52245,
};
} // namespace SSL

int bytestring_to_int(const_bytestring const & s, int base);
double bytestring_to_double(const_bytestring const & s);
int bytestring_casecmp(const_bytestring const & s1, const_charptr const & s2);
bool bytestring_caseprefix(const_bytestring const & s1, const_charptr const & s2);
double network_time();
namespace SSL {

class ContextSSL
{
public:
	ContextSSL(SSL_Conn * connection, SSL_Flow * flow, FlowBuffer * flow_buffer);
	~ContextSSL();
	
	// Member access functions
	SSL_Conn * connection() const { return connection_; }
	SSL_Flow * flow() const { return flow_; }
	FlowBuffer * flow_buffer() const { return flow_buffer_; }
	
protected:
	SSL_Conn * connection_;
	SSL_Flow * flow_;
	FlowBuffer * flow_buffer_;
};


class SSL_Conn : public binpac::ConnectionAnalyzer
{
public:
	SSL_Conn(BroAnalyzer const & bro_analyzer);
	~SSL_Conn();
	
	// Member access functions
	SSL_Flow * upflow() const { return upflow_; }
	SSL_Flow * downflow() const { return downflow_; }
	BroAnalyzer const & bro_analyzer() const { return bro_analyzer_; }
	
	void NewData(bool is_orig, const_byteptr begin, const_byteptr end);
	void NewGap(bool is_orig, int gap_length);
	void FlowEOF(bool is_orig);
	
	// Functions
	int chosen_cipher();
	bool set_cipher(uint32 cipher);
	int determine_ssl_record_layer(uint8 head0, uint8 head1, uint8 head2, uint8 head3, uint8 head4);
	int client_state();
	int server_state();
	int state(bool is_orig);
	bool startEncryption(bool is_orig);
	bool proc_alert(SSLRecord * rec, int level, int desc);
	bool proc_client_hello(SSLRecord * rec, uint16 version, double ts, bytestring const & client_random, vector<uint8> * session_id, vector<uint16> * cipher_suites16, vector<uint24 *> * cipher_suites24);
	bool proc_server_hello(SSLRecord * rec, uint16 version, double ts, bytestring const & server_random, vector<uint8> * session_id, vector<uint16> * cipher_suites16, vector<uint24 *> * cipher_suites24, uint8 comp_method);
	bool proc_session_ticket_handshake(SessionTicketHandshake * rec, bool is_orig);
	bool proc_ssl_extension(SSLRecord * rec, int type, const_bytestring const & sourcedata);
	bool proc_ec_point_formats(SSLRecord * rec, vector<uint8> * point_format_list);
	bool proc_elliptic_curves(SSLRecord * rec, vector<uint16> * list);
	bool proc_apnl(SSLRecord * rec, vector<ProtocolName *> * protocols);
	bool proc_server_name(SSLRecord * rec, vector<ServerName *> * list);
	bool proc_certificate(SSLRecord * rec, vector<bytestring> * certificates);
	bool proc_v2_certificate(SSLRecord * rec, bytestring const & cert);
	bool proc_v3_certificate(SSLRecord * rec, vector<X509Certificate *> * cl);
	bool proc_v2_client_master_key(SSLRecord * rec, int cipher_kind);
	bool proc_unknown_handshake(Handshake * hs, bool is_orig);
	bool proc_unknown_record(SSLRecord * rec);
	bool proc_ciphertext_record(SSLRecord * rec);
	bool proc_heartbeat(SSLRecord * rec, uint8 type, uint16 payload_length, bytestring const & data);
	bool proc_check_v2_server_hello_version(uint16 version);
	bool proc_certificate_status(SSLRecord * rec, uint8 status_type, bytestring const & response);
	bool proc_ec_server_key_exchange(SSLRecord * rec, uint8 curve_type, uint16 curve);
	bool proc_dh_server_key_exchange(SSLRecord * rec, bytestring const & p, bytestring const & g, bytestring const & Ys);
	bool proc_ccs(SSLRecord * rec);
	bool proc_handshake(SSLRecord * rec, uint8 msg_type, uint24 * length);
	
protected:
	
	// Additional members

		int client_state_;
		int server_state_;
		int record_layer_version_;
		uint32 chosen_cipher_;
	

		int established_;
	
	SSL_Flow * upflow_;
	SSL_Flow * downflow_;
	BroAnalyzer bro_analyzer_;
};


class uint24
{
public:
	uint24();
	~uint24();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 byte1() const { return byte1_; }
	uint8 byte2() const { return byte2_; }
	uint8 byte3() const { return byte3_; }
	
protected:
	uint8 byte1_;
	uint8 byte2_;
	uint8 byte3_;
};


	class to_int {
	public:
		int operator()(uint24 * num) const
		{
		return (num->byte1() << 16) | (num->byte2() << 8) | num->byte3();
		}
	};

	string state_label(int state_nr);


class SSLRecord
{
public:
	SSLRecord(bool is_orig);
	~SSLRecord();
	int initial_buffer_length() const { return 5; }
	bool ParseBuffer(flow_buffer_t t_flow_buffer, ContextSSL * t_context);
	
	// Member access functions
	uint8 head0() const { return head0_; }
	uint8 head1() const { return head1_; }
	uint8 head2() const { return head2_; }
	uint8 head3() const { return head3_; }
	uint8 head4() const { return head4_; }
	vector<RecordText *> * rec() const { return rec_; }
	bool is_orig() const { return is_orig_; }
	int byteorder() const { return byteorder_; }
	int version() const { return version_; }
	int content_type() const { return content_type_; }
	int length() const { return length_; }
	
protected:
	uint8 head0_;
	uint8 head1_;
	uint8 head2_;
	uint8 head3_;
	uint8 head4_;
	vector<RecordText *> * rec_;
	RecordText * rec__elem_;
	bool is_orig_;
	int byteorder_;
	int version_;
	int content_type_;
	int length_;
	int buffering_state_;
};


class RecordText
{
public:
	RecordText(SSLRecord * rec);
	~RecordText();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder);
	
	// Member access functions
	int val_case_index() const	{ return val_case_index_; }
	CiphertextRecord * ciphertext() const
		{
		switch ( val_case_index() )
			{
			case 1:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:56:ciphertext", val_case_index(), "STATE_ENCRYPTED");
				break;
			}
		return ciphertext_;
		}
	PlaintextRecord * plaintext() const
		{
		return plaintext_;
		}
	SSLRecord * rec() const { return rec_; }
	
protected:
	int val_case_index_;
	CiphertextRecord * ciphertext_;
	PlaintextRecord * plaintext_;
	SSLRecord * rec_;
};


class PlaintextRecord
{
public:
	PlaintextRecord(SSLRecord * rec);
	~PlaintextRecord();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder);
	
	// Member access functions
	int val_case_index() const	{ return val_case_index_; }
	ChangeCipherSpec * ch_cipher() const
		{
		switch ( val_case_index() )
			{
			case 20:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:62:ch_cipher", val_case_index(), "CHANGE_CIPHER_SPEC");
				break;
			}
		return ch_cipher_;
		}
	Alert * alert() const
		{
		switch ( val_case_index() )
			{
			case 21:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:63:alert", val_case_index(), "ALERT");
				break;
			}
		return alert_;
		}
	Handshake * handshake() const
		{
		switch ( val_case_index() )
			{
			case 22:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:64:handshake", val_case_index(), "HANDSHAKE");
				break;
			}
		return handshake_;
		}
	Heartbeat * heartbeat() const
		{
		switch ( val_case_index() )
			{
			case 24:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:65:heartbeat", val_case_index(), "HEARTBEAT");
				break;
			}
		return heartbeat_;
		}
	ApplicationData * app_data() const
		{
		switch ( val_case_index() )
			{
			case 23:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:66:app_data", val_case_index(), "APPLICATION_DATA");
				break;
			}
		return app_data_;
		}
	V2Error * v2_error() const
		{
		switch ( val_case_index() )
			{
			case 300:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:67:v2_error", val_case_index(), "V2_ERROR");
				break;
			}
		return v2_error_;
		}
	V2ClientHello * v2_client_hello() const
		{
		switch ( val_case_index() )
			{
			case 301:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:68:v2_client_hello", val_case_index(), "V2_CLIENT_HELLO");
				break;
			}
		return v2_client_hello_;
		}
	V2ClientMasterKey * v2_client_master_key() const
		{
		switch ( val_case_index() )
			{
			case 302:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:69:v2_client_master_key", val_case_index(), "V2_CLIENT_MASTER_KEY");
				break;
			}
		return v2_client_master_key_;
		}
	V2ServerHello * v2_server_hello() const
		{
		switch ( val_case_index() )
			{
			case 304:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:70:v2_server_hello", val_case_index(), "V2_SERVER_HELLO");
				break;
			}
		return v2_server_hello_;
		}
	UnknownRecord * unknown_record() const
		{
		return unknown_record_;
		}
	SSLRecord * rec() const { return rec_; }
	
protected:
	int val_case_index_;
	ChangeCipherSpec * ch_cipher_;
	Alert * alert_;
	Handshake * handshake_;
	Heartbeat * heartbeat_;
	ApplicationData * app_data_;
	V2Error * v2_error_;
	V2ClientHello * v2_client_hello_;
	V2ClientMasterKey * v2_client_master_key_;
	V2ServerHello * v2_server_hello_;
	UnknownRecord * unknown_record_;
	SSLRecord * rec_;
};


class SSLExtension
{
public:
	SSLExtension(SSLRecord * rec);
	~SSLExtension();
	int initial_buffer_length() const { return 4; }
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder);
	
	// Member access functions
	uint16 type() const { return type_; }
	uint16 data_len() const { return data_len_; }
	int ext_case_index() const	{ return ext_case_index_; }
	vector<ApplicationLayerProtocolNegotiationExtension *> * apnl() const
		{
		switch ( ext_case_index() )
			{
			case 16:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:85:apnl", ext_case_index(), "EXT_APPLICATION_LAYER_PROTOCOL_NEGOTIATION");
				break;
			}
		return apnl_;
		}
	vector<EllipticCurves *> * elliptic_curves() const
		{
		switch ( ext_case_index() )
			{
			case 10:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:86:elliptic_curves", ext_case_index(), "EXT_ELLIPTIC_CURVES");
				break;
			}
		return elliptic_curves_;
		}
	vector<EcPointFormats *> * ec_point_formats() const
		{
		switch ( ext_case_index() )
			{
			case 11:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:87:ec_point_formats", ext_case_index(), "EXT_EC_POINT_FORMATS");
				break;
			}
		return ec_point_formats_;
		}
	vector<ServerNameExt *> * server_name() const
		{
		switch ( ext_case_index() )
			{
			case 0:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:89:server_name", ext_case_index(), "EXT_SERVER_NAME");
				break;
			}
		return server_name_;
		}
	bytestring const & data() const
		{
		return data_;
		}
	SSLRecord * rec() const { return rec_; }
	bool proc() const { return proc_; }
	const_bytestring const & sourcedata() const { return sourcedata_; }
	
protected:
	uint16 type_;
	uint16 data_len_;
	int ext_case_index_;
	vector<ApplicationLayerProtocolNegotiationExtension *> * apnl_;
	ApplicationLayerProtocolNegotiationExtension * apnl__elem_;
	vector<EllipticCurves *> * elliptic_curves_;
	EllipticCurves * elliptic_curves__elem_;
	vector<EcPointFormats *> * ec_point_formats_;
	EcPointFormats * ec_point_formats__elem_;
	vector<ServerNameExt *> * server_name_;
	ServerNameExt * server_name__elem_;
	bytestring data_;
	SSLRecord * rec_;
	bool proc_;
	const_bytestring sourcedata_;
};


class ServerNameHostName
{
public:
	ServerNameHostName();
	~ServerNameHostName();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder);
	
	// Member access functions
	uint16 length() const { return length_; }
	bytestring const & host_name() const { return host_name_; }
	
protected:
	uint16 length_;
	bytestring host_name_;
};


class ServerName
{
public:
	ServerName();
	~ServerName();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder);
	
	// Member access functions
	uint8 name_type() const { return name_type_; }
	int name_case_index() const	{ return name_case_index_; }
	ServerNameHostName * host_name() const
		{
		switch ( name_case_index() )
			{
			case 0:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:102:host_name", name_case_index(), "((int) 0)");
				break;
			}
		return host_name_;
		}
	
protected:
	uint8 name_type_;
	int name_case_index_;
	ServerNameHostName * host_name_;
	const_bytestring data_;
};


class ServerNameExt
{
public:
	ServerNameExt(SSLRecord * rec);
	~ServerNameExt();
	int initial_buffer_length() const { return 2; }
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder);
	
	// Member access functions
	uint16 length() const { return length_; }
	vector<ServerName *> * server_names() const { return server_names_; }
	SSLRecord * rec() const { return rec_; }
	bool proc() const { return proc_; }
	
protected:
	uint16 length_;
	vector<ServerName *> * server_names_;
	ServerName * server_names__elem_;
	SSLRecord * rec_;
	bool proc_;
};


class EcPointFormats
{
public:
	EcPointFormats(SSLRecord * rec);
	~EcPointFormats();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context);
	
	// Member access functions
	uint8 length() const { return length_; }
	vector<uint8> * point_format_list() const { return point_format_list_; }
	SSLRecord * rec() const { return rec_; }
	bool proc() const { return proc_; }
	
protected:
	uint8 length_;
	vector<uint8> * point_format_list_;
	uint8 point_format_list__elem_;
	SSLRecord * rec_;
	bool proc_;
};


class EllipticCurves
{
public:
	EllipticCurves(SSLRecord * rec);
	~EllipticCurves();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder);
	
	// Member access functions
	uint16 length() const { return length_; }
	vector<uint16> * elliptic_curve_list() const { return elliptic_curve_list_; }
	SSLRecord * rec() const { return rec_; }
	bool proc() const { return proc_; }
	
protected:
	uint16 length_;
	vector<uint16> * elliptic_curve_list_;
	uint16 elliptic_curve_list__elem_;
	SSLRecord * rec_;
	bool proc_;
};


class ProtocolName
{
public:
	ProtocolName();
	~ProtocolName();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 length() const { return length_; }
	bytestring const & name() const { return name_; }
	
protected:
	uint8 length_;
	bytestring name_;
};


class ApplicationLayerProtocolNegotiationExtension
{
public:
	ApplicationLayerProtocolNegotiationExtension(SSLRecord * rec);
	~ApplicationLayerProtocolNegotiationExtension();
	int initial_buffer_length() const { return 2; }
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder);
	
	// Member access functions
	uint16 length() const { return length_; }
	vector<ProtocolName *> * protocol_name_list() const { return protocol_name_list_; }
	SSLRecord * rec() const { return rec_; }
	bool proc() const { return proc_; }
	
protected:
	uint16 length_;
	vector<ProtocolName *> * protocol_name_list_;
	ProtocolName * protocol_name_list__elem_;
	SSLRecord * rec_;
	bool proc_;
};


class ChangeCipherSpec
{
public:
	ChangeCipherSpec(SSLRecord * rec);
	~ChangeCipherSpec();
	int initial_buffer_length() const { return 0; }
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context);
	
	// Member access functions
	uint8 type() const { return type_; }
	SSLRecord * rec() const { return rec_; }
	bool state_changed() const { return state_changed_; }
	bool proc() const { return proc_; }
	
protected:
	uint8 type_;
	SSLRecord * rec_;
	bool state_changed_;
	bool proc_;
};


class Alert
{
public:
	Alert(SSLRecord * rec);
	~Alert();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context);
	
	// Member access functions
	uint8 level() const { return level_; }
	uint8 description() const { return description_; }
	SSLRecord * rec() const { return rec_; }
	bool proc() const { return proc_; }
	
protected:
	uint8 level_;
	uint8 description_;
	SSLRecord * rec_;
	bool proc_;
};


class V2Error
{
public:
	V2Error(SSLRecord * rec);
	~V2Error();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context);
	
	// Member access functions
	SSLRecord * rec() const { return rec_; }
	uint16 error_code() const { return error_code_; }
	bool proc() const { return proc_; }
	
protected:
	const_bytestring data_;
	SSLRecord * rec_;
	uint16 error_code_;
	bool proc_;
};


class ApplicationData
{
public:
	ApplicationData(SSLRecord * rec);
	~ApplicationData();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context);
	
	// Member access functions
	SSLRecord * rec() const { return rec_; }
	
protected:
	const_bytestring data_;
	SSLRecord * rec_;
};


class Heartbeat
{
public:
	Heartbeat(SSLRecord * rec);
	~Heartbeat();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder);
	
	// Member access functions
	uint8 type() const { return type_; }
	uint16 payload_length() const { return payload_length_; }
	bytestring const & data() const { return data_; }
	SSLRecord * rec() const { return rec_; }
	bool proc() const { return proc_; }
	
protected:
	uint8 type_;
	uint16 payload_length_;
	bytestring data_;
	SSLRecord * rec_;
	bool proc_;
};


class HelloRequest
{
public:
	HelloRequest(SSLRecord * rec);
	~HelloRequest();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context);
	
	// Member access functions
	SSLRecord * rec() const { return rec_; }
	
protected:
	SSLRecord * rec_;
};


class ClientHello
{
public:
	ClientHello(SSLRecord * rec);
	~ClientHello();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder);
	
	// Member access functions
	uint16 client_version() const { return client_version_; }
	uint32 gmt_unix_time() const { return gmt_unix_time_; }
	bytestring const & random_bytes() const { return random_bytes_; }
	uint8 session_len() const { return session_len_; }
	vector<uint8> * session_id() const { return session_id_; }
	uint16 csuit_len() const { return csuit_len_; }
	vector<uint16> * csuits() const { return csuits_; }
	uint8 cmeth_len() const { return cmeth_len_; }
	vector<uint8> * cmeths() const { return cmeths_; }
	vector<uint16> * ext_len() const { return ext_len_; }
	vector<SSLExtension *> * extensions() const { return extensions_; }
	SSLRecord * rec() const { return rec_; }
	bool proc() const { return proc_; }
	
protected:
	uint16 client_version_;
	uint32 gmt_unix_time_;
	bytestring random_bytes_;
	uint8 session_len_;
	vector<uint8> * session_id_;
	uint8 session_id__elem_;
	uint16 csuit_len_;
	vector<uint16> * csuits_;
	uint16 csuits__elem_;
	uint8 cmeth_len_;
	vector<uint8> * cmeths_;
	uint8 cmeths__elem_;
	vector<uint16> * ext_len_;
	uint16 ext_len__elem_;
	vector<SSLExtension *> * extensions_;
	SSLExtension * extensions__elem_;
	SSLRecord * rec_;
	bool proc_;
};


class V2ClientHello
{
public:
	V2ClientHello(SSLRecord * rec);
	~V2ClientHello();
	int initial_buffer_length() const { return 6; }
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder);
	
	// Member access functions
	uint16 csuit_len() const { return csuit_len_; }
	uint16 session_len() const { return session_len_; }
	uint16 chal_len() const { return chal_len_; }
	vector<uint24 *> * ciphers() const { return ciphers_; }
	vector<uint8> * session_id() const { return session_id_; }
	bytestring const & challenge() const { return challenge_; }
	SSLRecord * rec() const { return rec_; }
	int client_version() const { return client_version_; }
	bool proc() const { return proc_; }
	
protected:
	uint16 csuit_len_;
	uint16 session_len_;
	uint16 chal_len_;
	vector<uint24 *> * ciphers_;
	uint24 * ciphers__elem_;
	vector<uint8> * session_id_;
	uint8 session_id__elem_;
	bytestring challenge_;
	SSLRecord * rec_;
	int client_version_;
	bool proc_;
};


class ServerHello
{
public:
	ServerHello(SSLRecord * rec);
	~ServerHello();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder);
	
	// Member access functions
	uint16 server_version() const { return server_version_; }
	uint32 gmt_unix_time() const { return gmt_unix_time_; }
	bytestring const & random_bytes() const { return random_bytes_; }
	uint8 session_len() const { return session_len_; }
	vector<uint8> * session_id() const { return session_id_; }
	vector<uint16> * cipher_suite() const { return cipher_suite_; }
	uint8 compression_method() const { return compression_method_; }
	vector<uint16> * ext_len() const { return ext_len_; }
	vector<SSLExtension *> * extensions() const { return extensions_; }
	SSLRecord * rec() const { return rec_; }
	bool cipher_set() const { return cipher_set_; }
	bool proc() const { return proc_; }
	
protected:
	uint16 server_version_;
	uint32 gmt_unix_time_;
	bytestring random_bytes_;
	uint8 session_len_;
	vector<uint8> * session_id_;
	uint8 session_id__elem_;
	vector<uint16> * cipher_suite_;
	uint16 cipher_suite__elem_;
	uint8 compression_method_;
	vector<uint16> * ext_len_;
	uint16 ext_len__elem_;
	vector<SSLExtension *> * extensions_;
	SSLExtension * extensions__elem_;
	SSLRecord * rec_;
	bool cipher_set_;
	bool proc_;
};


class V2ServerHello
{
public:
	V2ServerHello(SSLRecord * rec);
	~V2ServerHello();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder);
	
	// Member access functions
	uint16 server_version() const { return server_version_; }
	uint16 cert_len() const { return cert_len_; }
	uint16 ciph_len() const { return ciph_len_; }
	uint16 conn_id_len() const { return conn_id_len_; }
	bytestring const & cert_data() const { return cert_data_; }
	vector<uint24 *> * ciphers() const { return ciphers_; }
	bytestring const & conn_id_data() const { return conn_id_data_; }
	SSLRecord * rec() const { return rec_; }
	uint8 session_id_hit() const { return session_id_hit_; }
	uint8 cert_type() const { return cert_type_; }
	bool proc() const { return proc_; }
	bool check_v2() const { return check_v2_; }
	bool cert() const { return cert_; }
	
protected:
	uint16 server_version_;
	uint16 cert_len_;
	uint16 ciph_len_;
	uint16 conn_id_len_;
	bytestring cert_data_;
	vector<uint24 *> * ciphers_;
	uint24 * ciphers__elem_;
	bytestring conn_id_data_;
	SSLRecord * rec_;
	uint8 session_id_hit_;
	uint8 cert_type_;
	bool proc_;
	bool check_v2_;
	bool cert_;
};


class X509Certificate
{
public:
	X509Certificate();
	~X509Certificate();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint24 * length() const { return length_; }
	bytestring const & certificate() const { return certificate_; }
	
protected:
	uint24 * length_;
	bytestring certificate_;
};


class Certificate
{
public:
	Certificate(SSLRecord * rec);
	~Certificate();
	int initial_buffer_length() const { return 3; }
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context);
	
	// Member access functions
	uint24 * length() const { return length_; }
	vector<X509Certificate *> * certificates() const { return certificates_; }
	SSLRecord * rec() const { return rec_; }
	bool proc() const { return proc_; }
	
protected:
	uint24 * length_;
	vector<X509Certificate *> * certificates_;
	X509Certificate * certificates__elem_;
	SSLRecord * rec_;
	bool proc_;
};


class CertificateStatus
{
public:
	CertificateStatus(SSLRecord * rec);
	~CertificateStatus();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context);
	
	// Member access functions
	uint8 status_type() const { return status_type_; }
	uint24 * length() const { return length_; }
	bytestring const & response() const { return response_; }
	SSLRecord * rec() const { return rec_; }
	bool proc() const { return proc_; }
	
protected:
	uint8 status_type_;
	uint24 * length_;
	bytestring response_;
	SSLRecord * rec_;
	bool proc_;
};


class ServerKeyExchange
{
public:
	ServerKeyExchange(SSLRecord * rec);
	~ServerKeyExchange();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder);
	
	// Member access functions
	int val_case_index() const	{ return val_case_index_; }
	EcServerKeyExchange * ec_server_key_exchange() const
		{
		switch ( val_case_index() )
			{
			case 49153:
			case 49154:
			case 49155:
			case 49156:
			case 49157:
			case 49158:
			case 49159:
			case 49160:
			case 49161:
			case 49162:
			case 49163:
			case 49164:
			case 49165:
			case 49166:
			case 49167:
			case 49168:
			case 49169:
			case 49170:
			case 49171:
			case 49172:
			case 49173:
			case 49174:
			case 49175:
			case 49176:
			case 49177:
			case 49187:
			case 49188:
			case 49189:
			case 49190:
			case 49191:
			case 49192:
			case 49193:
			case 49194:
			case 49195:
			case 49196:
			case 49197:
			case 49198:
			case 49199:
			case 49200:
			case 49201:
			case 49202:
			case 49203:
			case 49204:
			case 49205:
			case 49206:
			case 49207:
			case 49208:
			case 49209:
			case 49210:
			case 49211:
			case 49224:
			case 49225:
			case 49226:
			case 49227:
			case 49228:
			case 49229:
			case 49230:
			case 49231:
			case 49244:
			case 49245:
			case 49246:
			case 49247:
			case 49248:
			case 49249:
			case 49250:
			case 49251:
			case 49264:
			case 49265:
			case 49266:
			case 49267:
			case 49268:
			case 49269:
			case 49270:
			case 49271:
			case 49272:
			case 49273:
			case 49286:
			case 49287:
			case 49288:
			case 49289:
			case 49290:
			case 49291:
			case 49292:
			case 49293:
			case 49306:
			case 49307:
			case 49324:
			case 49325:
			case 49326:
			case 49327:
			case 52243:
			case 52244:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:457:ec_server_key_exchange", val_case_index(), "TLS_ECDH_ECDSA_WITH_NULL_SHA, TLS_ECDH_ECDSA_WITH_RC4_128_SHA, TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA, TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_ECDSA_WITH_NULL_SHA, TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDH_RSA_WITH_NULL_SHA, TLS_ECDH_RSA_WITH_RC4_128_SHA, TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA, TLS_ECDH_RSA_WITH_AES_128_CBC_SHA, TLS_ECDH_RSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_RSA_WITH_NULL_SHA, TLS_ECDHE_RSA_WITH_RC4_128_SHA, TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, TLS_ECDH_ANON_WITH_NULL_SHA, TLS_ECDH_ANON_WITH_RC4_128_SHA, TLS_ECDH_ANON_WITH_3DES_EDE_CBC_SHA, TLS_ECDH_ANON_WITH_AES_128_CBC_SHA, TLS_ECDH_ANON_WITH_AES_256_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384, TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256, TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384, TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256, TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256, TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_PSK_WITH_RC4_128_SHA, TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA, TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA, TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA, TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256, TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384, TLS_ECDHE_PSK_WITH_NULL_SHA, TLS_ECDHE_PSK_WITH_NULL_SHA256, TLS_ECDHE_PSK_WITH_NULL_SHA384, TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256, TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384, TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256, TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384, TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256, TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384, TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256, TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384, TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256, TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384, TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256, TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384, TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384, TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256, TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384, TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256, TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384, TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256, TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384, TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256, TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384, TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256, TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384, TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256, TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384, TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256, TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384, TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256, TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384, TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384, TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256, TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384, TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256, TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384, TLS_ECDHE_ECDSA_WITH_AES_128_CCM, TLS_ECDHE_ECDSA_WITH_AES_256_CCM, TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8, TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8, TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256, TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256");
				break;
			}
		return ec_server_key_exchange_;
		}
	DhServerKeyExchange * dh_server_key_exchange() const
		{
		switch ( val_case_index() )
			{
			case 17:
			case 18:
			case 19:
			case 20:
			case 21:
			case 22:
			case 50:
			case 51:
			case 56:
			case 57:
			case 64:
			case 68:
			case 69:
			case 99:
			case 101:
			case 102:
			case 103:
			case 106:
			case 107:
			case 114:
			case 115:
			case 116:
			case 119:
			case 120:
			case 121:
			case 135:
			case 136:
			case 142:
			case 143:
			case 144:
			case 145:
			case 153:
			case 154:
			case 158:
			case 159:
			case 162:
			case 163:
			case 170:
			case 171:
			case 178:
			case 179:
			case 180:
			case 181:
			case 189:
			case 190:
			case 195:
			case 196:
			case 49218:
			case 49219:
			case 49220:
			case 49221:
			case 49234:
			case 49235:
			case 49238:
			case 49239:
			case 49254:
			case 49255:
			case 49260:
			case 49261:
			case 49276:
			case 49277:
			case 49280:
			case 49281:
			case 49296:
			case 49297:
			case 49302:
			case 49303:
			case 49310:
			case 49311:
			case 49314:
			case 49315:
			case 49318:
			case 49319:
			case 49322:
			case 49323:
			case 52245:
			case 23:
			case 24:
			case 25:
			case 26:
			case 27:
			case 52:
			case 58:
			case 70:
			case 108:
			case 109:
			case 137:
			case 155:
			case 166:
			case 167:
			case 191:
			case 197:
			case 49222:
			case 49223:
			case 49242:
			case 49243:
			case 49284:
			case 49285:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:560:dh_server_key_exchange", val_case_index(), "TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA, TLS_DHE_DSS_WITH_DES_CBC_SHA, TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA, TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA, TLS_DHE_RSA_WITH_DES_CBC_SHA, TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA, TLS_DHE_DSS_WITH_AES_128_CBC_SHA, TLS_DHE_RSA_WITH_AES_128_CBC_SHA, TLS_DHE_DSS_WITH_AES_256_CBC_SHA, TLS_DHE_RSA_WITH_AES_256_CBC_SHA, TLS_DHE_DSS_WITH_AES_128_CBC_SHA256, TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA, TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA, TLS_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA, TLS_DHE_DSS_EXPORT1024_WITH_RC4_56_SHA, TLS_DHE_DSS_WITH_RC4_128_SHA, TLS_DHE_RSA_WITH_AES_128_CBC_SHA256, TLS_DHE_DSS_WITH_AES_256_CBC_SHA256, TLS_DHE_RSA_WITH_AES_256_CBC_SHA256, TLS_DHE_DSS_WITH_3DES_EDE_CBC_RMD, TLS_DHE_DSS_WITH_AES_128_CBC_RMD, TLS_DHE_DSS_WITH_AES_256_CBC_RMD, TLS_DHE_RSA_WITH_3DES_EDE_CBC_RMD, TLS_DHE_RSA_WITH_AES_128_CBC_RMD, TLS_DHE_RSA_WITH_AES_256_CBC_RMD, TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA, TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA, TLS_DHE_PSK_WITH_RC4_128_SHA, TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA, TLS_DHE_PSK_WITH_AES_128_CBC_SHA, TLS_DHE_PSK_WITH_AES_256_CBC_SHA, TLS_DHE_DSS_WITH_SEED_CBC_SHA, TLS_DHE_RSA_WITH_SEED_CBC_SHA, TLS_DHE_RSA_WITH_AES_128_GCM_SHA256, TLS_DHE_RSA_WITH_AES_256_GCM_SHA384, TLS_DHE_DSS_WITH_AES_128_GCM_SHA256, TLS_DHE_DSS_WITH_AES_256_GCM_SHA384, TLS_DHE_PSK_WITH_AES_128_GCM_SHA256, TLS_DHE_PSK_WITH_AES_256_GCM_SHA384, TLS_DHE_PSK_WITH_AES_128_CBC_SHA256, TLS_DHE_PSK_WITH_AES_256_CBC_SHA384, TLS_DHE_PSK_WITH_NULL_SHA256, TLS_DHE_PSK_WITH_NULL_SHA384, TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256, TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256, TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256, TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256, TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256, TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384, TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256, TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384, TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256, TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384, TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256, TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384, TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256, TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384, TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256, TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384, TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256, TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384, TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256, TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384, TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256, TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384, TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256, TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384, TLS_DHE_RSA_WITH_AES_128_CCM, TLS_DHE_RSA_WITH_AES_256_CCM, TLS_DHE_RSA_WITH_AES_128_CCM_8, TLS_DHE_RSA_WITH_AES_256_CCM_8, TLS_DHE_PSK_WITH_AES_128_CCM, TLS_DHE_PSK_WITH_AES_256_CCM, TLS_PSK_DHE_WITH_AES_128_CCM_8, TLS_PSK_DHE_WITH_AES_256_CCM_8, TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256, TLS_DH_ANON_EXPORT_WITH_RC4_40_MD5, TLS_DH_ANON_WITH_RC4_128_MD5, TLS_DH_ANON_EXPORT_WITH_DES40_CBC_SHA, TLS_DH_ANON_WITH_DES_CBC_SHA, TLS_DH_ANON_WITH_3DES_EDE_CBC_SHA, TLS_DH_ANON_WITH_AES_128_CBC_SHA, TLS_DH_ANON_WITH_AES_256_CBC_SHA, TLS_DH_ANON_WITH_CAMELLIA_128_CBC_SHA, TLS_DH_ANON_WITH_AES_128_CBC_SHA256, TLS_DH_ANON_WITH_AES_256_CBC_SHA256, TLS_DH_ANON_WITH_CAMELLIA_256_CBC_SHA, TLS_DH_ANON_WITH_SEED_CBC_SHA, TLS_DH_ANON_WITH_AES_128_GCM_SHA256, TLS_DH_ANON_WITH_AES_256_GCM_SHA384, TLS_DH_ANON_WITH_CAMELLIA_128_CBC_SHA256, TLS_DH_ANON_WITH_CAMELLIA_256_CBC_SHA256, TLS_DH_ANON_WITH_ARIA_128_CBC_SHA256, TLS_DH_ANON_WITH_ARIA_256_CBC_SHA384, TLS_DH_ANON_WITH_ARIA_128_GCM_SHA256, TLS_DH_ANON_WITH_ARIA_256_GCM_SHA384, TLS_DH_ANON_WITH_CAMELLIA_128_GCM_SHA256, TLS_DH_ANON_WITH_CAMELLIA_256_GCM_SHA384");
				break;
			}
		return dh_server_key_exchange_;
		}
	SSLRecord * rec() const { return rec_; }
	
protected:
	int val_case_index_;
	EcServerKeyExchange * ec_server_key_exchange_;
	DhServerKeyExchange * dh_server_key_exchange_;
	const_bytestring key_;
	SSLRecord * rec_;
};


class EcServerKeyExchange
{
public:
	EcServerKeyExchange(SSLRecord * rec);
	~EcServerKeyExchange();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder);
	
	// Member access functions
	uint8 curve_type() const { return curve_type_; }
	uint16 curve() const { return curve_; }
	SSLRecord * rec() const { return rec_; }
	bool proc() const { return proc_; }
	
protected:
	uint8 curve_type_;
	uint16 curve_;
	const_bytestring data_;
	SSLRecord * rec_;
	bool proc_;
};


class DhServerKeyExchange
{
public:
	DhServerKeyExchange(SSLRecord * rec);
	~DhServerKeyExchange();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder);
	
	// Member access functions
	uint16 dh_p_length() const { return dh_p_length_; }
	bytestring const & dh_p() const { return dh_p_; }
	uint16 dh_g_length() const { return dh_g_length_; }
	bytestring const & dh_g() const { return dh_g_; }
	uint16 dh_Ys_length() const { return dh_Ys_length_; }
	bytestring const & dh_Ys() const { return dh_Ys_; }
	SSLRecord * rec() const { return rec_; }
	bool proc() const { return proc_; }
	
protected:
	uint16 dh_p_length_;
	bytestring dh_p_;
	uint16 dh_g_length_;
	bytestring dh_g_;
	uint16 dh_Ys_length_;
	bytestring dh_Ys_;
	const_bytestring data_;
	SSLRecord * rec_;
	bool proc_;
};


class CertificateRequest
{
public:
	CertificateRequest(SSLRecord * rec);
	~CertificateRequest();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context);
	
	// Member access functions
	SSLRecord * rec() const { return rec_; }
	
protected:
	const_bytestring cont_;
	SSLRecord * rec_;
};


class ServerHelloDone
{
public:
	ServerHelloDone(SSLRecord * rec);
	~ServerHelloDone();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context);
	
	// Member access functions
	SSLRecord * rec() const { return rec_; }
	
protected:
	SSLRecord * rec_;
};


class ClientKeyExchange
{
public:
	ClientKeyExchange(SSLRecord * rec);
	~ClientKeyExchange();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context);
	
	// Member access functions
	SSLRecord * rec() const { return rec_; }
	
protected:
	const_bytestring key_;
	SSLRecord * rec_;
};


class V2ClientMasterKey
{
public:
	V2ClientMasterKey(SSLRecord * rec);
	~V2ClientMasterKey();
	int initial_buffer_length() const { return 7; }
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder);
	
	// Member access functions
	uint8 cipher_kind_8() const { return cipher_kind_8_; }
	uint16 cl_key_len() const { return cl_key_len_; }
	uint16 en_key_len() const { return en_key_len_; }
	uint16 key_arg_len() const { return key_arg_len_; }
	SSLRecord * rec() const { return rec_; }
	int cipher_kind() const { return cipher_kind_; }
	bool state_changed_client() const { return state_changed_client_; }
	bool state_changed_server() const { return state_changed_server_; }
	bool proc() const { return proc_; }
	
protected:
	uint8 cipher_kind_8_;
	uint16 cl_key_len_;
	uint16 en_key_len_;
	uint16 key_arg_len_;
	const_bytestring cl_key_data_;
	const_bytestring en_key_data_;
	const_bytestring key_arg_data_;
	SSLRecord * rec_;
	int cipher_kind_;
	bool state_changed_client_;
	bool state_changed_server_;
	bool proc_;
};


class CertificateVerify
{
public:
	CertificateVerify(SSLRecord * rec);
	~CertificateVerify();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context);
	
	// Member access functions
	SSLRecord * rec() const { return rec_; }
	
protected:
	const_bytestring cont_;
	SSLRecord * rec_;
};


class Finished
{
public:
	Finished(SSLRecord * rec);
	~Finished();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context);
	
	// Member access functions
	SSLRecord * rec() const { return rec_; }
	
protected:
	const_bytestring cont_;
	SSLRecord * rec_;
};


class SessionTicketHandshake
{
public:
	SessionTicketHandshake(SSLRecord * rec);
	~SessionTicketHandshake();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder);
	
	// Member access functions
	uint32 ticket_lifetime_hint() const { return ticket_lifetime_hint_; }
	bytestring const & data() const { return data_; }
	SSLRecord * rec() const { return rec_; }
	bool proc() const { return proc_; }
	
protected:
	uint32 ticket_lifetime_hint_;
	bytestring data_;
	SSLRecord * rec_;
	bool proc_;
};


class UnknownHandshake
{
public:
	UnknownHandshake(Handshake * hs, bool is_orig);
	~UnknownHandshake();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context);
	
	// Member access functions
	Handshake * hs() const { return hs_; }
	bool is_orig() const { return is_orig_; }
	bool proc() const { return proc_; }
	
protected:
	const_bytestring data_;
	Handshake * hs_;
	bool is_orig_;
	bool proc_;
};


class Handshake
{
public:
	Handshake(SSLRecord * rec);
	~Handshake();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder);
	
	// Member access functions
	uint8 msg_type() const { return msg_type_; }
	uint24 * length() const { return length_; }
	int body_case_index() const	{ return body_case_index_; }
	HelloRequest * hello_request() const
		{
		switch ( body_case_index() )
			{
			case 0:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:682:hello_request", body_case_index(), "HELLO_REQUEST");
				break;
			}
		return hello_request_;
		}
	ClientHello * client_hello() const
		{
		switch ( body_case_index() )
			{
			case 1:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:683:client_hello", body_case_index(), "CLIENT_HELLO");
				break;
			}
		return client_hello_;
		}
	ServerHello * server_hello() const
		{
		switch ( body_case_index() )
			{
			case 2:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:684:server_hello", body_case_index(), "SERVER_HELLO");
				break;
			}
		return server_hello_;
		}
	SessionTicketHandshake * session_ticket() const
		{
		switch ( body_case_index() )
			{
			case 4:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:685:session_ticket", body_case_index(), "SESSION_TICKET");
				break;
			}
		return session_ticket_;
		}
	Certificate * certificate() const
		{
		switch ( body_case_index() )
			{
			case 11:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:686:certificate", body_case_index(), "CERTIFICATE");
				break;
			}
		return certificate_;
		}
	ServerKeyExchange * server_key_exchange() const
		{
		switch ( body_case_index() )
			{
			case 12:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:687:server_key_exchange", body_case_index(), "SERVER_KEY_EXCHANGE");
				break;
			}
		return server_key_exchange_;
		}
	CertificateRequest * certificate_request() const
		{
		switch ( body_case_index() )
			{
			case 13:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:688:certificate_request", body_case_index(), "CERTIFICATE_REQUEST");
				break;
			}
		return certificate_request_;
		}
	ServerHelloDone * server_hello_done() const
		{
		switch ( body_case_index() )
			{
			case 14:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:689:server_hello_done", body_case_index(), "SERVER_HELLO_DONE");
				break;
			}
		return server_hello_done_;
		}
	CertificateVerify * certificate_verify() const
		{
		switch ( body_case_index() )
			{
			case 15:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:690:certificate_verify", body_case_index(), "CERTIFICATE_VERIFY");
				break;
			}
		return certificate_verify_;
		}
	ClientKeyExchange * client_key_exchange() const
		{
		switch ( body_case_index() )
			{
			case 16:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:691:client_key_exchange", body_case_index(), "CLIENT_KEY_EXCHANGE");
				break;
			}
		return client_key_exchange_;
		}
	Finished * finished() const
		{
		switch ( body_case_index() )
			{
			case 20:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:692:finished", body_case_index(), "FINISHED");
				break;
			}
		return finished_;
		}
	CertificateStatus * certificate_status() const
		{
		switch ( body_case_index() )
			{
			case 22:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:694:certificate_status", body_case_index(), "CERTIFICATE_STATUS");
				break;
			}
		return certificate_status_;
		}
	UnknownHandshake * unknown_handshake() const
		{
		return unknown_handshake_;
		}
	SSLRecord * rec() const { return rec_; }
	bool proc() const { return proc_; }
	
protected:
	uint8 msg_type_;
	uint24 * length_;
	int body_case_index_;
	HelloRequest * hello_request_;
	ClientHello * client_hello_;
	ServerHello * server_hello_;
	SessionTicketHandshake * session_ticket_;
	Certificate * certificate_;
	ServerKeyExchange * server_key_exchange_;
	CertificateRequest * certificate_request_;
	ServerHelloDone * server_hello_done_;
	CertificateVerify * certificate_verify_;
	ClientKeyExchange * client_key_exchange_;
	Finished * finished_;
	const_bytestring certificate_url_;
	CertificateStatus * certificate_status_;
	UnknownHandshake * unknown_handshake_;
	SSLRecord * rec_;
	bool proc_;
};


class UnknownRecord
{
public:
	UnknownRecord(SSLRecord * rec);
	~UnknownRecord();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context);
	
	// Member access functions
	SSLRecord * rec() const { return rec_; }
	bool proc() const { return proc_; }
	
protected:
	const_bytestring cont_;
	SSLRecord * rec_;
	bool proc_;
};


class CiphertextRecord
{
public:
	CiphertextRecord(SSLRecord * rec);
	~CiphertextRecord();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context);
	
	// Member access functions
	SSLRecord * rec() const { return rec_; }
	bool proc() const { return proc_; }
	
protected:
	const_bytestring cont_;
	SSLRecord * rec_;
	bool proc_;
};


class SSLPDU
{
public:
	SSLPDU(bool is_orig);
	~SSLPDU();
	bool ParseBuffer(flow_buffer_t t_flow_buffer, ContextSSL * t_context);
	
	// Member access functions
	bool is_orig() const { return is_orig_; }
	int byteorder() const { return byteorder_; }
	
protected:
	vector<SSLRecord *> * records_;
	SSLRecord * records__elem_;
	int records__arraylength_;
	int records__elem__it_;
	bool is_orig_;
	int byteorder_;
	int parsing_state_;
};


class SSL_Flow : public binpac::FlowAnalyzer
{
public:
	SSL_Flow(SSL_Conn * connection, bool is_orig);
	~SSL_Flow();
	
	// Member access functions
	FlowBuffer * flow_buffer() const { return flow_buffer_; }
	SSL_Conn * connection() const { return connection_; }
	bool is_orig() const { return is_orig_; }
	
	void NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data);
	void NewGap(int gap_length);
	void FlowEOF();
	
protected:
	SSLPDU * dataunit_;
	ContextSSL * context_;
	FlowBuffer * flow_buffer_;
	SSL_Conn * connection_;
	bool is_orig_;
};


	class extract_certs {
	public:
		bytestring const& operator() (X509Certificate* cert) const
			{
			return cert->certificate();
			}
	};

	string orig_label(bool is_orig);
	string handshake_type_label(int type);
	
StringVal * to_string_val(vector<uint8> * data);
bool version_ok(uint16 vers);
} // namespace SSL
}  // namespace binpac
#endif /* _home_benjamin_Bro_bro_2_3_1_src_analyzer_protocol_ssl_ssl_pac_h */

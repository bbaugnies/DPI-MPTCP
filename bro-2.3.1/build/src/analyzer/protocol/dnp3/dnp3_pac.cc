// This file is automatically generated from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3.pac.


#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include "/home/benjamin/Bro/bro-2.3.1/build/src/analyzer/protocol/dnp3/dnp3_pac.h"

namespace binpac {






namespace DNP3 {
ContextDNP3::ContextDNP3(DNP3_Conn * connection, DNP3_Flow * flow, FlowBuffer * flow_buffer)
	{
	connection_ = connection;
	flow_ = flow;
	flow_buffer_ = flow_buffer;
	}

ContextDNP3::~ContextDNP3()
	{
	}

DNP3_PDU::DNP3_PDU(bool is_orig)
	{
	val_case_index_ = -1;
	request_ = 0;
	response_ = 0;
	is_orig_ = is_orig;
	byteorder_ = bigendian;
	}

DNP3_PDU::~DNP3_PDU()
	{
	switch ( val_case_index() )
		{
		case 1:
			// Clean up "request"
			{
			delete request_;
			request_ = 0;
			}
			break;
		case 0:
			// Clean up "response"
			{
			delete response_;
			response_ = 0;
			}
			break;
		}
	}

bool DNP3_PDU::ParseBuffer(flow_buffer_t t_flow_buffer, ContextDNP3 * t_context)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	val_case_index_ = is_orig();
	switch ( val_case_index() )
		{
		case 1:
			// Parse "request"
			{
			if ( ! request_ )
				{
				request_ = new DNP3_Request();
				}
			bool t_request_parsing_complete;
			t_request_parsing_complete = false;
			while ( ! t_request_parsing_complete && t_flow_buffer->ready() )
				{
				const_byteptr t_begin_of_data = t_flow_buffer->begin();
				const_byteptr t_end_of_data = t_flow_buffer->end();
				t_request_parsing_complete = request_->ParseBuffer(t_flow_buffer, t_context);
				if ( t_request_parsing_complete )
					{
					// Evaluate 'let' and 'withinput' fields
					}
				}
			t_val_parsing_complete = t_request_parsing_complete;
			}
			break;
		case 0:
			// Parse "response"
			{
			if ( ! response_ )
				{
				response_ = new DNP3_Response();
				}
			bool t_response_parsing_complete;
			t_response_parsing_complete = false;
			while ( ! t_response_parsing_complete && t_flow_buffer->ready() )
				{
				const_byteptr t_begin_of_data = t_flow_buffer->begin();
				const_byteptr t_end_of_data = t_flow_buffer->end();
				t_response_parsing_complete = response_->ParseBuffer(t_flow_buffer, t_context);
				if ( t_response_parsing_complete )
					{
					// Evaluate 'let' and 'withinput' fields
					}
				}
			t_val_parsing_complete = t_response_parsing_complete;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("DNP3_PDU", val_case_index());
			break;
		}
	if ( t_val_parsing_complete )
		{
		// Evaluate 'let' and 'withinput' fields
		}
	return t_val_parsing_complete;
	}

Header_Block::Header_Block()
	{
	start_ = 0;
	len_ = 0;
	ctrl_ = 0;
	dest_addr_ = 0;
	src_addr_ = 0;
	byteorder_ = littleendian;
	get_header_ = 0;
	}

Header_Block::~Header_Block()
	{
	}

int Header_Block::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "Header_Block"
	if ( t_begin_of_data + (8) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Header_Block",
			(0) + (8), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start"
	start_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "len"
	len_ = *((uint8 const *) ((t_begin_of_data + 2)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "ctrl"
	ctrl_ = *((uint8 const *) ((t_begin_of_data + 3)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "dest_addr"
	dest_addr_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "src_addr"
	src_addr_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 6))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	get_header_ = t_context->flow()->get_dnp3_header_block(start(), len(), ctrl(), dest_addr(), src_addr());
	BINPAC_ASSERT(t_begin_of_data + (8) <= t_end_of_data);
	return 8;
	}

DNP3_Request::DNP3_Request()
	{
	addin_header_ = 0;
	app_header_ = 0;
	data_case_index_ = -1;
	read_requests_ = 0;
	read_requests__elem_ = 0;
	write_requests_ = 0;
	write_requests__elem_ = 0;
	select_requests_ = 0;
	select_requests__elem_ = 0;
	operate_requests_ = 0;
	operate_requests__elem_ = 0;
	direct_operate_requests_ = 0;
	direct_operate_requests__elem_ = 0;
	direct_operate_nr_requests_ = 0;
	direct_operate_nr_requests__elem_ = 0;
	immed_freeze_requests_ = 0;
	immed_freeze_requests__elem_ = 0;
	immed_freeze_nr_requests_ = 0;
	immed_freeze_nr_requests__elem_ = 0;
	freeze_clear_requests_ = 0;
	freeze_clear_requests__elem_ = 0;
	freeze_clear_nr_requests_ = 0;
	freeze_clear_nr_requests__elem_ = 0;
	freeze_time_requests_ = 0;
	freeze_time_requests__elem_ = 0;
	freeze_time_nr_requests_ = 0;
	freeze_time_nr_requests__elem_ = 0;
	initilize_appl_ = 0;
	initilize_appl__elem_ = 0;
	start_appl_ = 0;
	start_appl__elem_ = 0;
	stop_appl_ = 0;
	stop_appl__elem_ = 0;
	enable_unsolicited_ = 0;
	enable_unsolicited__elem_ = 0;
	disable_unsolicited_ = 0;
	disable_unsolicited__elem_ = 0;
	assign_class_ = 0;
	assign_class__elem_ = 0;
	open_file_ = 0;
	open_file__elem_ = 0;
	close_file_ = 0;
	close_file__elem_ = 0;
	delete_file_ = 0;
	delete_file__elem_ = 0;
	abort_file_ = 0;
	abort_file__elem_ = 0;
	get_file_info_ = 0;
	get_file_info__elem_ = 0;
	auth_file_ = 0;
	auth_file__elem_ = 0;
	active_config_ = 0;
	active_config__elem_ = 0;
	auth_req_ = 0;
	auth_req__elem_ = 0;
	auth_err_ = 0;
	auth_err__elem_ = 0;
	byteorder_ = bigendian;
	buffering_state_ = 0;
	buffering_state_ = 0;
	}

DNP3_Request::~DNP3_Request()
	{
	delete addin_header_;
	addin_header_ = 0;
	delete app_header_;
	app_header_ = 0;
	switch ( data_case_index() )
		{
		case 0:
			// Clean up "none_coonfirm"
			{
			}
			break;
		case 1:
			// Clean up "read_requests"
			{
			delete read_requests__elem_;
			read_requests__elem_ = 0;
			if ( read_requests() )
				{
				for ( int i = 0; i < (int) read_requests()->size(); ++i )
					{
					Request_Objects * read_requests__elem_ = (*read_requests_)[i];
					delete read_requests__elem_;
					read_requests__elem_ = 0;
					}
				}
			delete read_requests_;
			}
			break;
		case 2:
			// Clean up "write_requests"
			{
			delete write_requests__elem_;
			write_requests__elem_ = 0;
			if ( write_requests() )
				{
				for ( int i = 0; i < (int) write_requests()->size(); ++i )
					{
					Request_Objects * write_requests__elem_ = (*write_requests_)[i];
					delete write_requests__elem_;
					write_requests__elem_ = 0;
					}
				}
			delete write_requests_;
			}
			break;
		case 3:
			// Clean up "select_requests"
			{
			delete select_requests__elem_;
			select_requests__elem_ = 0;
			if ( select_requests() )
				{
				for ( int i = 0; i < (int) select_requests()->size(); ++i )
					{
					Request_Objects * select_requests__elem_ = (*select_requests_)[i];
					delete select_requests__elem_;
					select_requests__elem_ = 0;
					}
				}
			delete select_requests_;
			}
			break;
		case 4:
			// Clean up "operate_requests"
			{
			delete operate_requests__elem_;
			operate_requests__elem_ = 0;
			if ( operate_requests() )
				{
				for ( int i = 0; i < (int) operate_requests()->size(); ++i )
					{
					Request_Objects * operate_requests__elem_ = (*operate_requests_)[i];
					delete operate_requests__elem_;
					operate_requests__elem_ = 0;
					}
				}
			delete operate_requests_;
			}
			break;
		case 5:
			// Clean up "direct_operate_requests"
			{
			delete direct_operate_requests__elem_;
			direct_operate_requests__elem_ = 0;
			if ( direct_operate_requests() )
				{
				for ( int i = 0; i < (int) direct_operate_requests()->size(); ++i )
					{
					Request_Objects * direct_operate_requests__elem_ = (*direct_operate_requests_)[i];
					delete direct_operate_requests__elem_;
					direct_operate_requests__elem_ = 0;
					}
				}
			delete direct_operate_requests_;
			}
			break;
		case 6:
			// Clean up "direct_operate_nr_requests"
			{
			delete direct_operate_nr_requests__elem_;
			direct_operate_nr_requests__elem_ = 0;
			if ( direct_operate_nr_requests() )
				{
				for ( int i = 0; i < (int) direct_operate_nr_requests()->size(); ++i )
					{
					Request_Objects * direct_operate_nr_requests__elem_ = (*direct_operate_nr_requests_)[i];
					delete direct_operate_nr_requests__elem_;
					direct_operate_nr_requests__elem_ = 0;
					}
				}
			delete direct_operate_nr_requests_;
			}
			break;
		case 7:
			// Clean up "immed_freeze_requests"
			{
			delete immed_freeze_requests__elem_;
			immed_freeze_requests__elem_ = 0;
			if ( immed_freeze_requests() )
				{
				for ( int i = 0; i < (int) immed_freeze_requests()->size(); ++i )
					{
					Request_Objects * immed_freeze_requests__elem_ = (*immed_freeze_requests_)[i];
					delete immed_freeze_requests__elem_;
					immed_freeze_requests__elem_ = 0;
					}
				}
			delete immed_freeze_requests_;
			}
			break;
		case 8:
			// Clean up "immed_freeze_nr_requests"
			{
			delete immed_freeze_nr_requests__elem_;
			immed_freeze_nr_requests__elem_ = 0;
			if ( immed_freeze_nr_requests() )
				{
				for ( int i = 0; i < (int) immed_freeze_nr_requests()->size(); ++i )
					{
					Request_Objects * immed_freeze_nr_requests__elem_ = (*immed_freeze_nr_requests_)[i];
					delete immed_freeze_nr_requests__elem_;
					immed_freeze_nr_requests__elem_ = 0;
					}
				}
			delete immed_freeze_nr_requests_;
			}
			break;
		case 9:
			// Clean up "freeze_clear_requests"
			{
			delete freeze_clear_requests__elem_;
			freeze_clear_requests__elem_ = 0;
			if ( freeze_clear_requests() )
				{
				for ( int i = 0; i < (int) freeze_clear_requests()->size(); ++i )
					{
					Request_Objects * freeze_clear_requests__elem_ = (*freeze_clear_requests_)[i];
					delete freeze_clear_requests__elem_;
					freeze_clear_requests__elem_ = 0;
					}
				}
			delete freeze_clear_requests_;
			}
			break;
		case 10:
			// Clean up "freeze_clear_nr_requests"
			{
			delete freeze_clear_nr_requests__elem_;
			freeze_clear_nr_requests__elem_ = 0;
			if ( freeze_clear_nr_requests() )
				{
				for ( int i = 0; i < (int) freeze_clear_nr_requests()->size(); ++i )
					{
					Request_Objects * freeze_clear_nr_requests__elem_ = (*freeze_clear_nr_requests_)[i];
					delete freeze_clear_nr_requests__elem_;
					freeze_clear_nr_requests__elem_ = 0;
					}
				}
			delete freeze_clear_nr_requests_;
			}
			break;
		case 11:
			// Clean up "freeze_time_requests"
			{
			delete freeze_time_requests__elem_;
			freeze_time_requests__elem_ = 0;
			if ( freeze_time_requests() )
				{
				for ( int i = 0; i < (int) freeze_time_requests()->size(); ++i )
					{
					Request_Objects * freeze_time_requests__elem_ = (*freeze_time_requests_)[i];
					delete freeze_time_requests__elem_;
					freeze_time_requests__elem_ = 0;
					}
				}
			delete freeze_time_requests_;
			}
			break;
		case 12:
			// Clean up "freeze_time_nr_requests"
			{
			delete freeze_time_nr_requests__elem_;
			freeze_time_nr_requests__elem_ = 0;
			if ( freeze_time_nr_requests() )
				{
				for ( int i = 0; i < (int) freeze_time_nr_requests()->size(); ++i )
					{
					Request_Objects * freeze_time_nr_requests__elem_ = (*freeze_time_nr_requests_)[i];
					delete freeze_time_nr_requests__elem_;
					freeze_time_nr_requests__elem_ = 0;
					}
				}
			delete freeze_time_nr_requests_;
			}
			break;
		case 13:
			// Clean up "cold_restart"
			{
			}
			break;
		case 14:
			// Clean up "warm_restart"
			{
			}
			break;
		case 15:
			// Clean up "initilize_data"
			{
			}
			break;
		case 16:
			// Clean up "initilize_appl"
			{
			delete initilize_appl__elem_;
			initilize_appl__elem_ = 0;
			if ( initilize_appl() )
				{
				for ( int i = 0; i < (int) initilize_appl()->size(); ++i )
					{
					Request_Objects * initilize_appl__elem_ = (*initilize_appl_)[i];
					delete initilize_appl__elem_;
					initilize_appl__elem_ = 0;
					}
				}
			delete initilize_appl_;
			}
			break;
		case 17:
			// Clean up "start_appl"
			{
			delete start_appl__elem_;
			start_appl__elem_ = 0;
			if ( start_appl() )
				{
				for ( int i = 0; i < (int) start_appl()->size(); ++i )
					{
					Request_Objects * start_appl__elem_ = (*start_appl_)[i];
					delete start_appl__elem_;
					start_appl__elem_ = 0;
					}
				}
			delete start_appl_;
			}
			break;
		case 18:
			// Clean up "stop_appl"
			{
			delete stop_appl__elem_;
			stop_appl__elem_ = 0;
			if ( stop_appl() )
				{
				for ( int i = 0; i < (int) stop_appl()->size(); ++i )
					{
					Request_Objects * stop_appl__elem_ = (*stop_appl_)[i];
					delete stop_appl__elem_;
					stop_appl__elem_ = 0;
					}
				}
			delete stop_appl_;
			}
			break;
		case 19:
			// Clean up "save_config"
			{
			}
			break;
		case 20:
			// Clean up "enable_unsolicited"
			{
			delete enable_unsolicited__elem_;
			enable_unsolicited__elem_ = 0;
			if ( enable_unsolicited() )
				{
				for ( int i = 0; i < (int) enable_unsolicited()->size(); ++i )
					{
					Request_Objects * enable_unsolicited__elem_ = (*enable_unsolicited_)[i];
					delete enable_unsolicited__elem_;
					enable_unsolicited__elem_ = 0;
					}
				}
			delete enable_unsolicited_;
			}
			break;
		case 21:
			// Clean up "disable_unsolicited"
			{
			delete disable_unsolicited__elem_;
			disable_unsolicited__elem_ = 0;
			if ( disable_unsolicited() )
				{
				for ( int i = 0; i < (int) disable_unsolicited()->size(); ++i )
					{
					Request_Objects * disable_unsolicited__elem_ = (*disable_unsolicited_)[i];
					delete disable_unsolicited__elem_;
					disable_unsolicited__elem_ = 0;
					}
				}
			delete disable_unsolicited_;
			}
			break;
		case 22:
			// Clean up "assign_class"
			{
			delete assign_class__elem_;
			assign_class__elem_ = 0;
			if ( assign_class() )
				{
				for ( int i = 0; i < (int) assign_class()->size(); ++i )
					{
					Request_Objects * assign_class__elem_ = (*assign_class_)[i];
					delete assign_class__elem_;
					assign_class__elem_ = 0;
					}
				}
			delete assign_class_;
			}
			break;
		case 23:
			// Clean up "delay_measure"
			{
			}
			break;
		case 24:
			// Clean up "record_cur_time"
			{
			}
			break;
		case 25:
			// Clean up "open_file"
			{
			delete open_file__elem_;
			open_file__elem_ = 0;
			if ( open_file() )
				{
				for ( int i = 0; i < (int) open_file()->size(); ++i )
					{
					Request_Objects * open_file__elem_ = (*open_file_)[i];
					delete open_file__elem_;
					open_file__elem_ = 0;
					}
				}
			delete open_file_;
			}
			break;
		case 26:
			// Clean up "close_file"
			{
			delete close_file__elem_;
			close_file__elem_ = 0;
			if ( close_file() )
				{
				for ( int i = 0; i < (int) close_file()->size(); ++i )
					{
					Request_Objects * close_file__elem_ = (*close_file_)[i];
					delete close_file__elem_;
					close_file__elem_ = 0;
					}
				}
			delete close_file_;
			}
			break;
		case 27:
			// Clean up "delete_file"
			{
			delete delete_file__elem_;
			delete_file__elem_ = 0;
			if ( delete_file() )
				{
				for ( int i = 0; i < (int) delete_file()->size(); ++i )
					{
					Request_Objects * delete_file__elem_ = (*delete_file_)[i];
					delete delete_file__elem_;
					delete_file__elem_ = 0;
					}
				}
			delete delete_file_;
			}
			break;
		case 30:
			// Clean up "abort_file"
			{
			delete abort_file__elem_;
			abort_file__elem_ = 0;
			if ( abort_file() )
				{
				for ( int i = 0; i < (int) abort_file()->size(); ++i )
					{
					Request_Objects * abort_file__elem_ = (*abort_file_)[i];
					delete abort_file__elem_;
					abort_file__elem_ = 0;
					}
				}
			delete abort_file_;
			}
			break;
		case 28:
			// Clean up "get_file_info"
			{
			delete get_file_info__elem_;
			get_file_info__elem_ = 0;
			if ( get_file_info() )
				{
				for ( int i = 0; i < (int) get_file_info()->size(); ++i )
					{
					Request_Objects * get_file_info__elem_ = (*get_file_info_)[i];
					delete get_file_info__elem_;
					get_file_info__elem_ = 0;
					}
				}
			delete get_file_info_;
			}
			break;
		case 29:
			// Clean up "auth_file"
			{
			delete auth_file__elem_;
			auth_file__elem_ = 0;
			if ( auth_file() )
				{
				for ( int i = 0; i < (int) auth_file()->size(); ++i )
					{
					Request_Objects * auth_file__elem_ = (*auth_file_)[i];
					delete auth_file__elem_;
					auth_file__elem_ = 0;
					}
				}
			delete auth_file_;
			}
			break;
		case 31:
			// Clean up "active_config"
			{
			delete active_config__elem_;
			active_config__elem_ = 0;
			if ( active_config() )
				{
				for ( int i = 0; i < (int) active_config()->size(); ++i )
					{
					Request_Objects * active_config__elem_ = (*active_config_)[i];
					delete active_config__elem_;
					active_config__elem_ = 0;
					}
				}
			delete active_config_;
			}
			break;
		case 32:
			// Clean up "auth_req"
			{
			delete auth_req__elem_;
			auth_req__elem_ = 0;
			if ( auth_req() )
				{
				for ( int i = 0; i < (int) auth_req()->size(); ++i )
					{
					Request_Objects * auth_req__elem_ = (*auth_req_)[i];
					delete auth_req__elem_;
					auth_req__elem_ = 0;
					}
				}
			delete auth_req_;
			}
			break;
		case 33:
			// Clean up "auth_err"
			{
			delete auth_err__elem_;
			auth_err__elem_ = 0;
			if ( auth_err() )
				{
				for ( int i = 0; i < (int) auth_err()->size(); ++i )
					{
					Request_Objects * auth_err__elem_ = (*auth_err_)[i];
					delete auth_err__elem_;
					auth_err__elem_ = 0;
					}
				}
			delete auth_err_;
			}
			break;
		default:
			// Clean up "unknown"
			{
			unknown_.free();
			}
			break;
		}
	}

bool DNP3_Request::ParseBuffer(flow_buffer_t t_flow_buffer, ContextDNP3 * t_context)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	const_byteptr t_begin_of_data = t_flow_buffer->begin();
	const_byteptr t_end_of_data = t_flow_buffer->end();
	switch ( buffering_state_ )
		{
		case 0:
			if ( buffering_state_ == 0 )
				{
				t_flow_buffer->NewFrame(8, false);
				buffering_state_ = 1;
				}
			buffering_state_ = 1;
			break;
		case 1:
			{
			buffering_state_ = 2;
			// Checking out-of-bound for "DNP3_Request:addin_header"
			if ( t_begin_of_data + (8) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("DNP3_Request:addin_header",
					(0) + (8), 
					(t_end_of_data) - (t_begin_of_data));
				}
			// Parse "addin_header"
			addin_header_ = new Header_Block();
			addin_header_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_flow_buffer->GrowFrame(9 + addin_header()->len() - 5 - 1);
			}
			break;
		case 2:
			BINPAC_ASSERT(t_flow_buffer->ready());
			if ( t_flow_buffer->ready() )
				{
				
				// Parse "app_header"
				app_header_ = new DNP3_Application_Request_Header();
				int t_app_header__size;
				t_app_header__size = app_header_->Parse((t_begin_of_data + 8), t_end_of_data, t_context);
				// Evaluate 'let' and 'withinput' fields
				
				const_byteptr const t_dataptr_after_app_header = (t_begin_of_data + 8) + (t_app_header__size);
				BINPAC_ASSERT(t_dataptr_after_app_header <= t_end_of_data);
				// Parse "data"
				int t_data__size;
				data_case_index_ =  ( app_header()->function_code() ) ;
				switch ( data_case_index() )
					{
					case 0:
						// Parse "none_coonfirm"
						{
						// Evaluate 'let' and 'withinput' fields
						t_data__size = 0;
						}
						break;
					case 1:
						// Parse "read_requests"
						{
						int t_read_requests__arraylength;
						t_read_requests__arraylength = 0;
						read_requests__elem_ = 0;
						int t_read_requests__elem__it;
						t_read_requests__elem__it = 0;
						int t_read_requests__size;
						read_requests_ = new vector<Request_Objects *>;
						const_byteptr t_read_requests__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_read_requests__elem__it)
							{
							// Check &until(read_requests__elem__dataptr >= end_of_data)
							if ( t_read_requests__elem__dataptr >= t_end_of_data )
								{
								read_requests__elem_ = 0;
								goto end_of_read_requests;
								}
							read_requests__elem_ = new Request_Objects(app_header()->function_code());
							int t_read_requests__elem__size;
							t_read_requests__elem__size = read_requests__elem_->Parse(t_read_requests__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							read_requests_->push_back(read_requests__elem_);
							t_read_requests__elem__dataptr += t_read_requests__elem__size;
							BINPAC_ASSERT(t_read_requests__elem__dataptr <= t_end_of_data);
							read_requests__elem_ = 0;
							}
					end_of_read_requests: ;
						t_read_requests__size = t_read_requests__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_read_requests__size;
						}
						break;
					case 2:
						// Parse "write_requests"
						{
						int t_write_requests__arraylength;
						t_write_requests__arraylength = 0;
						write_requests__elem_ = 0;
						int t_write_requests__elem__it;
						t_write_requests__elem__it = 0;
						int t_write_requests__size;
						write_requests_ = new vector<Request_Objects *>;
						const_byteptr t_write_requests__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_write_requests__elem__it)
							{
							// Check &until(write_requests__elem__dataptr >= end_of_data)
							if ( t_write_requests__elem__dataptr >= t_end_of_data )
								{
								write_requests__elem_ = 0;
								goto end_of_write_requests;
								}
							write_requests__elem_ = new Request_Objects(app_header()->function_code());
							int t_write_requests__elem__size;
							t_write_requests__elem__size = write_requests__elem_->Parse(t_write_requests__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							write_requests_->push_back(write_requests__elem_);
							t_write_requests__elem__dataptr += t_write_requests__elem__size;
							BINPAC_ASSERT(t_write_requests__elem__dataptr <= t_end_of_data);
							write_requests__elem_ = 0;
							}
					end_of_write_requests: ;
						t_write_requests__size = t_write_requests__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_write_requests__size;
						}
						break;
					case 3:
						// Parse "select_requests"
						{
						int t_select_requests__arraylength;
						t_select_requests__arraylength = 0;
						select_requests__elem_ = 0;
						int t_select_requests__elem__it;
						t_select_requests__elem__it = 0;
						int t_select_requests__size;
						select_requests_ = new vector<Request_Objects *>;
						const_byteptr t_select_requests__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_select_requests__elem__it)
							{
							// Check &until(select_requests__elem__dataptr >= end_of_data)
							if ( t_select_requests__elem__dataptr >= t_end_of_data )
								{
								select_requests__elem_ = 0;
								goto end_of_select_requests;
								}
							select_requests__elem_ = new Request_Objects(app_header()->function_code());
							int t_select_requests__elem__size;
							t_select_requests__elem__size = select_requests__elem_->Parse(t_select_requests__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							select_requests_->push_back(select_requests__elem_);
							t_select_requests__elem__dataptr += t_select_requests__elem__size;
							BINPAC_ASSERT(t_select_requests__elem__dataptr <= t_end_of_data);
							select_requests__elem_ = 0;
							}
					end_of_select_requests: ;
						t_select_requests__size = t_select_requests__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_select_requests__size;
						}
						break;
					case 4:
						// Parse "operate_requests"
						{
						int t_operate_requests__arraylength;
						t_operate_requests__arraylength = 0;
						operate_requests__elem_ = 0;
						int t_operate_requests__elem__it;
						t_operate_requests__elem__it = 0;
						int t_operate_requests__size;
						operate_requests_ = new vector<Request_Objects *>;
						const_byteptr t_operate_requests__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_operate_requests__elem__it)
							{
							// Check &until(operate_requests__elem__dataptr >= end_of_data)
							if ( t_operate_requests__elem__dataptr >= t_end_of_data )
								{
								operate_requests__elem_ = 0;
								goto end_of_operate_requests;
								}
							operate_requests__elem_ = new Request_Objects(app_header()->function_code());
							int t_operate_requests__elem__size;
							t_operate_requests__elem__size = operate_requests__elem_->Parse(t_operate_requests__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							operate_requests_->push_back(operate_requests__elem_);
							t_operate_requests__elem__dataptr += t_operate_requests__elem__size;
							BINPAC_ASSERT(t_operate_requests__elem__dataptr <= t_end_of_data);
							operate_requests__elem_ = 0;
							}
					end_of_operate_requests: ;
						t_operate_requests__size = t_operate_requests__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_operate_requests__size;
						}
						break;
					case 5:
						// Parse "direct_operate_requests"
						{
						int t_direct_operate_requests__arraylength;
						t_direct_operate_requests__arraylength = 0;
						direct_operate_requests__elem_ = 0;
						int t_direct_operate_requests__elem__it;
						t_direct_operate_requests__elem__it = 0;
						int t_direct_operate_requests__size;
						direct_operate_requests_ = new vector<Request_Objects *>;
						const_byteptr t_direct_operate_requests__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_direct_operate_requests__elem__it)
							{
							// Check &until(direct_operate_requests__elem__dataptr >= end_of_data)
							if ( t_direct_operate_requests__elem__dataptr >= t_end_of_data )
								{
								direct_operate_requests__elem_ = 0;
								goto end_of_direct_operate_requests;
								}
							direct_operate_requests__elem_ = new Request_Objects(app_header()->function_code());
							int t_direct_operate_requests__elem__size;
							t_direct_operate_requests__elem__size = direct_operate_requests__elem_->Parse(t_direct_operate_requests__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							direct_operate_requests_->push_back(direct_operate_requests__elem_);
							t_direct_operate_requests__elem__dataptr += t_direct_operate_requests__elem__size;
							BINPAC_ASSERT(t_direct_operate_requests__elem__dataptr <= t_end_of_data);
							direct_operate_requests__elem_ = 0;
							}
					end_of_direct_operate_requests: ;
						t_direct_operate_requests__size = t_direct_operate_requests__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_direct_operate_requests__size;
						}
						break;
					case 6:
						// Parse "direct_operate_nr_requests"
						{
						int t_direct_operate_nr_requests__arraylength;
						t_direct_operate_nr_requests__arraylength = 0;
						direct_operate_nr_requests__elem_ = 0;
						int t_direct_operate_nr_requests__elem__it;
						t_direct_operate_nr_requests__elem__it = 0;
						int t_direct_operate_nr_requests__size;
						direct_operate_nr_requests_ = new vector<Request_Objects *>;
						const_byteptr t_direct_operate_nr_requests__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_direct_operate_nr_requests__elem__it)
							{
							// Check &until(direct_operate_nr_requests__elem__dataptr >= end_of_data)
							if ( t_direct_operate_nr_requests__elem__dataptr >= t_end_of_data )
								{
								direct_operate_nr_requests__elem_ = 0;
								goto end_of_direct_operate_nr_requests;
								}
							direct_operate_nr_requests__elem_ = new Request_Objects(app_header()->function_code());
							int t_direct_operate_nr_requests__elem__size;
							t_direct_operate_nr_requests__elem__size = direct_operate_nr_requests__elem_->Parse(t_direct_operate_nr_requests__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							direct_operate_nr_requests_->push_back(direct_operate_nr_requests__elem_);
							t_direct_operate_nr_requests__elem__dataptr += t_direct_operate_nr_requests__elem__size;
							BINPAC_ASSERT(t_direct_operate_nr_requests__elem__dataptr <= t_end_of_data);
							direct_operate_nr_requests__elem_ = 0;
							}
					end_of_direct_operate_nr_requests: ;
						t_direct_operate_nr_requests__size = t_direct_operate_nr_requests__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_direct_operate_nr_requests__size;
						}
						break;
					case 7:
						// Parse "immed_freeze_requests"
						{
						int t_immed_freeze_requests__arraylength;
						t_immed_freeze_requests__arraylength = 0;
						immed_freeze_requests__elem_ = 0;
						int t_immed_freeze_requests__elem__it;
						t_immed_freeze_requests__elem__it = 0;
						int t_immed_freeze_requests__size;
						immed_freeze_requests_ = new vector<Request_Objects *>;
						const_byteptr t_immed_freeze_requests__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_immed_freeze_requests__elem__it)
							{
							// Check &until(immed_freeze_requests__elem__dataptr >= end_of_data)
							if ( t_immed_freeze_requests__elem__dataptr >= t_end_of_data )
								{
								immed_freeze_requests__elem_ = 0;
								goto end_of_immed_freeze_requests;
								}
							immed_freeze_requests__elem_ = new Request_Objects(app_header()->function_code());
							int t_immed_freeze_requests__elem__size;
							t_immed_freeze_requests__elem__size = immed_freeze_requests__elem_->Parse(t_immed_freeze_requests__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							immed_freeze_requests_->push_back(immed_freeze_requests__elem_);
							t_immed_freeze_requests__elem__dataptr += t_immed_freeze_requests__elem__size;
							BINPAC_ASSERT(t_immed_freeze_requests__elem__dataptr <= t_end_of_data);
							immed_freeze_requests__elem_ = 0;
							}
					end_of_immed_freeze_requests: ;
						t_immed_freeze_requests__size = t_immed_freeze_requests__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_immed_freeze_requests__size;
						}
						break;
					case 8:
						// Parse "immed_freeze_nr_requests"
						{
						int t_immed_freeze_nr_requests__arraylength;
						t_immed_freeze_nr_requests__arraylength = 0;
						immed_freeze_nr_requests__elem_ = 0;
						int t_immed_freeze_nr_requests__elem__it;
						t_immed_freeze_nr_requests__elem__it = 0;
						int t_immed_freeze_nr_requests__size;
						immed_freeze_nr_requests_ = new vector<Request_Objects *>;
						const_byteptr t_immed_freeze_nr_requests__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_immed_freeze_nr_requests__elem__it)
							{
							// Check &until(immed_freeze_nr_requests__elem__dataptr >= end_of_data)
							if ( t_immed_freeze_nr_requests__elem__dataptr >= t_end_of_data )
								{
								immed_freeze_nr_requests__elem_ = 0;
								goto end_of_immed_freeze_nr_requests;
								}
							immed_freeze_nr_requests__elem_ = new Request_Objects(app_header()->function_code());
							int t_immed_freeze_nr_requests__elem__size;
							t_immed_freeze_nr_requests__elem__size = immed_freeze_nr_requests__elem_->Parse(t_immed_freeze_nr_requests__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							immed_freeze_nr_requests_->push_back(immed_freeze_nr_requests__elem_);
							t_immed_freeze_nr_requests__elem__dataptr += t_immed_freeze_nr_requests__elem__size;
							BINPAC_ASSERT(t_immed_freeze_nr_requests__elem__dataptr <= t_end_of_data);
							immed_freeze_nr_requests__elem_ = 0;
							}
					end_of_immed_freeze_nr_requests: ;
						t_immed_freeze_nr_requests__size = t_immed_freeze_nr_requests__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_immed_freeze_nr_requests__size;
						}
						break;
					case 9:
						// Parse "freeze_clear_requests"
						{
						int t_freeze_clear_requests__arraylength;
						t_freeze_clear_requests__arraylength = 0;
						freeze_clear_requests__elem_ = 0;
						int t_freeze_clear_requests__elem__it;
						t_freeze_clear_requests__elem__it = 0;
						int t_freeze_clear_requests__size;
						freeze_clear_requests_ = new vector<Request_Objects *>;
						const_byteptr t_freeze_clear_requests__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_freeze_clear_requests__elem__it)
							{
							// Check &until(freeze_clear_requests__elem__dataptr >= end_of_data)
							if ( t_freeze_clear_requests__elem__dataptr >= t_end_of_data )
								{
								freeze_clear_requests__elem_ = 0;
								goto end_of_freeze_clear_requests;
								}
							freeze_clear_requests__elem_ = new Request_Objects(app_header()->function_code());
							int t_freeze_clear_requests__elem__size;
							t_freeze_clear_requests__elem__size = freeze_clear_requests__elem_->Parse(t_freeze_clear_requests__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							freeze_clear_requests_->push_back(freeze_clear_requests__elem_);
							t_freeze_clear_requests__elem__dataptr += t_freeze_clear_requests__elem__size;
							BINPAC_ASSERT(t_freeze_clear_requests__elem__dataptr <= t_end_of_data);
							freeze_clear_requests__elem_ = 0;
							}
					end_of_freeze_clear_requests: ;
						t_freeze_clear_requests__size = t_freeze_clear_requests__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_freeze_clear_requests__size;
						}
						break;
					case 10:
						// Parse "freeze_clear_nr_requests"
						{
						int t_freeze_clear_nr_requests__arraylength;
						t_freeze_clear_nr_requests__arraylength = 0;
						freeze_clear_nr_requests__elem_ = 0;
						int t_freeze_clear_nr_requests__elem__it;
						t_freeze_clear_nr_requests__elem__it = 0;
						int t_freeze_clear_nr_requests__size;
						freeze_clear_nr_requests_ = new vector<Request_Objects *>;
						const_byteptr t_freeze_clear_nr_requests__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_freeze_clear_nr_requests__elem__it)
							{
							// Check &until(freeze_clear_nr_requests__elem__dataptr >= end_of_data)
							if ( t_freeze_clear_nr_requests__elem__dataptr >= t_end_of_data )
								{
								freeze_clear_nr_requests__elem_ = 0;
								goto end_of_freeze_clear_nr_requests;
								}
							freeze_clear_nr_requests__elem_ = new Request_Objects(app_header()->function_code());
							int t_freeze_clear_nr_requests__elem__size;
							t_freeze_clear_nr_requests__elem__size = freeze_clear_nr_requests__elem_->Parse(t_freeze_clear_nr_requests__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							freeze_clear_nr_requests_->push_back(freeze_clear_nr_requests__elem_);
							t_freeze_clear_nr_requests__elem__dataptr += t_freeze_clear_nr_requests__elem__size;
							BINPAC_ASSERT(t_freeze_clear_nr_requests__elem__dataptr <= t_end_of_data);
							freeze_clear_nr_requests__elem_ = 0;
							}
					end_of_freeze_clear_nr_requests: ;
						t_freeze_clear_nr_requests__size = t_freeze_clear_nr_requests__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_freeze_clear_nr_requests__size;
						}
						break;
					case 11:
						// Parse "freeze_time_requests"
						{
						int t_freeze_time_requests__arraylength;
						t_freeze_time_requests__arraylength = 0;
						freeze_time_requests__elem_ = 0;
						int t_freeze_time_requests__elem__it;
						t_freeze_time_requests__elem__it = 0;
						int t_freeze_time_requests__size;
						freeze_time_requests_ = new vector<Request_Objects *>;
						const_byteptr t_freeze_time_requests__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_freeze_time_requests__elem__it)
							{
							// Check &until(freeze_time_requests__elem__dataptr >= end_of_data)
							if ( t_freeze_time_requests__elem__dataptr >= t_end_of_data )
								{
								freeze_time_requests__elem_ = 0;
								goto end_of_freeze_time_requests;
								}
							freeze_time_requests__elem_ = new Request_Objects(app_header()->function_code());
							int t_freeze_time_requests__elem__size;
							t_freeze_time_requests__elem__size = freeze_time_requests__elem_->Parse(t_freeze_time_requests__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							freeze_time_requests_->push_back(freeze_time_requests__elem_);
							t_freeze_time_requests__elem__dataptr += t_freeze_time_requests__elem__size;
							BINPAC_ASSERT(t_freeze_time_requests__elem__dataptr <= t_end_of_data);
							freeze_time_requests__elem_ = 0;
							}
					end_of_freeze_time_requests: ;
						t_freeze_time_requests__size = t_freeze_time_requests__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_freeze_time_requests__size;
						}
						break;
					case 12:
						// Parse "freeze_time_nr_requests"
						{
						int t_freeze_time_nr_requests__arraylength;
						t_freeze_time_nr_requests__arraylength = 0;
						freeze_time_nr_requests__elem_ = 0;
						int t_freeze_time_nr_requests__elem__it;
						t_freeze_time_nr_requests__elem__it = 0;
						int t_freeze_time_nr_requests__size;
						freeze_time_nr_requests_ = new vector<Request_Objects *>;
						const_byteptr t_freeze_time_nr_requests__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_freeze_time_nr_requests__elem__it)
							{
							// Check &until(freeze_time_nr_requests__elem__dataptr >= end_of_data)
							if ( t_freeze_time_nr_requests__elem__dataptr >= t_end_of_data )
								{
								freeze_time_nr_requests__elem_ = 0;
								goto end_of_freeze_time_nr_requests;
								}
							freeze_time_nr_requests__elem_ = new Request_Objects(app_header()->function_code());
							int t_freeze_time_nr_requests__elem__size;
							t_freeze_time_nr_requests__elem__size = freeze_time_nr_requests__elem_->Parse(t_freeze_time_nr_requests__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							freeze_time_nr_requests_->push_back(freeze_time_nr_requests__elem_);
							t_freeze_time_nr_requests__elem__dataptr += t_freeze_time_nr_requests__elem__size;
							BINPAC_ASSERT(t_freeze_time_nr_requests__elem__dataptr <= t_end_of_data);
							freeze_time_nr_requests__elem_ = 0;
							}
					end_of_freeze_time_nr_requests: ;
						t_freeze_time_nr_requests__size = t_freeze_time_nr_requests__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_freeze_time_nr_requests__size;
						}
						break;
					case 13:
						// Parse "cold_restart"
						{
						// Evaluate 'let' and 'withinput' fields
						t_data__size = 0;
						}
						break;
					case 14:
						// Parse "warm_restart"
						{
						// Evaluate 'let' and 'withinput' fields
						t_data__size = 0;
						}
						break;
					case 15:
						// Parse "initilize_data"
						{
						// Evaluate 'let' and 'withinput' fields
						t_data__size = 0;
						}
						break;
					case 16:
						// Parse "initilize_appl"
						{
						int t_initilize_appl__arraylength;
						t_initilize_appl__arraylength = 0;
						initilize_appl__elem_ = 0;
						int t_initilize_appl__elem__it;
						t_initilize_appl__elem__it = 0;
						int t_initilize_appl__size;
						initilize_appl_ = new vector<Request_Objects *>;
						const_byteptr t_initilize_appl__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_initilize_appl__elem__it)
							{
							// Check &until(initilize_appl__elem__dataptr >= end_of_data)
							if ( t_initilize_appl__elem__dataptr >= t_end_of_data )
								{
								initilize_appl__elem_ = 0;
								goto end_of_initilize_appl;
								}
							initilize_appl__elem_ = new Request_Objects(app_header()->function_code());
							int t_initilize_appl__elem__size;
							t_initilize_appl__elem__size = initilize_appl__elem_->Parse(t_initilize_appl__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							initilize_appl_->push_back(initilize_appl__elem_);
							t_initilize_appl__elem__dataptr += t_initilize_appl__elem__size;
							BINPAC_ASSERT(t_initilize_appl__elem__dataptr <= t_end_of_data);
							initilize_appl__elem_ = 0;
							}
					end_of_initilize_appl: ;
						t_initilize_appl__size = t_initilize_appl__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_initilize_appl__size;
						}
						break;
					case 17:
						// Parse "start_appl"
						{
						int t_start_appl__arraylength;
						t_start_appl__arraylength = 0;
						start_appl__elem_ = 0;
						int t_start_appl__elem__it;
						t_start_appl__elem__it = 0;
						int t_start_appl__size;
						start_appl_ = new vector<Request_Objects *>;
						const_byteptr t_start_appl__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_start_appl__elem__it)
							{
							// Check &until(start_appl__elem__dataptr >= end_of_data)
							if ( t_start_appl__elem__dataptr >= t_end_of_data )
								{
								start_appl__elem_ = 0;
								goto end_of_start_appl;
								}
							start_appl__elem_ = new Request_Objects(app_header()->function_code());
							int t_start_appl__elem__size;
							t_start_appl__elem__size = start_appl__elem_->Parse(t_start_appl__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							start_appl_->push_back(start_appl__elem_);
							t_start_appl__elem__dataptr += t_start_appl__elem__size;
							BINPAC_ASSERT(t_start_appl__elem__dataptr <= t_end_of_data);
							start_appl__elem_ = 0;
							}
					end_of_start_appl: ;
						t_start_appl__size = t_start_appl__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_start_appl__size;
						}
						break;
					case 18:
						// Parse "stop_appl"
						{
						int t_stop_appl__arraylength;
						t_stop_appl__arraylength = 0;
						stop_appl__elem_ = 0;
						int t_stop_appl__elem__it;
						t_stop_appl__elem__it = 0;
						int t_stop_appl__size;
						stop_appl_ = new vector<Request_Objects *>;
						const_byteptr t_stop_appl__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_stop_appl__elem__it)
							{
							// Check &until(stop_appl__elem__dataptr >= end_of_data)
							if ( t_stop_appl__elem__dataptr >= t_end_of_data )
								{
								stop_appl__elem_ = 0;
								goto end_of_stop_appl;
								}
							stop_appl__elem_ = new Request_Objects(app_header()->function_code());
							int t_stop_appl__elem__size;
							t_stop_appl__elem__size = stop_appl__elem_->Parse(t_stop_appl__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							stop_appl_->push_back(stop_appl__elem_);
							t_stop_appl__elem__dataptr += t_stop_appl__elem__size;
							BINPAC_ASSERT(t_stop_appl__elem__dataptr <= t_end_of_data);
							stop_appl__elem_ = 0;
							}
					end_of_stop_appl: ;
						t_stop_appl__size = t_stop_appl__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_stop_appl__size;
						}
						break;
					case 19:
						// Parse "save_config"
						{
						// Evaluate 'let' and 'withinput' fields
						t_data__size = 0;
						}
						break;
					case 20:
						// Parse "enable_unsolicited"
						{
						int t_enable_unsolicited__arraylength;
						t_enable_unsolicited__arraylength = 0;
						enable_unsolicited__elem_ = 0;
						int t_enable_unsolicited__elem__it;
						t_enable_unsolicited__elem__it = 0;
						int t_enable_unsolicited__size;
						enable_unsolicited_ = new vector<Request_Objects *>;
						const_byteptr t_enable_unsolicited__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_enable_unsolicited__elem__it)
							{
							// Check &until(enable_unsolicited__elem__dataptr >= end_of_data)
							if ( t_enable_unsolicited__elem__dataptr >= t_end_of_data )
								{
								enable_unsolicited__elem_ = 0;
								goto end_of_enable_unsolicited;
								}
							enable_unsolicited__elem_ = new Request_Objects(app_header()->function_code());
							int t_enable_unsolicited__elem__size;
							t_enable_unsolicited__elem__size = enable_unsolicited__elem_->Parse(t_enable_unsolicited__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							enable_unsolicited_->push_back(enable_unsolicited__elem_);
							t_enable_unsolicited__elem__dataptr += t_enable_unsolicited__elem__size;
							BINPAC_ASSERT(t_enable_unsolicited__elem__dataptr <= t_end_of_data);
							enable_unsolicited__elem_ = 0;
							}
					end_of_enable_unsolicited: ;
						t_enable_unsolicited__size = t_enable_unsolicited__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_enable_unsolicited__size;
						}
						break;
					case 21:
						// Parse "disable_unsolicited"
						{
						int t_disable_unsolicited__arraylength;
						t_disable_unsolicited__arraylength = 0;
						disable_unsolicited__elem_ = 0;
						int t_disable_unsolicited__elem__it;
						t_disable_unsolicited__elem__it = 0;
						int t_disable_unsolicited__size;
						disable_unsolicited_ = new vector<Request_Objects *>;
						const_byteptr t_disable_unsolicited__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_disable_unsolicited__elem__it)
							{
							// Check &until(disable_unsolicited__elem__dataptr >= end_of_data)
							if ( t_disable_unsolicited__elem__dataptr >= t_end_of_data )
								{
								disable_unsolicited__elem_ = 0;
								goto end_of_disable_unsolicited;
								}
							disable_unsolicited__elem_ = new Request_Objects(app_header()->function_code());
							int t_disable_unsolicited__elem__size;
							t_disable_unsolicited__elem__size = disable_unsolicited__elem_->Parse(t_disable_unsolicited__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							disable_unsolicited_->push_back(disable_unsolicited__elem_);
							t_disable_unsolicited__elem__dataptr += t_disable_unsolicited__elem__size;
							BINPAC_ASSERT(t_disable_unsolicited__elem__dataptr <= t_end_of_data);
							disable_unsolicited__elem_ = 0;
							}
					end_of_disable_unsolicited: ;
						t_disable_unsolicited__size = t_disable_unsolicited__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_disable_unsolicited__size;
						}
						break;
					case 22:
						// Parse "assign_class"
						{
						int t_assign_class__arraylength;
						t_assign_class__arraylength = 0;
						assign_class__elem_ = 0;
						int t_assign_class__elem__it;
						t_assign_class__elem__it = 0;
						int t_assign_class__size;
						assign_class_ = new vector<Request_Objects *>;
						const_byteptr t_assign_class__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_assign_class__elem__it)
							{
							// Check &until(assign_class__elem__dataptr >= end_of_data)
							if ( t_assign_class__elem__dataptr >= t_end_of_data )
								{
								assign_class__elem_ = 0;
								goto end_of_assign_class;
								}
							assign_class__elem_ = new Request_Objects(app_header()->function_code());
							int t_assign_class__elem__size;
							t_assign_class__elem__size = assign_class__elem_->Parse(t_assign_class__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							assign_class_->push_back(assign_class__elem_);
							t_assign_class__elem__dataptr += t_assign_class__elem__size;
							BINPAC_ASSERT(t_assign_class__elem__dataptr <= t_end_of_data);
							assign_class__elem_ = 0;
							}
					end_of_assign_class: ;
						t_assign_class__size = t_assign_class__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_assign_class__size;
						}
						break;
					case 23:
						// Parse "delay_measure"
						{
						// Evaluate 'let' and 'withinput' fields
						t_data__size = 0;
						}
						break;
					case 24:
						// Parse "record_cur_time"
						{
						// Evaluate 'let' and 'withinput' fields
						t_data__size = 0;
						}
						break;
					case 25:
						// Parse "open_file"
						{
						int t_open_file__arraylength;
						t_open_file__arraylength = 0;
						open_file__elem_ = 0;
						int t_open_file__elem__it;
						t_open_file__elem__it = 0;
						int t_open_file__size;
						open_file_ = new vector<Request_Objects *>;
						const_byteptr t_open_file__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_open_file__elem__it)
							{
							// Check &until(open_file__elem__dataptr >= end_of_data)
							if ( t_open_file__elem__dataptr >= t_end_of_data )
								{
								open_file__elem_ = 0;
								goto end_of_open_file;
								}
							open_file__elem_ = new Request_Objects(app_header()->function_code());
							int t_open_file__elem__size;
							t_open_file__elem__size = open_file__elem_->Parse(t_open_file__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							open_file_->push_back(open_file__elem_);
							t_open_file__elem__dataptr += t_open_file__elem__size;
							BINPAC_ASSERT(t_open_file__elem__dataptr <= t_end_of_data);
							open_file__elem_ = 0;
							}
					end_of_open_file: ;
						t_open_file__size = t_open_file__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_open_file__size;
						}
						break;
					case 26:
						// Parse "close_file"
						{
						int t_close_file__arraylength;
						t_close_file__arraylength = 0;
						close_file__elem_ = 0;
						int t_close_file__elem__it;
						t_close_file__elem__it = 0;
						int t_close_file__size;
						close_file_ = new vector<Request_Objects *>;
						const_byteptr t_close_file__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_close_file__elem__it)
							{
							// Check &until(close_file__elem__dataptr >= end_of_data)
							if ( t_close_file__elem__dataptr >= t_end_of_data )
								{
								close_file__elem_ = 0;
								goto end_of_close_file;
								}
							close_file__elem_ = new Request_Objects(app_header()->function_code());
							int t_close_file__elem__size;
							t_close_file__elem__size = close_file__elem_->Parse(t_close_file__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							close_file_->push_back(close_file__elem_);
							t_close_file__elem__dataptr += t_close_file__elem__size;
							BINPAC_ASSERT(t_close_file__elem__dataptr <= t_end_of_data);
							close_file__elem_ = 0;
							}
					end_of_close_file: ;
						t_close_file__size = t_close_file__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_close_file__size;
						}
						break;
					case 27:
						// Parse "delete_file"
						{
						int t_delete_file__arraylength;
						t_delete_file__arraylength = 0;
						delete_file__elem_ = 0;
						int t_delete_file__elem__it;
						t_delete_file__elem__it = 0;
						int t_delete_file__size;
						delete_file_ = new vector<Request_Objects *>;
						const_byteptr t_delete_file__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_delete_file__elem__it)
							{
							// Check &until(delete_file__elem__dataptr >= end_of_data)
							if ( t_delete_file__elem__dataptr >= t_end_of_data )
								{
								delete_file__elem_ = 0;
								goto end_of_delete_file;
								}
							delete_file__elem_ = new Request_Objects(app_header()->function_code());
							int t_delete_file__elem__size;
							t_delete_file__elem__size = delete_file__elem_->Parse(t_delete_file__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							delete_file_->push_back(delete_file__elem_);
							t_delete_file__elem__dataptr += t_delete_file__elem__size;
							BINPAC_ASSERT(t_delete_file__elem__dataptr <= t_end_of_data);
							delete_file__elem_ = 0;
							}
					end_of_delete_file: ;
						t_delete_file__size = t_delete_file__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_delete_file__size;
						}
						break;
					case 30:
						// Parse "abort_file"
						{
						int t_abort_file__arraylength;
						t_abort_file__arraylength = 0;
						abort_file__elem_ = 0;
						int t_abort_file__elem__it;
						t_abort_file__elem__it = 0;
						int t_abort_file__size;
						abort_file_ = new vector<Request_Objects *>;
						const_byteptr t_abort_file__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_abort_file__elem__it)
							{
							// Check &until(abort_file__elem__dataptr >= end_of_data)
							if ( t_abort_file__elem__dataptr >= t_end_of_data )
								{
								abort_file__elem_ = 0;
								goto end_of_abort_file;
								}
							abort_file__elem_ = new Request_Objects(app_header()->function_code());
							int t_abort_file__elem__size;
							t_abort_file__elem__size = abort_file__elem_->Parse(t_abort_file__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							abort_file_->push_back(abort_file__elem_);
							t_abort_file__elem__dataptr += t_abort_file__elem__size;
							BINPAC_ASSERT(t_abort_file__elem__dataptr <= t_end_of_data);
							abort_file__elem_ = 0;
							}
					end_of_abort_file: ;
						t_abort_file__size = t_abort_file__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_abort_file__size;
						}
						break;
					case 28:
						// Parse "get_file_info"
						{
						int t_get_file_info__arraylength;
						t_get_file_info__arraylength = 0;
						get_file_info__elem_ = 0;
						int t_get_file_info__elem__it;
						t_get_file_info__elem__it = 0;
						int t_get_file_info__size;
						get_file_info_ = new vector<Request_Objects *>;
						const_byteptr t_get_file_info__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_get_file_info__elem__it)
							{
							// Check &until(get_file_info__elem__dataptr >= end_of_data)
							if ( t_get_file_info__elem__dataptr >= t_end_of_data )
								{
								get_file_info__elem_ = 0;
								goto end_of_get_file_info;
								}
							get_file_info__elem_ = new Request_Objects(app_header()->function_code());
							int t_get_file_info__elem__size;
							t_get_file_info__elem__size = get_file_info__elem_->Parse(t_get_file_info__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							get_file_info_->push_back(get_file_info__elem_);
							t_get_file_info__elem__dataptr += t_get_file_info__elem__size;
							BINPAC_ASSERT(t_get_file_info__elem__dataptr <= t_end_of_data);
							get_file_info__elem_ = 0;
							}
					end_of_get_file_info: ;
						t_get_file_info__size = t_get_file_info__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_get_file_info__size;
						}
						break;
					case 29:
						// Parse "auth_file"
						{
						int t_auth_file__arraylength;
						t_auth_file__arraylength = 0;
						auth_file__elem_ = 0;
						int t_auth_file__elem__it;
						t_auth_file__elem__it = 0;
						int t_auth_file__size;
						auth_file_ = new vector<Request_Objects *>;
						const_byteptr t_auth_file__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_auth_file__elem__it)
							{
							// Check &until(auth_file__elem__dataptr >= end_of_data)
							if ( t_auth_file__elem__dataptr >= t_end_of_data )
								{
								auth_file__elem_ = 0;
								goto end_of_auth_file;
								}
							auth_file__elem_ = new Request_Objects(app_header()->function_code());
							int t_auth_file__elem__size;
							t_auth_file__elem__size = auth_file__elem_->Parse(t_auth_file__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							auth_file_->push_back(auth_file__elem_);
							t_auth_file__elem__dataptr += t_auth_file__elem__size;
							BINPAC_ASSERT(t_auth_file__elem__dataptr <= t_end_of_data);
							auth_file__elem_ = 0;
							}
					end_of_auth_file: ;
						t_auth_file__size = t_auth_file__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_auth_file__size;
						}
						break;
					case 31:
						// Parse "active_config"
						{
						int t_active_config__arraylength;
						t_active_config__arraylength = 0;
						active_config__elem_ = 0;
						int t_active_config__elem__it;
						t_active_config__elem__it = 0;
						int t_active_config__size;
						active_config_ = new vector<Request_Objects *>;
						const_byteptr t_active_config__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_active_config__elem__it)
							{
							// Check &until(active_config__elem__dataptr >= end_of_data)
							if ( t_active_config__elem__dataptr >= t_end_of_data )
								{
								active_config__elem_ = 0;
								goto end_of_active_config;
								}
							active_config__elem_ = new Request_Objects(app_header()->function_code());
							int t_active_config__elem__size;
							t_active_config__elem__size = active_config__elem_->Parse(t_active_config__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							active_config_->push_back(active_config__elem_);
							t_active_config__elem__dataptr += t_active_config__elem__size;
							BINPAC_ASSERT(t_active_config__elem__dataptr <= t_end_of_data);
							active_config__elem_ = 0;
							}
					end_of_active_config: ;
						t_active_config__size = t_active_config__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_active_config__size;
						}
						break;
					case 32:
						// Parse "auth_req"
						{
						int t_auth_req__arraylength;
						t_auth_req__arraylength = 0;
						auth_req__elem_ = 0;
						int t_auth_req__elem__it;
						t_auth_req__elem__it = 0;
						int t_auth_req__size;
						auth_req_ = new vector<Request_Objects *>;
						const_byteptr t_auth_req__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_auth_req__elem__it)
							{
							// Check &until(auth_req__elem__dataptr >= end_of_data)
							if ( t_auth_req__elem__dataptr >= t_end_of_data )
								{
								auth_req__elem_ = 0;
								goto end_of_auth_req;
								}
							auth_req__elem_ = new Request_Objects(app_header()->function_code());
							int t_auth_req__elem__size;
							t_auth_req__elem__size = auth_req__elem_->Parse(t_auth_req__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							auth_req_->push_back(auth_req__elem_);
							t_auth_req__elem__dataptr += t_auth_req__elem__size;
							BINPAC_ASSERT(t_auth_req__elem__dataptr <= t_end_of_data);
							auth_req__elem_ = 0;
							}
					end_of_auth_req: ;
						t_auth_req__size = t_auth_req__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_auth_req__size;
						}
						break;
					case 33:
						// Parse "auth_err"
						{
						int t_auth_err__arraylength;
						t_auth_err__arraylength = 0;
						auth_err__elem_ = 0;
						int t_auth_err__elem__it;
						t_auth_err__elem__it = 0;
						int t_auth_err__size;
						auth_err_ = new vector<Request_Objects *>;
						const_byteptr t_auth_err__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_auth_err__elem__it)
							{
							// Check &until(auth_err__elem__dataptr >= end_of_data)
							if ( t_auth_err__elem__dataptr >= t_end_of_data )
								{
								auth_err__elem_ = 0;
								goto end_of_auth_err;
								}
							auth_err__elem_ = new Request_Objects(app_header()->function_code());
							int t_auth_err__elem__size;
							t_auth_err__elem__size = auth_err__elem_->Parse(t_auth_err__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							auth_err_->push_back(auth_err__elem_);
							t_auth_err__elem__dataptr += t_auth_err__elem__size;
							BINPAC_ASSERT(t_auth_err__elem__dataptr <= t_end_of_data);
							auth_err__elem_ = 0;
							}
					end_of_auth_err: ;
						t_auth_err__size = t_auth_err__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_auth_err__size;
						}
						break;
					default:
						// Parse "unknown"
						{
						int t_unknown_string_length;
						t_unknown_string_length = (t_end_of_data) - (t_dataptr_after_app_header);
						int t_unknown__size;
						t_unknown__size = t_unknown_string_length;
						// check for negative sizes
						if ( t_unknown_string_length < 0 )
						throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-protocol.pac:56", t_unknown_string_length);
						unknown_.init(t_dataptr_after_app_header, t_unknown_string_length);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_unknown__size;
						}
						break;
					}
				// Evaluate 'let' and 'withinput' fields
				
				t_val_parsing_complete = true;
				if ( t_val_parsing_complete )
					{
					// Evaluate 'let' and 'withinput' fields
					}
				BINPAC_ASSERT(t_val_parsing_complete);
				buffering_state_ = 0;
				}
			break;
		default:
			BINPAC_ASSERT(buffering_state_ <= 2);
			break;
		}
	return t_val_parsing_complete;
	}

Debug_Byte::Debug_Byte()
	{
	process_request_ = 0;
	}

Debug_Byte::~Debug_Byte()
	{
	debug_.free();
	}

int Debug_Byte::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Parse "debug"
	int t_debug_string_length;
	t_debug_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_debug__size;
	t_debug__size = t_debug_string_length;
	// check for negative sizes
	if ( t_debug_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-protocol.pac:62", t_debug_string_length);
	debug_.init(t_begin_of_data, t_debug_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_Debug_Byte__size;
	const_byteptr const t_dataptr_after_debug = t_begin_of_data + (t_debug__size);
	BINPAC_ASSERT(t_dataptr_after_debug <= t_end_of_data);
	t_Debug_Byte__size = t_dataptr_after_debug - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_debug_byte(debug());
	BINPAC_ASSERT(t_begin_of_data + (t_Debug_Byte__size) <= t_end_of_data);
	return t_Debug_Byte__size;
	}

DNP3_Response::DNP3_Response()
	{
	addin_header_ = 0;
	app_header_ = 0;
	data_case_index_ = -1;
	response_objects_ = 0;
	response_objects__elem_ = 0;
	unsolicited_response_objects_ = 0;
	unsolicited_response_objects__elem_ = 0;
	auth_response_ = 0;
	auth_response__elem_ = 0;
	unknown_ = 0;
	byteorder_ = bigendian;
	buffering_state_ = 0;
	buffering_state_ = 0;
	}

DNP3_Response::~DNP3_Response()
	{
	delete addin_header_;
	addin_header_ = 0;
	delete app_header_;
	app_header_ = 0;
	switch ( data_case_index() )
		{
		case 129:
			// Clean up "response_objects"
			{
			delete response_objects__elem_;
			response_objects__elem_ = 0;
			if ( response_objects() )
				{
				for ( int i = 0; i < (int) response_objects()->size(); ++i )
					{
					Response_Objects * response_objects__elem_ = (*response_objects_)[i];
					delete response_objects__elem_;
					response_objects__elem_ = 0;
					}
				}
			delete response_objects_;
			}
			break;
		case 130:
			// Clean up "unsolicited_response_objects"
			{
			delete unsolicited_response_objects__elem_;
			unsolicited_response_objects__elem_ = 0;
			if ( unsolicited_response_objects() )
				{
				for ( int i = 0; i < (int) unsolicited_response_objects()->size(); ++i )
					{
					Response_Objects * unsolicited_response_objects__elem_ = (*unsolicited_response_objects_)[i];
					delete unsolicited_response_objects__elem_;
					unsolicited_response_objects__elem_ = 0;
					}
				}
			delete unsolicited_response_objects_;
			}
			break;
		case 131:
			// Clean up "auth_response"
			{
			delete auth_response__elem_;
			auth_response__elem_ = 0;
			if ( auth_response() )
				{
				for ( int i = 0; i < (int) auth_response()->size(); ++i )
					{
					Response_Objects * auth_response__elem_ = (*auth_response_)[i];
					delete auth_response__elem_;
					auth_response__elem_ = 0;
					}
				}
			delete auth_response_;
			}
			break;
		default:
			// Clean up "unknown"
			{
			delete unknown_;
			unknown_ = 0;
			}
			break;
		}
	}

bool DNP3_Response::ParseBuffer(flow_buffer_t t_flow_buffer, ContextDNP3 * t_context)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	const_byteptr t_begin_of_data = t_flow_buffer->begin();
	const_byteptr t_end_of_data = t_flow_buffer->end();
	switch ( buffering_state_ )
		{
		case 0:
			if ( buffering_state_ == 0 )
				{
				t_flow_buffer->NewFrame(8, false);
				buffering_state_ = 1;
				}
			buffering_state_ = 1;
			break;
		case 1:
			{
			buffering_state_ = 2;
			// Checking out-of-bound for "DNP3_Response:addin_header"
			if ( t_begin_of_data + (8) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("DNP3_Response:addin_header",
					(0) + (8), 
					(t_end_of_data) - (t_begin_of_data));
				}
			// Parse "addin_header"
			addin_header_ = new Header_Block();
			addin_header_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_flow_buffer->GrowFrame(9 + addin_header()->len() - 5 - 1);
			}
			break;
		case 2:
			BINPAC_ASSERT(t_flow_buffer->ready());
			if ( t_flow_buffer->ready() )
				{
				
				// Parse "app_header"
				app_header_ = new DNP3_Application_Response_Header();
				int t_app_header__size;
				t_app_header__size = app_header_->Parse((t_begin_of_data + 8), t_end_of_data, t_context, byteorder());
				// Evaluate 'let' and 'withinput' fields
				
				const_byteptr const t_dataptr_after_app_header = (t_begin_of_data + 8) + (t_app_header__size);
				BINPAC_ASSERT(t_dataptr_after_app_header <= t_end_of_data);
				// Parse "data"
				int t_data__size;
				data_case_index_ =  ( app_header()->function_code() ) ;
				switch ( data_case_index() )
					{
					case 129:
						// Parse "response_objects"
						{
						int t_response_objects__arraylength;
						t_response_objects__arraylength = 0;
						response_objects__elem_ = 0;
						int t_response_objects__elem__it;
						t_response_objects__elem__it = 0;
						int t_response_objects__size;
						response_objects_ = new vector<Response_Objects *>;
						const_byteptr t_response_objects__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_response_objects__elem__it)
							{
							// Check &until(response_objects__elem__dataptr >= end_of_data)
							if ( t_response_objects__elem__dataptr >= t_end_of_data )
								{
								response_objects__elem_ = 0;
								goto end_of_response_objects;
								}
							response_objects__elem_ = new Response_Objects(app_header()->function_code());
							int t_response_objects__elem__size;
							t_response_objects__elem__size = response_objects__elem_->Parse(t_response_objects__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							response_objects_->push_back(response_objects__elem_);
							t_response_objects__elem__dataptr += t_response_objects__elem__size;
							BINPAC_ASSERT(t_response_objects__elem__dataptr <= t_end_of_data);
							response_objects__elem_ = 0;
							}
					end_of_response_objects: ;
						t_response_objects__size = t_response_objects__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_response_objects__size;
						}
						break;
					case 130:
						// Parse "unsolicited_response_objects"
						{
						int t_unsolicited_response_objects__arraylength;
						t_unsolicited_response_objects__arraylength = 0;
						unsolicited_response_objects__elem_ = 0;
						int t_unsolicited_response_objects__elem__it;
						t_unsolicited_response_objects__elem__it = 0;
						int t_unsolicited_response_objects__size;
						unsolicited_response_objects_ = new vector<Response_Objects *>;
						const_byteptr t_unsolicited_response_objects__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_unsolicited_response_objects__elem__it)
							{
							// Check &until(unsolicited_response_objects__elem__dataptr >= end_of_data)
							if ( t_unsolicited_response_objects__elem__dataptr >= t_end_of_data )
								{
								unsolicited_response_objects__elem_ = 0;
								goto end_of_unsolicited_response_objects;
								}
							unsolicited_response_objects__elem_ = new Response_Objects(app_header()->function_code());
							int t_unsolicited_response_objects__elem__size;
							t_unsolicited_response_objects__elem__size = unsolicited_response_objects__elem_->Parse(t_unsolicited_response_objects__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							unsolicited_response_objects_->push_back(unsolicited_response_objects__elem_);
							t_unsolicited_response_objects__elem__dataptr += t_unsolicited_response_objects__elem__size;
							BINPAC_ASSERT(t_unsolicited_response_objects__elem__dataptr <= t_end_of_data);
							unsolicited_response_objects__elem_ = 0;
							}
					end_of_unsolicited_response_objects: ;
						t_unsolicited_response_objects__size = t_unsolicited_response_objects__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_unsolicited_response_objects__size;
						}
						break;
					case 131:
						// Parse "auth_response"
						{
						int t_auth_response__arraylength;
						t_auth_response__arraylength = 0;
						auth_response__elem_ = 0;
						int t_auth_response__elem__it;
						t_auth_response__elem__it = 0;
						int t_auth_response__size;
						auth_response_ = new vector<Response_Objects *>;
						const_byteptr t_auth_response__elem__dataptr = t_dataptr_after_app_header;
						for (; /* forever */; ++t_auth_response__elem__it)
							{
							// Check &until(auth_response__elem__dataptr >= end_of_data)
							if ( t_auth_response__elem__dataptr >= t_end_of_data )
								{
								auth_response__elem_ = 0;
								goto end_of_auth_response;
								}
							auth_response__elem_ = new Response_Objects(app_header()->function_code());
							int t_auth_response__elem__size;
							t_auth_response__elem__size = auth_response__elem_->Parse(t_auth_response__elem__dataptr, t_end_of_data, t_context, byteorder());
							// Evaluate 'let' and 'withinput' fields
							auth_response_->push_back(auth_response__elem_);
							t_auth_response__elem__dataptr += t_auth_response__elem__size;
							BINPAC_ASSERT(t_auth_response__elem__dataptr <= t_end_of_data);
							auth_response__elem_ = 0;
							}
					end_of_auth_response: ;
						t_auth_response__size = t_auth_response__elem__dataptr - (t_dataptr_after_app_header);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_auth_response__size;
						}
						break;
					default:
						// Parse "unknown"
						{
						unknown_ = new Debug_Byte();
						int t_unknown__size;
						t_unknown__size = unknown_->Parse(t_dataptr_after_app_header, t_end_of_data, t_context);
						// Evaluate 'let' and 'withinput' fields
						t_data__size = t_unknown__size;
						}
						break;
					}
				// Evaluate 'let' and 'withinput' fields
				
				t_val_parsing_complete = true;
				if ( t_val_parsing_complete )
					{
					// Evaluate 'let' and 'withinput' fields
					}
				BINPAC_ASSERT(t_val_parsing_complete);
				buffering_state_ = 0;
				}
			break;
		default:
			BINPAC_ASSERT(buffering_state_ <= 2);
			break;
		}
	return t_val_parsing_complete;
	}

DNP3_Application_Request_Header::DNP3_Application_Request_Header()
	{
	application_control_ = 0;
	function_code_ = 0;
	process_request_ = 0;
	}

DNP3_Application_Request_Header::~DNP3_Application_Request_Header()
	{
	empty_.free();
	}

int DNP3_Application_Request_Header::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "DNP3_Application_Request_Header"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DNP3_Application_Request_Header",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + 2;
	// Parse "empty"
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + 0;
	int t_empty_string_length;
	t_empty_string_length = 0;
	int t_empty__size;
	t_empty__size = t_empty_string_length;
	empty_.init(t_begin_of_data, t_empty_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_empty = t_begin_of_data + (0);
	BINPAC_ASSERT(t_dataptr_after_empty <= t_end_of_data);
	// Parse "application_control"
	application_control_ = *((uint8 const *) (t_dataptr_after_empty));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "function_code"
	function_code_ = *((uint8 const *) ((t_dataptr_after_empty + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	int t_DNP3_Application_Request_Header__size;
	t_DNP3_Application_Request_Header__size = (t_dataptr_after_empty + 2) - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_application_request_header(function_code());
	}
	BINPAC_ASSERT(t_begin_of_data + (2) <= t_end_of_data);
	return 2;
	}

DNP3_Application_Response_Header::DNP3_Application_Response_Header()
	{
	application_control_ = 0;
	function_code_ = 0;
	internal_indications_ = 0;
	process_request_ = 0;
	}

DNP3_Application_Response_Header::~DNP3_Application_Response_Header()
	{
	empty_.free();
	}

int DNP3_Application_Response_Header::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "DNP3_Application_Response_Header"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DNP3_Application_Response_Header",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + 4;
	// Parse "empty"
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + 0;
	int t_empty_string_length;
	t_empty_string_length = 0;
	int t_empty__size;
	t_empty__size = t_empty_string_length;
	empty_.init(t_begin_of_data, t_empty_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_empty = t_begin_of_data + (0);
	BINPAC_ASSERT(t_dataptr_after_empty <= t_end_of_data);
	// Parse "application_control"
	application_control_ = *((uint8 const *) (t_dataptr_after_empty));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "function_code"
	function_code_ = *((uint8 const *) ((t_dataptr_after_empty + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "internal_indications"
	internal_indications_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_dataptr_after_empty + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	int t_DNP3_Application_Response_Header__size;
	t_DNP3_Application_Response_Header__size = (t_dataptr_after_empty + 4) - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_application_response_header(function_code(), internal_indications());
	}
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

Request_Objects::Request_Objects(uint8 function_code)
	{
	object_header_ = 0;
	data_case_index_ = -1;
	bocmd_PM_ = 0;
	bocmd_PM__elem_ = 0;
	time_interval_ojbects_ = 0;
	time_interval_ojbects__elem_ = 0;
	ojbects_ = 0;
	ojbects__elem_ = 0;
	dump_data_case_index_ = -1;
	function_code_ = function_code;
	}

Request_Objects::~Request_Objects()
	{
	delete object_header_;
	object_header_ = 0;
	switch ( data_case_index() )
		{
		case 3075:
			// Clean up "bocmd_PM"
			{
			delete bocmd_PM__elem_;
			bocmd_PM__elem_ = 0;
			if ( bocmd_PM() )
				{
				for ( int i = 0; i < (int) bocmd_PM()->size(); ++i )
					{
					Request_Data_Object * bocmd_PM__elem_ = (*bocmd_PM_)[i];
					delete bocmd_PM__elem_;
					bocmd_PM__elem_ = 0;
					}
				}
			delete bocmd_PM_;
			}
			break;
		case 12802:
			// Clean up "time_interval_ojbects"
			{
			delete time_interval_ojbects__elem_;
			time_interval_ojbects__elem_ = 0;
			if ( time_interval_ojbects() )
				{
				for ( int i = 0; i < (int) time_interval_ojbects()->size(); ++i )
					{
					Request_Data_Object * time_interval_ojbects__elem_ = (*time_interval_ojbects_)[i];
					delete time_interval_ojbects__elem_;
					time_interval_ojbects__elem_ = 0;
					}
				}
			delete time_interval_ojbects_;
			}
			break;
		default:
			// Clean up "ojbects"
			{
			delete ojbects__elem_;
			ojbects__elem_ = 0;
			if ( ojbects() )
				{
				for ( int i = 0; i < (int) ojbects()->size(); ++i )
					{
					Request_Data_Object * ojbects__elem_ = (*ojbects_)[i];
					delete ojbects__elem_;
					ojbects__elem_ = 0;
					}
				}
			delete ojbects_;
			}
			break;
		}
	switch ( dump_data_case_index() )
		{
		case 25:
			// Clean up "open_file_dump"
			{
			}
			break;
		case 26:
			// Clean up "close_file_dump"
			{
			}
			break;
		case 27:
			// Clean up "delete_file_dump"
			{
			}
			break;
		case 30:
			// Clean up "abort_file_dump"
			{
			}
			break;
		case 28:
			// Clean up "get_file_info"
			{
			}
			break;
		case 29:
			// Clean up "auth_file"
			{
			}
			break;
		case 31:
			// Clean up "active_config"
			{
			}
			break;
		default:
			// Clean up "default_dump"
			{
			}
			break;
		}
	}

int Request_Objects::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context, int t_byteorder)
	{
	// Parse "object_header"
	object_header_ = new Object_Header(function_code());
	int t_object_header__size;
	t_object_header__size = object_header_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_object_header = t_begin_of_data + (t_object_header__size);
	BINPAC_ASSERT(t_dataptr_after_object_header <= t_end_of_data);
	// Parse "data"
	int t_data__size;
	data_case_index_ =  ( object_header()->object_type_field() ) ;
	switch ( data_case_index() )
		{
		case 3075:
			// Parse "bocmd_PM"
			{
			int t_bocmd_PM__arraylength;
			t_bocmd_PM__arraylength = 0;
			t_bocmd_PM__arraylength =  ( object_header()->number_of_item() / 8 )  + 1;
			if ( t_begin_of_data + t_bocmd_PM__arraylength > t_end_of_data + 1 )
				{
				t_bocmd_PM__arraylength = t_end_of_data - t_begin_of_data + 1;
				}
			if ( t_bocmd_PM__arraylength < 0 )
				{
				t_bocmd_PM__arraylength = 0;
				}
			bocmd_PM__elem_ = 0;
			int t_bocmd_PM__elem__it;
			t_bocmd_PM__elem__it = 0;
			int t_bocmd_PM__size;
			bocmd_PM_ = new vector<Request_Data_Object *>;
			bocmd_PM_->reserve(t_bocmd_PM__arraylength);
			const_byteptr t_bocmd_PM__elem__dataptr = t_dataptr_after_object_header;
			for (; t_bocmd_PM__elem__it < t_bocmd_PM__arraylength; ++t_bocmd_PM__elem__it)
				{
				// Check &until(bocmd_PM__elem__dataptr >= end_of_data)
				if ( t_bocmd_PM__elem__dataptr >= t_end_of_data )
					{
					bocmd_PM__elem_ = 0;
					goto end_of_bocmd_PM;
					}
				bocmd_PM__elem_ = new Request_Data_Object(function_code(), object_header()->qualifier_field(), object_header()->object_type_field());
				int t_bocmd_PM__elem__size;
				t_bocmd_PM__elem__size = bocmd_PM__elem_->Parse(t_bocmd_PM__elem__dataptr, t_end_of_data, t_context, t_byteorder);
				// Evaluate 'let' and 'withinput' fields
				bocmd_PM_->push_back(bocmd_PM__elem_);
				t_bocmd_PM__elem__dataptr += t_bocmd_PM__elem__size;
				BINPAC_ASSERT(t_bocmd_PM__elem__dataptr <= t_end_of_data);
				bocmd_PM__elem_ = 0;
				}
		end_of_bocmd_PM: ;
			t_bocmd_PM__size = t_bocmd_PM__elem__dataptr - (t_dataptr_after_object_header);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_bocmd_PM__size;
			}
			break;
		case 12802:
			// Parse "time_interval_ojbects"
			{
			int t_time_interval_ojbects__arraylength;
			t_time_interval_ojbects__arraylength = 0;
			t_time_interval_ojbects__arraylength = object_header()->number_of_item();
			if ( t_begin_of_data + t_time_interval_ojbects__arraylength > t_end_of_data + 1 )
				{
				t_time_interval_ojbects__arraylength = t_end_of_data - t_begin_of_data + 1;
				}
			if ( t_time_interval_ojbects__arraylength < 0 )
				{
				t_time_interval_ojbects__arraylength = 0;
				}
			time_interval_ojbects__elem_ = 0;
			int t_time_interval_ojbects__elem__it;
			t_time_interval_ojbects__elem__it = 0;
			int t_time_interval_ojbects__size;
			time_interval_ojbects_ = new vector<Request_Data_Object *>;
			time_interval_ojbects_->reserve(t_time_interval_ojbects__arraylength);
			const_byteptr t_time_interval_ojbects__elem__dataptr = t_dataptr_after_object_header;
			for (; t_time_interval_ojbects__elem__it < t_time_interval_ojbects__arraylength; ++t_time_interval_ojbects__elem__it)
				{
				// Check &until(time_interval_ojbects__elem__dataptr >= end_of_data)
				if ( t_time_interval_ojbects__elem__dataptr >= t_end_of_data )
					{
					time_interval_ojbects__elem_ = 0;
					goto end_of_time_interval_ojbects;
					}
				time_interval_ojbects__elem_ = new Request_Data_Object(function_code(), object_header()->qualifier_field(), object_header()->object_type_field());
				int t_time_interval_ojbects__elem__size;
				t_time_interval_ojbects__elem__size = time_interval_ojbects__elem_->Parse(t_time_interval_ojbects__elem__dataptr, t_end_of_data, t_context, t_byteorder);
				// Evaluate 'let' and 'withinput' fields
				time_interval_ojbects_->push_back(time_interval_ojbects__elem_);
				t_time_interval_ojbects__elem__dataptr += t_time_interval_ojbects__elem__size;
				BINPAC_ASSERT(t_time_interval_ojbects__elem__dataptr <= t_end_of_data);
				time_interval_ojbects__elem_ = 0;
				}
		end_of_time_interval_ojbects: ;
			t_time_interval_ojbects__size = t_time_interval_ojbects__elem__dataptr - (t_dataptr_after_object_header);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_time_interval_ojbects__size;
			}
			break;
		default:
			// Parse "ojbects"
			{
			int t_ojbects__arraylength;
			t_ojbects__arraylength = 0;
			t_ojbects__arraylength = object_header()->number_of_item();
			if ( t_begin_of_data + t_ojbects__arraylength > t_end_of_data + 1 )
				{
				t_ojbects__arraylength = t_end_of_data - t_begin_of_data + 1;
				}
			if ( t_ojbects__arraylength < 0 )
				{
				t_ojbects__arraylength = 0;
				}
			ojbects__elem_ = 0;
			int t_ojbects__elem__it;
			t_ojbects__elem__it = 0;
			int t_ojbects__size;
			ojbects_ = new vector<Request_Data_Object *>;
			ojbects_->reserve(t_ojbects__arraylength);
			const_byteptr t_ojbects__elem__dataptr = t_dataptr_after_object_header;
			for (; t_ojbects__elem__it < t_ojbects__arraylength; ++t_ojbects__elem__it)
				{
				// Check &until(ojbects__elem__dataptr >= end_of_data)
				if ( t_ojbects__elem__dataptr >= t_end_of_data )
					{
					ojbects__elem_ = 0;
					goto end_of_ojbects;
					}
				ojbects__elem_ = new Request_Data_Object(function_code(), object_header()->qualifier_field(), object_header()->object_type_field());
				int t_ojbects__elem__size;
				t_ojbects__elem__size = ojbects__elem_->Parse(t_ojbects__elem__dataptr, t_end_of_data, t_context, t_byteorder);
				// Evaluate 'let' and 'withinput' fields
				ojbects_->push_back(ojbects__elem_);
				t_ojbects__elem__dataptr += t_ojbects__elem__size;
				BINPAC_ASSERT(t_ojbects__elem__dataptr <= t_end_of_data);
				ojbects__elem_ = 0;
				}
		end_of_ojbects: ;
			t_ojbects__size = t_ojbects__elem__dataptr - (t_dataptr_after_object_header);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_ojbects__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_data = t_dataptr_after_object_header + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	// Checking out-of-bound for "Request_Objects:dump_data"
	if ( t_dataptr_after_data + (0) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Request_Objects:dump_data",
			((t_dataptr_after_data - t_begin_of_data)) + (0), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "dump_data"
	dump_data_case_index_ =  ( function_code() ) ;
	switch ( dump_data_case_index() )
		{
		case 25:
			// Parse "open_file_dump"
			{
			// Evaluate 'let' and 'withinput' fields
			}
			break;
		case 26:
			// Parse "close_file_dump"
			{
			// Evaluate 'let' and 'withinput' fields
			}
			break;
		case 27:
			// Parse "delete_file_dump"
			{
			// Evaluate 'let' and 'withinput' fields
			}
			break;
		case 30:
			// Parse "abort_file_dump"
			{
			// Evaluate 'let' and 'withinput' fields
			}
			break;
		case 28:
			// Parse "get_file_info"
			{
			// Evaluate 'let' and 'withinput' fields
			}
			break;
		case 29:
			// Parse "auth_file"
			{
			// Evaluate 'let' and 'withinput' fields
			}
			break;
		case 31:
			// Parse "active_config"
			{
			// Evaluate 'let' and 'withinput' fields
			}
			break;
		default:
			// Parse "default_dump"
			{
			// Evaluate 'let' and 'withinput' fields
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_Request_Objects__size;
	t_Request_Objects__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Request_Objects__size) <= t_end_of_data);
	return t_Request_Objects__size;
	}

Response_Objects::Response_Objects(uint8 function_code)
	{
	object_header_ = 0;
	data_case_index_ = -1;
	biwoflag_ = 0;
	biwoflag__elem_ = 0;
	diwoflag_ = 0;
	diwoflag__elem_ = 0;
	bowoflag_ = 0;
	bowoflag__elem_ = 0;
	bocmd_PM_ = 0;
	bocmd_PM__elem_ = 0;
	ojbects_ = 0;
	ojbects__elem_ = 0;
	function_code_ = function_code;
	}

Response_Objects::~Response_Objects()
	{
	delete object_header_;
	object_header_ = 0;
	switch ( data_case_index() )
		{
		case 257:
			// Clean up "biwoflag"
			{
			delete biwoflag__elem_;
			biwoflag__elem_ = 0;
			if ( biwoflag() )
				{
				for ( int i = 0; i < (int) biwoflag()->size(); ++i )
					{
					Response_Data_Object * biwoflag__elem_ = (*biwoflag_)[i];
					delete biwoflag__elem_;
					biwoflag__elem_ = 0;
					}
				}
			delete biwoflag_;
			}
			break;
		case 769:
			// Clean up "diwoflag"
			{
			delete diwoflag__elem_;
			diwoflag__elem_ = 0;
			if ( diwoflag() )
				{
				for ( int i = 0; i < (int) diwoflag()->size(); ++i )
					{
					Response_Data_Object * diwoflag__elem_ = (*diwoflag_)[i];
					delete diwoflag__elem_;
					diwoflag__elem_ = 0;
					}
				}
			delete diwoflag_;
			}
			break;
		case 2561:
			// Clean up "bowoflag"
			{
			delete bowoflag__elem_;
			bowoflag__elem_ = 0;
			if ( bowoflag() )
				{
				for ( int i = 0; i < (int) bowoflag()->size(); ++i )
					{
					Response_Data_Object * bowoflag__elem_ = (*bowoflag_)[i];
					delete bowoflag__elem_;
					bowoflag__elem_ = 0;
					}
				}
			delete bowoflag_;
			}
			break;
		case 3075:
			// Clean up "bocmd_PM"
			{
			delete bocmd_PM__elem_;
			bocmd_PM__elem_ = 0;
			if ( bocmd_PM() )
				{
				for ( int i = 0; i < (int) bocmd_PM()->size(); ++i )
					{
					Response_Data_Object * bocmd_PM__elem_ = (*bocmd_PM_)[i];
					delete bocmd_PM__elem_;
					bocmd_PM__elem_ = 0;
					}
				}
			delete bocmd_PM_;
			}
			break;
		default:
			// Clean up "ojbects"
			{
			delete ojbects__elem_;
			ojbects__elem_ = 0;
			if ( ojbects() )
				{
				for ( int i = 0; i < (int) ojbects()->size(); ++i )
					{
					Response_Data_Object * ojbects__elem_ = (*ojbects_)[i];
					delete ojbects__elem_;
					ojbects__elem_ = 0;
					}
				}
			delete ojbects_;
			}
			break;
		}
	}

int Response_Objects::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context, int t_byteorder)
	{
	// Parse "object_header"
	object_header_ = new Object_Header(function_code());
	int t_object_header__size;
	t_object_header__size = object_header_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_object_header = t_begin_of_data + (t_object_header__size);
	BINPAC_ASSERT(t_dataptr_after_object_header <= t_end_of_data);
	// Parse "data"
	int t_data__size;
	data_case_index_ =  ( object_header()->object_type_field() ) ;
	switch ( data_case_index() )
		{
		case 257:
			// Parse "biwoflag"
			{
			int t_biwoflag__arraylength;
			t_biwoflag__arraylength = 0;
			t_biwoflag__arraylength =  ( object_header()->number_of_item() / 8 )  + 1;
			if ( t_begin_of_data + t_biwoflag__arraylength > t_end_of_data + 1 )
				{
				t_biwoflag__arraylength = t_end_of_data - t_begin_of_data + 1;
				}
			if ( t_biwoflag__arraylength < 0 )
				{
				t_biwoflag__arraylength = 0;
				}
			biwoflag__elem_ = 0;
			int t_biwoflag__elem__it;
			t_biwoflag__elem__it = 0;
			int t_biwoflag__size;
			biwoflag_ = new vector<Response_Data_Object *>;
			biwoflag_->reserve(t_biwoflag__arraylength);
			const_byteptr t_biwoflag__elem__dataptr = t_dataptr_after_object_header;
			for (; t_biwoflag__elem__it < t_biwoflag__arraylength; ++t_biwoflag__elem__it)
				{
				// Check &until(biwoflag__elem__dataptr >= end_of_data)
				if ( t_biwoflag__elem__dataptr >= t_end_of_data )
					{
					biwoflag__elem_ = 0;
					goto end_of_biwoflag;
					}
				biwoflag__elem_ = new Response_Data_Object(function_code(), object_header()->qualifier_field(), object_header()->object_type_field());
				int t_biwoflag__elem__size;
				t_biwoflag__elem__size = biwoflag__elem_->Parse(t_biwoflag__elem__dataptr, t_end_of_data, t_context, t_byteorder);
				// Evaluate 'let' and 'withinput' fields
				biwoflag_->push_back(biwoflag__elem_);
				t_biwoflag__elem__dataptr += t_biwoflag__elem__size;
				BINPAC_ASSERT(t_biwoflag__elem__dataptr <= t_end_of_data);
				biwoflag__elem_ = 0;
				}
		end_of_biwoflag: ;
			t_biwoflag__size = t_biwoflag__elem__dataptr - (t_dataptr_after_object_header);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_biwoflag__size;
			}
			break;
		case 769:
			// Parse "diwoflag"
			{
			int t_diwoflag__arraylength;
			t_diwoflag__arraylength = 0;
			t_diwoflag__arraylength =  ( object_header()->number_of_item() / 8 )  + 1;
			if ( t_begin_of_data + t_diwoflag__arraylength > t_end_of_data + 1 )
				{
				t_diwoflag__arraylength = t_end_of_data - t_begin_of_data + 1;
				}
			if ( t_diwoflag__arraylength < 0 )
				{
				t_diwoflag__arraylength = 0;
				}
			diwoflag__elem_ = 0;
			int t_diwoflag__elem__it;
			t_diwoflag__elem__it = 0;
			int t_diwoflag__size;
			diwoflag_ = new vector<Response_Data_Object *>;
			diwoflag_->reserve(t_diwoflag__arraylength);
			const_byteptr t_diwoflag__elem__dataptr = t_dataptr_after_object_header;
			for (; t_diwoflag__elem__it < t_diwoflag__arraylength; ++t_diwoflag__elem__it)
				{
				// Check &until(diwoflag__elem__dataptr >= end_of_data)
				if ( t_diwoflag__elem__dataptr >= t_end_of_data )
					{
					diwoflag__elem_ = 0;
					goto end_of_diwoflag;
					}
				diwoflag__elem_ = new Response_Data_Object(function_code(), object_header()->qualifier_field(), object_header()->object_type_field());
				int t_diwoflag__elem__size;
				t_diwoflag__elem__size = diwoflag__elem_->Parse(t_diwoflag__elem__dataptr, t_end_of_data, t_context, t_byteorder);
				// Evaluate 'let' and 'withinput' fields
				diwoflag_->push_back(diwoflag__elem_);
				t_diwoflag__elem__dataptr += t_diwoflag__elem__size;
				BINPAC_ASSERT(t_diwoflag__elem__dataptr <= t_end_of_data);
				diwoflag__elem_ = 0;
				}
		end_of_diwoflag: ;
			t_diwoflag__size = t_diwoflag__elem__dataptr - (t_dataptr_after_object_header);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_diwoflag__size;
			}
			break;
		case 2561:
			// Parse "bowoflag"
			{
			int t_bowoflag__arraylength;
			t_bowoflag__arraylength = 0;
			t_bowoflag__arraylength =  ( object_header()->number_of_item() / 8 )  + 1;
			if ( t_begin_of_data + t_bowoflag__arraylength > t_end_of_data + 1 )
				{
				t_bowoflag__arraylength = t_end_of_data - t_begin_of_data + 1;
				}
			if ( t_bowoflag__arraylength < 0 )
				{
				t_bowoflag__arraylength = 0;
				}
			bowoflag__elem_ = 0;
			int t_bowoflag__elem__it;
			t_bowoflag__elem__it = 0;
			int t_bowoflag__size;
			bowoflag_ = new vector<Response_Data_Object *>;
			bowoflag_->reserve(t_bowoflag__arraylength);
			const_byteptr t_bowoflag__elem__dataptr = t_dataptr_after_object_header;
			for (; t_bowoflag__elem__it < t_bowoflag__arraylength; ++t_bowoflag__elem__it)
				{
				// Check &until(bowoflag__elem__dataptr >= end_of_data)
				if ( t_bowoflag__elem__dataptr >= t_end_of_data )
					{
					bowoflag__elem_ = 0;
					goto end_of_bowoflag;
					}
				bowoflag__elem_ = new Response_Data_Object(function_code(), object_header()->qualifier_field(), object_header()->object_type_field());
				int t_bowoflag__elem__size;
				t_bowoflag__elem__size = bowoflag__elem_->Parse(t_bowoflag__elem__dataptr, t_end_of_data, t_context, t_byteorder);
				// Evaluate 'let' and 'withinput' fields
				bowoflag_->push_back(bowoflag__elem_);
				t_bowoflag__elem__dataptr += t_bowoflag__elem__size;
				BINPAC_ASSERT(t_bowoflag__elem__dataptr <= t_end_of_data);
				bowoflag__elem_ = 0;
				}
		end_of_bowoflag: ;
			t_bowoflag__size = t_bowoflag__elem__dataptr - (t_dataptr_after_object_header);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_bowoflag__size;
			}
			break;
		case 3075:
			// Parse "bocmd_PM"
			{
			int t_bocmd_PM__arraylength;
			t_bocmd_PM__arraylength = 0;
			t_bocmd_PM__arraylength =  ( object_header()->number_of_item() / 8 )  + 1;
			if ( t_begin_of_data + t_bocmd_PM__arraylength > t_end_of_data + 1 )
				{
				t_bocmd_PM__arraylength = t_end_of_data - t_begin_of_data + 1;
				}
			if ( t_bocmd_PM__arraylength < 0 )
				{
				t_bocmd_PM__arraylength = 0;
				}
			bocmd_PM__elem_ = 0;
			int t_bocmd_PM__elem__it;
			t_bocmd_PM__elem__it = 0;
			int t_bocmd_PM__size;
			bocmd_PM_ = new vector<Response_Data_Object *>;
			bocmd_PM_->reserve(t_bocmd_PM__arraylength);
			const_byteptr t_bocmd_PM__elem__dataptr = t_dataptr_after_object_header;
			for (; t_bocmd_PM__elem__it < t_bocmd_PM__arraylength; ++t_bocmd_PM__elem__it)
				{
				// Check &until(bocmd_PM__elem__dataptr >= end_of_data)
				if ( t_bocmd_PM__elem__dataptr >= t_end_of_data )
					{
					bocmd_PM__elem_ = 0;
					goto end_of_bocmd_PM;
					}
				bocmd_PM__elem_ = new Response_Data_Object(function_code(), object_header()->qualifier_field(), object_header()->object_type_field());
				int t_bocmd_PM__elem__size;
				t_bocmd_PM__elem__size = bocmd_PM__elem_->Parse(t_bocmd_PM__elem__dataptr, t_end_of_data, t_context, t_byteorder);
				// Evaluate 'let' and 'withinput' fields
				bocmd_PM_->push_back(bocmd_PM__elem_);
				t_bocmd_PM__elem__dataptr += t_bocmd_PM__elem__size;
				BINPAC_ASSERT(t_bocmd_PM__elem__dataptr <= t_end_of_data);
				bocmd_PM__elem_ = 0;
				}
		end_of_bocmd_PM: ;
			t_bocmd_PM__size = t_bocmd_PM__elem__dataptr - (t_dataptr_after_object_header);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_bocmd_PM__size;
			}
			break;
		default:
			// Parse "ojbects"
			{
			int t_ojbects__arraylength;
			t_ojbects__arraylength = 0;
			t_ojbects__arraylength = object_header()->number_of_item();
			if ( t_begin_of_data + t_ojbects__arraylength > t_end_of_data + 1 )
				{
				t_ojbects__arraylength = t_end_of_data - t_begin_of_data + 1;
				}
			if ( t_ojbects__arraylength < 0 )
				{
				t_ojbects__arraylength = 0;
				}
			ojbects__elem_ = 0;
			int t_ojbects__elem__it;
			t_ojbects__elem__it = 0;
			int t_ojbects__size;
			ojbects_ = new vector<Response_Data_Object *>;
			ojbects_->reserve(t_ojbects__arraylength);
			const_byteptr t_ojbects__elem__dataptr = t_dataptr_after_object_header;
			for (; t_ojbects__elem__it < t_ojbects__arraylength; ++t_ojbects__elem__it)
				{
				// Check &until(ojbects__elem__dataptr >= end_of_data)
				if ( t_ojbects__elem__dataptr >= t_end_of_data )
					{
					ojbects__elem_ = 0;
					goto end_of_ojbects;
					}
				ojbects__elem_ = new Response_Data_Object(function_code(), object_header()->qualifier_field(), object_header()->object_type_field());
				int t_ojbects__elem__size;
				t_ojbects__elem__size = ojbects__elem_->Parse(t_ojbects__elem__dataptr, t_end_of_data, t_context, t_byteorder);
				// Evaluate 'let' and 'withinput' fields
				ojbects_->push_back(ojbects__elem_);
				t_ojbects__elem__dataptr += t_ojbects__elem__size;
				BINPAC_ASSERT(t_ojbects__elem__dataptr <= t_end_of_data);
				ojbects__elem_ = 0;
				}
		end_of_ojbects: ;
			t_ojbects__size = t_ojbects__elem__dataptr - (t_dataptr_after_object_header);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_ojbects__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_Response_Objects__size;
	const_byteptr const t_dataptr_after_data = t_dataptr_after_object_header + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_Response_Objects__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Response_Objects__size) <= t_end_of_data);
	return t_Response_Objects__size;
	}

Object_Header::Object_Header(uint8 function_code)
	{
	object_type_field_ = 0;
	qualifier_field_ = 0;
	range_field_case_index_ = -1;
	range_field_0_ = 0;
	range_field_1_ = 0;
	range_field_2_ = 0;
	range_field_3_ = 0;
	range_field_4_ = 0;
	range_field_5_ = 0;
	range_field_7_ = 0;
	range_field_8_ = 0;
	range_field_9_ = 0;
	range_field_b_ = 0;
	dump_data_case_index_ = -1;
	function_code_ = function_code;
	number_of_item_ = 0;
	rf_value_low_ = 0;
	rf_value_high_ = 0;
	process_request_ = 0;
	}

Object_Header::~Object_Header()
	{
	switch ( range_field_case_index() )
		{
		case 0:
			// Clean up "range_field_0"
			{
			delete range_field_0_;
			range_field_0_ = 0;
			}
			break;
		case 1:
			// Clean up "range_field_1"
			{
			delete range_field_1_;
			range_field_1_ = 0;
			}
			break;
		case 2:
			// Clean up "range_field_2"
			{
			delete range_field_2_;
			range_field_2_ = 0;
			}
			break;
		case 3:
			// Clean up "range_field_3"
			{
			delete range_field_3_;
			range_field_3_ = 0;
			}
			break;
		case 4:
			// Clean up "range_field_4"
			{
			delete range_field_4_;
			range_field_4_ = 0;
			}
			break;
		case 5:
			// Clean up "range_field_5"
			{
			delete range_field_5_;
			range_field_5_ = 0;
			}
			break;
		case 6:
			// Clean up "range_field_6"
			{
			}
			break;
		case 7:
			// Clean up "range_field_7"
			{
			}
			break;
		case 8:
			// Clean up "range_field_8"
			{
			}
			break;
		case 9:
			// Clean up "range_field_9"
			{
			}
			break;
		case 11:
			// Clean up "range_field_b"
			{
			}
			break;
		default:
			// Clean up "unknown"
			{
			unknown_.free();
			}
			break;
		}
	switch ( dump_data_case_index() )
		{
		case 15360:
			// Clean up "dump_3c"
			{
			}
			break;
		default:
			// Clean up "dump_def"
			{
			}
			break;
		}
	}

int Object_Header::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "Object_Header:qualifier_field"
	if ( (t_begin_of_data + 2) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Object_Header:qualifier_field",
			(2) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "object_type_field"
	object_type_field_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "qualifier_field"
	qualifier_field_ = *((uint8 const *) ((t_begin_of_data + 2)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "range_field"
	int t_range_field__size;
	range_field_case_index_ =  ( qualifier_field() & 0x0f ) ;
	switch ( range_field_case_index() )
		{
		case 0:
			// Parse "range_field_0"
			{
			range_field_0_ = new Range_Field_0();
			range_field_0_->Parse((t_begin_of_data + 3), t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 2;
			}
			break;
		case 1:
			// Parse "range_field_1"
			{
			range_field_1_ = new Range_Field_1();
			range_field_1_->Parse((t_begin_of_data + 3), t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 4;
			}
			break;
		case 2:
			// Parse "range_field_2"
			{
			range_field_2_ = new Range_Field_2();
			range_field_2_->Parse((t_begin_of_data + 3), t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 8;
			}
			break;
		case 3:
			// Parse "range_field_3"
			{
			range_field_3_ = new Range_Field_3();
			range_field_3_->Parse((t_begin_of_data + 3), t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 2;
			}
			break;
		case 4:
			// Parse "range_field_4"
			{
			range_field_4_ = new Range_Field_4();
			range_field_4_->Parse((t_begin_of_data + 3), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 4;
			}
			break;
		case 5:
			// Parse "range_field_5"
			{
			range_field_5_ = new Range_Field_5();
			range_field_5_->Parse((t_begin_of_data + 3), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 8;
			}
			break;
		case 6:
			// Parse "range_field_6"
			{
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 0;
			}
			break;
		case 7:
			// Parse "range_field_7"
			{
			// Checking out-of-bound for "Object_Header:range_field_7"
			if ( (t_begin_of_data + 3) + (1) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Object_Header:range_field_7",
					(3) + (1), 
					(t_end_of_data) - (t_begin_of_data));
				}
			range_field_7_ = *((uint8 const *) ((t_begin_of_data + 3)));
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 1;
			}
			break;
		case 8:
			// Parse "range_field_8"
			{
			// Checking out-of-bound for "Object_Header:range_field_8"
			if ( (t_begin_of_data + 3) + (2) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Object_Header:range_field_8",
					(3) + (2), 
					(t_end_of_data) - (t_begin_of_data));
				}
			range_field_8_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 3))));
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 2;
			}
			break;
		case 9:
			// Parse "range_field_9"
			{
			// Checking out-of-bound for "Object_Header:range_field_9"
			if ( (t_begin_of_data + 3) + (4) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Object_Header:range_field_9",
					(3) + (4), 
					(t_end_of_data) - (t_begin_of_data));
				}
			range_field_9_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 3))));
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 4;
			}
			break;
		case 11:
			// Parse "range_field_b"
			{
			// Checking out-of-bound for "Object_Header:range_field_b"
			if ( (t_begin_of_data + 3) + (1) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Object_Header:range_field_b",
					(3) + (1), 
					(t_end_of_data) - (t_begin_of_data));
				}
			range_field_b_ = *((uint8 const *) ((t_begin_of_data + 3)));
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 1;
			}
			break;
		default:
			// Parse "unknown"
			{
			int t_unknown_string_length;
			t_unknown_string_length = (t_end_of_data) - ((t_begin_of_data + 3));
			int t_unknown__size;
			t_unknown__size = t_unknown_string_length;
			// check for negative sizes
			if ( t_unknown_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-protocol.pac:138", t_unknown_string_length);
			unknown_.init((t_begin_of_data + 3), t_unknown_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = t_unknown__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_range_field = (t_begin_of_data + 3) + (t_range_field__size);
	BINPAC_ASSERT(t_dataptr_after_range_field <= t_end_of_data);
	// Checking out-of-bound for "Object_Header:dump_data"
	if ( t_dataptr_after_range_field + (0) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Object_Header:dump_data",
			((t_dataptr_after_range_field - t_begin_of_data)) + (0), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "dump_data"
	dump_data_case_index_ =  ( object_type_field() & 0xff00 ) ;
	switch ( dump_data_case_index() )
		{
		case 15360:
			// Parse "dump_3c"
			{
			// Evaluate 'let' and 'withinput' fields
			}
			break;
		default:
			// Parse "dump_def"
			{
			// Evaluate 'let' and 'withinput' fields
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_Object_Header__size;
	t_Object_Header__size = t_dataptr_after_range_field - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	int t_t_var_001;
	switch (  ( qualifier_field() & 0x0f )  )
		{
		case 0:
			t_t_var_001 =  ( range_field_0()->stop_index() - range_field_0()->start_index() + 1 ) ;
			break;
		case 1:
			t_t_var_001 =  ( range_field_1()->stop_index() - range_field_1()->start_index() + 1 ) ;
			break;
		case 2:
			t_t_var_001 =  ( range_field_2()->stop_index() - range_field_2()->start_index() + 1 ) ;
			break;
		case 7:
			t_t_var_001 = range_field_7();
			break;
		case 8:
			t_t_var_001 =  ( range_field_8() & 0x0ff )  * 0x100 +  ( range_field_8() / 0x100 ) ;
			break;
		case 9:
			t_t_var_001 =  ( range_field_9() & 0x000000ff )  * 0x1000000 +  ( range_field_9() & 0x0000ff00 )  * 0x100 +  ( range_field_9() & 0x00ff0000 )  / 0x100 +  ( range_field_9() & 0xff000000 )  / 0x1000000;
			break;
		case 11:
			t_t_var_001 = range_field_b();
			break;
		default:
			t_t_var_001 = 0;
			break;
		}
	number_of_item_ = t_t_var_001;
	int t_t_var_002;
	switch (  ( qualifier_field() & 0x0f )  )
		{
		case 0:
			t_t_var_002 = 0 + range_field_0()->start_index();
			break;
		case 1:
			t_t_var_002 = range_field_1()->start_index();
			break;
		case 2:
			t_t_var_002 = range_field_2()->start_index();
			break;
		case 3:
			t_t_var_002 = range_field_3()->start_addr();
			break;
		case 4:
			t_t_var_002 = range_field_4()->start_addr();
			break;
		case 5:
			t_t_var_002 = range_field_5()->start_addr();
			break;
		case 6:
			t_t_var_002 = 0xffff;
			break;
		case 7:
			t_t_var_002 = range_field_7();
			break;
		case 8:
			t_t_var_002 = range_field_8();
			break;
		case 9:
			t_t_var_002 = range_field_9();
			break;
		case 11:
			t_t_var_002 = range_field_b();
			break;
		default:
			t_t_var_002 = 0;
			break;
		}
	rf_value_low_ = t_t_var_002;
	int t_t_var_003;
	switch (  ( qualifier_field() & 0x0f )  )
		{
		case 0:
			t_t_var_003 = 0 + range_field_0()->stop_index();
			break;
		case 1:
			t_t_var_003 = range_field_1()->stop_index();
			break;
		case 2:
			t_t_var_003 = range_field_2()->stop_index();
			break;
		case 3:
			t_t_var_003 = range_field_3()->stop_addr();
			break;
		case 4:
			t_t_var_003 = range_field_4()->stop_addr();
			break;
		case 5:
			t_t_var_003 = range_field_5()->stop_addr();
			break;
		case 6:
			t_t_var_003 = 0xffff;
			break;
		default:
			t_t_var_003 = 0;
			break;
		}
	rf_value_high_ = t_t_var_003;
	process_request_ = t_context->flow()->get_dnp3_object_header(object_type_field(), qualifier_field(), number_of_item(), rf_value_low(), rf_value_high());
	BINPAC_ASSERT(t_begin_of_data + (t_Object_Header__size) <= t_end_of_data);
	return t_Object_Header__size;
	}

Range_Field_0::Range_Field_0()
	{
	start_index_ = 0;
	stop_index_ = 0;
	}

Range_Field_0::~Range_Field_0()
	{
	}

int Range_Field_0::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Range_Field_0"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Range_Field_0",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start_index"
	start_index_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "stop_index"
	stop_index_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (2) <= t_end_of_data);
	return 2;
	}

Range_Field_1::Range_Field_1()
	{
	start_index_ = 0;
	stop_index_ = 0;
	byteorder_ = littleendian;
	}

Range_Field_1::~Range_Field_1()
	{
	}

int Range_Field_1::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Range_Field_1"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Range_Field_1",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start_index"
	start_index_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "stop_index"
	stop_index_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

Range_Field_2::Range_Field_2()
	{
	start_index_ = 0;
	stop_index_ = 0;
	byteorder_ = littleendian;
	}

Range_Field_2::~Range_Field_2()
	{
	}

int Range_Field_2::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Range_Field_2"
	if ( t_begin_of_data + (8) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Range_Field_2",
			(0) + (8), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start_index"
	start_index_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "stop_index"
	stop_index_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (8) <= t_end_of_data);
	return 8;
	}

Range_Field_3::Range_Field_3()
	{
	start_addr_ = 0;
	stop_addr_ = 0;
	}

Range_Field_3::~Range_Field_3()
	{
	}

int Range_Field_3::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Range_Field_3"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Range_Field_3",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start_addr"
	start_addr_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "stop_addr"
	stop_addr_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (2) <= t_end_of_data);
	return 2;
	}

Range_Field_4::Range_Field_4()
	{
	start_addr_ = 0;
	stop_addr_ = 0;
	}

Range_Field_4::~Range_Field_4()
	{
	}

int Range_Field_4::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "Range_Field_4"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Range_Field_4",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start_addr"
	start_addr_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "stop_addr"
	stop_addr_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

Range_Field_5::Range_Field_5()
	{
	start_addr_ = 0;
	stop_addr_ = 0;
	}

Range_Field_5::~Range_Field_5()
	{
	}

int Range_Field_5::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "Range_Field_5"
	if ( t_begin_of_data + (8) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Range_Field_5",
			(0) + (8), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start_addr"
	start_addr_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "stop_addr"
	stop_addr_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (8) <= t_end_of_data);
	return 8;
	}

Prefix_Type::Prefix_Type(uint8 qualifier_field)
	{
	prefix_case_index_ = -1;
	prefix8_ = 0;
	prefix16_ = 0;
	prefix32_ = 0;
	object_size8_ = 0;
	object_size16_ = 0;
	object_size32_ = 0;
	qualifier_field_ = qualifier_field;
	byteorder_ = littleendian;
	prefix_value_ = 0;
	prefix_called_ = 0;
	}

Prefix_Type::~Prefix_Type()
	{
	switch ( prefix_case_index() )
		{
		case 0:
			// Clean up "none"
			{
			}
			break;
		case 16:
			// Clean up "prefix8"
			{
			}
			break;
		case 32:
			// Clean up "prefix16"
			{
			}
			break;
		case 48:
			// Clean up "prefix32"
			{
			}
			break;
		case 64:
			// Clean up "object_size8"
			{
			}
			break;
		case 80:
			// Clean up "object_size16"
			{
			}
			break;
		case 96:
			// Clean up "object_size32"
			{
			}
			break;
		default:
			// Clean up "unknownprefix"
			{
			}
			break;
		}
	}

int Prefix_Type::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Parse "prefix"
	int t_prefix__size;
	prefix_case_index_ =  ( qualifier_field() & 0xf0 ) ;
	switch ( prefix_case_index() )
		{
		case 0:
			// Parse "none"
			{
			// Evaluate 'let' and 'withinput' fields
			t_prefix__size = 0;
			}
			break;
		case 16:
			// Parse "prefix8"
			{
			// Checking out-of-bound for "Prefix_Type:prefix8"
			if ( t_begin_of_data + (1) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Prefix_Type:prefix8",
					(0) + (1), 
					(t_end_of_data) - (t_begin_of_data));
				}
			prefix8_ = *((uint8 const *) (t_begin_of_data));
			// Evaluate 'let' and 'withinput' fields
			t_prefix__size = 1;
			}
			break;
		case 32:
			// Parse "prefix16"
			{
			// Checking out-of-bound for "Prefix_Type:prefix16"
			if ( t_begin_of_data + (2) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Prefix_Type:prefix16",
					(0) + (2), 
					(t_end_of_data) - (t_begin_of_data));
				}
			prefix16_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
			// Evaluate 'let' and 'withinput' fields
			t_prefix__size = 2;
			}
			break;
		case 48:
			// Parse "prefix32"
			{
			// Checking out-of-bound for "Prefix_Type:prefix32"
			if ( t_begin_of_data + (4) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Prefix_Type:prefix32",
					(0) + (4), 
					(t_end_of_data) - (t_begin_of_data));
				}
			prefix32_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
			// Evaluate 'let' and 'withinput' fields
			t_prefix__size = 4;
			}
			break;
		case 64:
			// Parse "object_size8"
			{
			// Checking out-of-bound for "Prefix_Type:object_size8"
			if ( t_begin_of_data + (1) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Prefix_Type:object_size8",
					(0) + (1), 
					(t_end_of_data) - (t_begin_of_data));
				}
			object_size8_ = *((uint8 const *) (t_begin_of_data));
			// Evaluate 'let' and 'withinput' fields
			t_prefix__size = 1;
			}
			break;
		case 80:
			// Parse "object_size16"
			{
			// Checking out-of-bound for "Prefix_Type:object_size16"
			if ( t_begin_of_data + (2) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Prefix_Type:object_size16",
					(0) + (2), 
					(t_end_of_data) - (t_begin_of_data));
				}
			object_size16_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
			// Evaluate 'let' and 'withinput' fields
			t_prefix__size = 2;
			}
			break;
		case 96:
			// Parse "object_size32"
			{
			// Checking out-of-bound for "Prefix_Type:object_size32"
			if ( t_begin_of_data + (4) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Prefix_Type:object_size32",
					(0) + (4), 
					(t_end_of_data) - (t_begin_of_data));
				}
			object_size32_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
			// Evaluate 'let' and 'withinput' fields
			t_prefix__size = 4;
			}
			break;
		default:
			// Parse "unknownprefix"
			{
			// Evaluate 'let' and 'withinput' fields
			t_prefix__size = 0;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_Prefix_Type__size;
	const_byteptr const t_dataptr_after_prefix = t_begin_of_data + (t_prefix__size);
	BINPAC_ASSERT(t_dataptr_after_prefix <= t_end_of_data);
	t_Prefix_Type__size = t_dataptr_after_prefix - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	int t_t_var_004;
	switch (  ( qualifier_field() & 0xf0 )  )
		{
		case 0:
			t_t_var_004 = 0;
			break;
		case 16:
			t_t_var_004 = prefix8();
			break;
		case 32:
			t_t_var_004 = prefix16();
			break;
		case 48:
			t_t_var_004 = prefix32();
			break;
		case 64:
			t_t_var_004 = object_size8();
			break;
		case 80:
			t_t_var_004 = object_size16();
			break;
		case 96:
			t_t_var_004 = object_size32();
			break;
		default:
			t_t_var_004 = 0x0;
			break;
		}
	prefix_value_ = t_t_var_004;
	prefix_called_ = t_context->flow()->get_dnp3_object_prefix(prefix_value());
	BINPAC_ASSERT(t_begin_of_data + (t_Prefix_Type__size) <= t_end_of_data);
	return t_Prefix_Type__size;
	}

Request_Data_Object::Request_Data_Object(uint8 function_code, uint8 qualifier_field, uint16 object_type_field)
	{
	prefix_ = 0;
	data_case_index_ = -1;
	attrib211_ = 0;
	attrib212_ = 0;
	attrib213_ = 0;
	attrib214_ = 0;
	attrib215_ = 0;
	attrib216_ = 0;
	attrib217_ = 0;
	attrib218_ = 0;
	attrib219_ = 0;
	attrib220_ = 0;
	attrib221_ = 0;
	attrib222_ = 0;
	attrib223_ = 0;
	attrib224_ = 0;
	attrib225_ = 0;
	attrib226_ = 0;
	attrib227_ = 0;
	attrib228_ = 0;
	attrib229_ = 0;
	attrib230_ = 0;
	attrib231_ = 0;
	attrib232_ = 0;
	attrib233_ = 0;
	attrib234_ = 0;
	attrib235_ = 0;
	attrib236_ = 0;
	attrib237_ = 0;
	attrib238_ = 0;
	attrib239_ = 0;
	attrib240_ = 0;
	attrib241_ = 0;
	attrib242_ = 0;
	attrib243_ = 0;
	attrib245_ = 0;
	attrib246_ = 0;
	attrib247_ = 0;
	attrib248_ = 0;
	attrib249_ = 0;
	attrib250_ = 0;
	attrib252_ = 0;
	attrib254_ = 0;
	attrib255_ = 0;
	bocmd_CROB_ = 0;
	bocmd_PCB_ = 0;
	bocmd_PM_ = 0;
	ao_32_ = 0;
	ao_16_ = 0;
	ao_sp_ = 0;
	ao_dp_ = 0;
	time_abs_ = 0;
	time_interval_ = 0;
	time_abs_last_ = 0;
	time_abs_sync_ = 0;
	time_abs_unsync_ = 0;
	time_coarse_ = 0;
	time_fine_ = 0;
	file_control_id_ = 0;
	file_control_auth_ = 0;
	file_control_cmd_ = 0;
	file_control_cmd_status_ = 0;
	file_trans_ = 0;
	file_trans_status_ = 0;
	file_desc_ = 0;
	priregobj_ = 0;
	priregobjdesc_ = 0;
	desc_ele_ = 0;
	desc_ele86_ = 0;
	cha_ = 0;
	point_index_attr_ = 0;
	present_value_ = 0;
	snapshot_ = 0;
	activate_conf_ = 0;
	bcd_small_ = 0;
	bcd_medium_ = 0;
	bcd_large_ = 0;
	unsigned_integer_ = 0;
	challenge_ = 0;
	reply_ = 0;
	aggrRequest_ = 0;
	seesionKeyRequest_ = 0;
	status_ = 0;
	keyChange_ = 0;
	error_ = 0;
	unmatched_ = 0;
	function_code_ = function_code;
	qualifier_field_ = qualifier_field;
	object_type_field_ = object_type_field;
	}

Request_Data_Object::~Request_Data_Object()
	{
	delete prefix_;
	prefix_ = 0;
	switch ( data_case_index() )
		{
		case 211:
			// Clean up "attrib211"
			{
			delete attrib211_;
			attrib211_ = 0;
			}
			break;
		case 212:
			// Clean up "attrib212"
			{
			delete attrib212_;
			attrib212_ = 0;
			}
			break;
		case 213:
			// Clean up "attrib213"
			{
			delete attrib213_;
			attrib213_ = 0;
			}
			break;
		case 214:
			// Clean up "attrib214"
			{
			delete attrib214_;
			attrib214_ = 0;
			}
			break;
		case 215:
			// Clean up "attrib215"
			{
			delete attrib215_;
			attrib215_ = 0;
			}
			break;
		case 216:
			// Clean up "attrib216"
			{
			delete attrib216_;
			attrib216_ = 0;
			}
			break;
		case 217:
			// Clean up "attrib217"
			{
			delete attrib217_;
			attrib217_ = 0;
			}
			break;
		case 218:
			// Clean up "attrib218"
			{
			delete attrib218_;
			attrib218_ = 0;
			}
			break;
		case 219:
			// Clean up "attrib219"
			{
			delete attrib219_;
			attrib219_ = 0;
			}
			break;
		case 220:
			// Clean up "attrib220"
			{
			delete attrib220_;
			attrib220_ = 0;
			}
			break;
		case 221:
			// Clean up "attrib221"
			{
			delete attrib221_;
			attrib221_ = 0;
			}
			break;
		case 222:
			// Clean up "attrib222"
			{
			delete attrib222_;
			attrib222_ = 0;
			}
			break;
		case 223:
			// Clean up "attrib223"
			{
			delete attrib223_;
			attrib223_ = 0;
			}
			break;
		case 224:
			// Clean up "attrib224"
			{
			delete attrib224_;
			attrib224_ = 0;
			}
			break;
		case 225:
			// Clean up "attrib225"
			{
			delete attrib225_;
			attrib225_ = 0;
			}
			break;
		case 226:
			// Clean up "attrib226"
			{
			delete attrib226_;
			attrib226_ = 0;
			}
			break;
		case 227:
			// Clean up "attrib227"
			{
			delete attrib227_;
			attrib227_ = 0;
			}
			break;
		case 228:
			// Clean up "attrib228"
			{
			delete attrib228_;
			attrib228_ = 0;
			}
			break;
		case 229:
			// Clean up "attrib229"
			{
			delete attrib229_;
			attrib229_ = 0;
			}
			break;
		case 230:
			// Clean up "attrib230"
			{
			delete attrib230_;
			attrib230_ = 0;
			}
			break;
		case 231:
			// Clean up "attrib231"
			{
			delete attrib231_;
			attrib231_ = 0;
			}
			break;
		case 232:
			// Clean up "attrib232"
			{
			delete attrib232_;
			attrib232_ = 0;
			}
			break;
		case 233:
			// Clean up "attrib233"
			{
			delete attrib233_;
			attrib233_ = 0;
			}
			break;
		case 234:
			// Clean up "attrib234"
			{
			delete attrib234_;
			attrib234_ = 0;
			}
			break;
		case 235:
			// Clean up "attrib235"
			{
			delete attrib235_;
			attrib235_ = 0;
			}
			break;
		case 236:
			// Clean up "attrib236"
			{
			delete attrib236_;
			attrib236_ = 0;
			}
			break;
		case 237:
			// Clean up "attrib237"
			{
			delete attrib237_;
			attrib237_ = 0;
			}
			break;
		case 238:
			// Clean up "attrib238"
			{
			delete attrib238_;
			attrib238_ = 0;
			}
			break;
		case 239:
			// Clean up "attrib239"
			{
			delete attrib239_;
			attrib239_ = 0;
			}
			break;
		case 240:
			// Clean up "attrib240"
			{
			delete attrib240_;
			attrib240_ = 0;
			}
			break;
		case 241:
			// Clean up "attrib241"
			{
			delete attrib241_;
			attrib241_ = 0;
			}
			break;
		case 242:
			// Clean up "attrib242"
			{
			delete attrib242_;
			attrib242_ = 0;
			}
			break;
		case 243:
			// Clean up "attrib243"
			{
			delete attrib243_;
			attrib243_ = 0;
			}
			break;
		case 245:
			// Clean up "attrib245"
			{
			delete attrib245_;
			attrib245_ = 0;
			}
			break;
		case 246:
			// Clean up "attrib246"
			{
			delete attrib246_;
			attrib246_ = 0;
			}
			break;
		case 247:
			// Clean up "attrib247"
			{
			delete attrib247_;
			attrib247_ = 0;
			}
			break;
		case 248:
			// Clean up "attrib248"
			{
			delete attrib248_;
			attrib248_ = 0;
			}
			break;
		case 249:
			// Clean up "attrib249"
			{
			delete attrib249_;
			attrib249_ = 0;
			}
			break;
		case 250:
			// Clean up "attrib250"
			{
			delete attrib250_;
			attrib250_ = 0;
			}
			break;
		case 252:
			// Clean up "attrib252"
			{
			delete attrib252_;
			attrib252_ = 0;
			}
			break;
		case 254:
			// Clean up "attrib254"
			{
			delete attrib254_;
			attrib254_ = 0;
			}
			break;
		case 255:
			// Clean up "attrib255"
			{
			delete attrib255_;
			attrib255_ = 0;
			}
			break;
		case 256:
			// Clean up "bi_default"
			{
			}
			break;
		case 257:
			// Clean up "bi_packed"
			{
			}
			break;
		case 258:
			// Clean up "bi_flag"
			{
			}
			break;
		case 512:
			// Clean up "biedefault"
			{
			}
			break;
		case 513:
			// Clean up "biewotime"
			{
			}
			break;
		case 514:
			// Clean up "biewatime"
			{
			}
			break;
		case 515:
			// Clean up "biewrtime"
			{
			}
			break;
		case 768:
			// Clean up "dbiDefault"
			{
			}
			break;
		case 769:
			// Clean up "dbibytes"
			{
			}
			break;
		case 770:
			// Clean up "dbiflag"
			{
			}
			break;
		case 1024:
			// Clean up "dbieDefault"
			{
			}
			break;
		case 1025:
			// Clean up "dbieatime"
			{
			}
			break;
		case 1026:
			// Clean up "dbiertime"
			{
			}
			break;
		case 2560:
			// Clean up "boDefault"
			{
			}
			break;
		case 2561:
			// Clean up "bowoflag"
			{
			}
			break;
		case 2562:
			// Clean up "bowflag"
			{
			}
			break;
		case 2816:
			// Clean up "bowDefault"
			{
			}
			break;
		case 2817:
			// Clean up "boewflag"
			{
			}
			break;
		case 2818:
			// Clean up "boewatime"
			{
			}
			break;
		case 3073:
			// Clean up "bocmd_CROB"
			{
			delete bocmd_CROB_;
			bocmd_CROB_ = 0;
			}
			break;
		case 3074:
			// Clean up "bocmd_PCB"
			{
			delete bocmd_PCB_;
			bocmd_PCB_ = 0;
			}
			break;
		case 3075:
			// Clean up "bocmd_PM"
			{
			}
			break;
		case 3328:
			// Clean up "boceDefault"
			{
			}
			break;
		case 3329:
			// Clean up "boceFlag"
			{
			}
			break;
		case 3330:
			// Clean up "boceAtime"
			{
			}
			break;
		case 5120:
			// Clean up "counter_default"
			{
			}
			break;
		case 5121:
			// Clean up "counter_32_wflag"
			{
			}
			break;
		case 5122:
			// Clean up "counter_16_wflag"
			{
			}
			break;
		case 5123:
			// Clean up "counter_32_wflag_delta"
			{
			}
			break;
		case 5124:
			// Clean up "counter_16_wflag_delta"
			{
			}
			break;
		case 5125:
			// Clean up "counter_32_woflag"
			{
			}
			break;
		case 5126:
			// Clean up "counter_16_woflag"
			{
			}
			break;
		case 5127:
			// Clean up "counter_32_woflag_delta"
			{
			}
			break;
		case 5128:
			// Clean up "counter_16_woflag_delta"
			{
			}
			break;
		case 5376:
			// Clean up "f_counter_default"
			{
			}
			break;
		case 5377:
			// Clean up "f_counter_32_wflag"
			{
			}
			break;
		case 5378:
			// Clean up "f_counter_16_wflag"
			{
			}
			break;
		case 5379:
			// Clean up "f_counter_32_wflag_delta"
			{
			}
			break;
		case 5380:
			// Clean up "f_counter_16_wflag_delta"
			{
			}
			break;
		case 5381:
			// Clean up "f_counter_32_wflag_time"
			{
			}
			break;
		case 5382:
			// Clean up "f_counter_16_wflag_time"
			{
			}
			break;
		case 5383:
			// Clean up "f_counter_32_wflag_time_delta"
			{
			}
			break;
		case 5384:
			// Clean up "f_counter_16_wflag_time_delta"
			{
			}
			break;
		case 5385:
			// Clean up "f_counter_32_woflag"
			{
			}
			break;
		case 5386:
			// Clean up "f_counter_16_woflag"
			{
			}
			break;
		case 5387:
			// Clean up "f_counter_32_woflag_delta"
			{
			}
			break;
		case 5388:
			// Clean up "f_counter_16_woflag_delta"
			{
			}
			break;
		case 5632:
			// Clean up "counter_event_default"
			{
			}
			break;
		case 5633:
			// Clean up "counter_event_32_wflag"
			{
			}
			break;
		case 5634:
			// Clean up "counter_event_16_wflag"
			{
			}
			break;
		case 5635:
			// Clean up "counter_event_32_wflag_delta"
			{
			}
			break;
		case 5636:
			// Clean up "counter_event_16_wflag_delta"
			{
			}
			break;
		case 5637:
			// Clean up "counter_event_32_wflag_time"
			{
			}
			break;
		case 5638:
			// Clean up "counter_event_16_wflag_time"
			{
			}
			break;
		case 5639:
			// Clean up "counter_event_32_wflag_time_delta"
			{
			}
			break;
		case 5640:
			// Clean up "counter_event_16_wflag_time_delat"
			{
			}
			break;
		case 5888:
			// Clean up "f_counter_event_default"
			{
			}
			break;
		case 5889:
			// Clean up "f_counter_event_32_wflag"
			{
			}
			break;
		case 5890:
			// Clean up "f_counter_event_16_wflag"
			{
			}
			break;
		case 5891:
			// Clean up "f_counter_event_32_wflag_delta"
			{
			}
			break;
		case 5892:
			// Clean up "f_counter_event_16_wflag_delta"
			{
			}
			break;
		case 5893:
			// Clean up "f_counter_event_32_wflag_time"
			{
			}
			break;
		case 5894:
			// Clean up "f_counter_event_16_wflag_time"
			{
			}
			break;
		case 5895:
			// Clean up "f_counter_event_32_wflag_time_delta"
			{
			}
			break;
		case 5896:
			// Clean up "f_counter_event_16_wflag_time_delat"
			{
			}
			break;
		case 7680:
			// Clean up "ai_default"
			{
			}
			break;
		case 7681:
			// Clean up "ai_32_wflag"
			{
			}
			break;
		case 7682:
			// Clean up "ai_16_wflag"
			{
			}
			break;
		case 7683:
			// Clean up "ai_32_woflag"
			{
			}
			break;
		case 7684:
			// Clean up "ai_16_woflag"
			{
			}
			break;
		case 7685:
			// Clean up "ai_sp_wflag"
			{
			}
			break;
		case 7686:
			// Clean up "ai_dp_wflag"
			{
			}
			break;
		case 7936:
			// Clean up "f_ai_default"
			{
			}
			break;
		case 7937:
			// Clean up "f_ai_32_wflag"
			{
			}
			break;
		case 7938:
			// Clean up "f_ai_16_wflag"
			{
			}
			break;
		case 7939:
			// Clean up "f_ai_32_wtime"
			{
			}
			break;
		case 7940:
			// Clean up "f_ai_16_wtime"
			{
			}
			break;
		case 7941:
			// Clean up "f_ai_32_woflag"
			{
			}
			break;
		case 7942:
			// Clean up "f_ai_16_woflag"
			{
			}
			break;
		case 7943:
			// Clean up "f_ai_sp_wflag"
			{
			}
			break;
		case 7944:
			// Clean up "f_ai_dp_wflag"
			{
			}
			break;
		case 8192:
			// Clean up "aie_default"
			{
			}
			break;
		case 8193:
			// Clean up "ai32wotime"
			{
			}
			break;
		case 8194:
			// Clean up "ai16wotime"
			{
			}
			break;
		case 8195:
			// Clean up "ai32wtime"
			{
			}
			break;
		case 8196:
			// Clean up "ai16wtime"
			{
			}
			break;
		case 8197:
			// Clean up "aispwotime"
			{
			}
			break;
		case 8198:
			// Clean up "aidpwotime"
			{
			}
			break;
		case 8199:
			// Clean up "aispwtime"
			{
			}
			break;
		case 8200:
			// Clean up "aidpwtime"
			{
			}
			break;
		case 8448:
			// Clean up "f_aie_default"
			{
			}
			break;
		case 8449:
			// Clean up "f_aie_32_wotime"
			{
			}
			break;
		case 8450:
			// Clean up "f_aie_16_wotime"
			{
			}
			break;
		case 8451:
			// Clean up "f_aie_32_wtime"
			{
			}
			break;
		case 8452:
			// Clean up "f_aie_16_wtime"
			{
			}
			break;
		case 8453:
			// Clean up "f_aie_sp_wotime"
			{
			}
			break;
		case 8454:
			// Clean up "f_aie_dp_wotime"
			{
			}
			break;
		case 8455:
			// Clean up "f_aie_sp_wtime"
			{
			}
			break;
		case 8456:
			// Clean up "f_aie_dp_wtime"
			{
			}
			break;
		case 8704:
			// Clean up "ai_dead"
			{
			}
			break;
		case 8705:
			// Clean up "ai_dead_16"
			{
			}
			break;
		case 8706:
			// Clean up "ai_dead_32"
			{
			}
			break;
		case 8707:
			// Clean up "ai_dead_sp"
			{
			}
			break;
		case 10240:
			// Clean up "aos_default"
			{
			}
			break;
		case 10241:
			// Clean up "aos_32"
			{
			}
			break;
		case 10242:
			// Clean up "aos_16"
			{
			}
			break;
		case 10243:
			// Clean up "aos_sp"
			{
			}
			break;
		case 10244:
			// Clean up "aos_dp"
			{
			}
			break;
		case 10497:
			// Clean up "ao_32"
			{
			delete ao_32_;
			ao_32_ = 0;
			}
			break;
		case 10498:
			// Clean up "ao_16"
			{
			delete ao_16_;
			ao_16_ = 0;
			}
			break;
		case 10499:
			// Clean up "ao_sp"
			{
			delete ao_sp_;
			ao_sp_ = 0;
			}
			break;
		case 10500:
			// Clean up "ao_dp"
			{
			delete ao_dp_;
			ao_dp_ = 0;
			}
			break;
		case 10752:
			// Clean up "aoe_default"
			{
			}
			break;
		case 10753:
			// Clean up "aoe32wotime"
			{
			}
			break;
		case 10754:
			// Clean up "aoe16wotime"
			{
			}
			break;
		case 10755:
			// Clean up "aoe32wtime"
			{
			}
			break;
		case 10756:
			// Clean up "aoe16wtime"
			{
			}
			break;
		case 10757:
			// Clean up "aoespwotime"
			{
			}
			break;
		case 10758:
			// Clean up "aoedpwotime"
			{
			}
			break;
		case 10759:
			// Clean up "aoespwtime"
			{
			}
			break;
		case 10760:
			// Clean up "aoedpwtime"
			{
			}
			break;
		case 11008:
			// Clean up "aoce_default"
			{
			}
			break;
		case 11009:
			// Clean up "aoce32wotime"
			{
			}
			break;
		case 11010:
			// Clean up "aoce16wotime"
			{
			}
			break;
		case 11011:
			// Clean up "aoce32wtime"
			{
			}
			break;
		case 11012:
			// Clean up "aoce16wtime"
			{
			}
			break;
		case 11013:
			// Clean up "aocespwotime"
			{
			}
			break;
		case 11014:
			// Clean up "aocedpwotime"
			{
			}
			break;
		case 11015:
			// Clean up "aocespwtime"
			{
			}
			break;
		case 11016:
			// Clean up "aocedpwtime"
			{
			}
			break;
		case 12800:
			// Clean up "time_default"
			{
			}
			break;
		case 12801:
			// Clean up "time_abs"
			{
			delete time_abs_;
			time_abs_ = 0;
			}
			break;
		case 12802:
			// Clean up "time_interval"
			{
			delete time_interval_;
			time_interval_ = 0;
			}
			break;
		case 12803:
			// Clean up "time_abs_last"
			{
			delete time_abs_last_;
			time_abs_last_ = 0;
			}
			break;
		case 13057:
			// Clean up "time_abs_sync"
			{
			delete time_abs_sync_;
			time_abs_sync_ = 0;
			}
			break;
		case 13058:
			// Clean up "time_abs_unsync"
			{
			delete time_abs_unsync_;
			time_abs_unsync_ = 0;
			}
			break;
		case 13313:
			// Clean up "time_coarse"
			{
			}
			break;
		case 13314:
			// Clean up "time_fine"
			{
			}
			break;
		case 15361:
			// Clean up "class0data"
			{
			}
			break;
		case 15362:
			// Clean up "class1data"
			{
			}
			break;
		case 15363:
			// Clean up "class2data"
			{
			}
			break;
		case 15364:
			// Clean up "class3data"
			{
			}
			break;
		case 17921:
			// Clean up "file_control_id"
			{
			delete file_control_id_;
			file_control_id_ = 0;
			}
			break;
		case 17922:
			// Clean up "file_control_auth"
			{
			delete file_control_auth_;
			file_control_auth_ = 0;
			}
			break;
		case 17923:
			// Clean up "file_control_cmd"
			{
			delete file_control_cmd_;
			file_control_cmd_ = 0;
			}
			break;
		case 17924:
			// Clean up "file_control_cmd_status"
			{
			delete file_control_cmd_status_;
			file_control_cmd_status_ = 0;
			}
			break;
		case 17925:
			// Clean up "file_trans"
			{
			delete file_trans_;
			file_trans_ = 0;
			}
			break;
		case 17926:
			// Clean up "file_trans_status"
			{
			delete file_trans_status_;
			file_trans_status_ = 0;
			}
			break;
		case 17927:
			// Clean up "file_desc"
			{
			delete file_desc_;
			file_desc_ = 0;
			}
			break;
		case 20481:
			// Clean up "iin"
			{
			iin_.free();
			}
			break;
		case 20737:
			// Clean up "dev_store"
			{
			}
			break;
		case 20993:
			// Clean up "dev_profile"
			{
			}
			break;
		case 21249:
			// Clean up "priregobj"
			{
			delete priregobj_;
			priregobj_ = 0;
			}
			break;
		case 21250:
			// Clean up "priregobjdesc"
			{
			delete priregobjdesc_;
			priregobjdesc_ = 0;
			}
			break;
		case 21761:
			// Clean up "desc_ele"
			{
			delete desc_ele_;
			desc_ele_ = 0;
			}
			break;
		case 22017:
			// Clean up "desc_ele86"
			{
			delete desc_ele86_;
			desc_ele86_ = 0;
			}
			break;
		case 22018:
			// Clean up "cha"
			{
			}
			break;
		case 22019:
			// Clean up "point_index_attr"
			{
			delete point_index_attr_;
			point_index_attr_ = 0;
			}
			break;
		case 22273:
			// Clean up "present_value"
			{
			delete present_value_;
			present_value_ = 0;
			}
			break;
		case 22529:
			// Clean up "snapshot"
			{
			delete snapshot_;
			snapshot_ = 0;
			}
			break;
		case 23297:
			// Clean up "activate_conf"
			{
			delete activate_conf_;
			activate_conf_ = 0;
			}
			break;
		case 25857:
			// Clean up "bcd_small"
			{
			}
			break;
		case 25858:
			// Clean up "bcd_medium"
			{
			}
			break;
		case 25859:
			// Clean up "bcd_large"
			{
			delete bcd_large_;
			bcd_large_ = 0;
			}
			break;
		case 26113:
			// Clean up "unsigned_integer"
			{
			}
			break;
		case 30721:
			// Clean up "challenge"
			{
			delete challenge_;
			challenge_ = 0;
			}
			break;
		case 30722:
			// Clean up "reply"
			{
			delete reply_;
			reply_ = 0;
			}
			break;
		case 30723:
			// Clean up "aggrRequest"
			{
			delete aggrRequest_;
			aggrRequest_ = 0;
			}
			break;
		case 30724:
			// Clean up "seesionKeyRequest"
			{
			}
			break;
		case 30725:
			// Clean up "status"
			{
			delete status_;
			status_ = 0;
			}
			break;
		case 30726:
			// Clean up "keyChange"
			{
			delete keyChange_;
			keyChange_ = 0;
			}
			break;
		case 30727:
			// Clean up "error"
			{
			delete error_;
			error_ = 0;
			}
			break;
		default:
			// Clean up "unmatched"
			{
			delete unmatched_;
			unmatched_ = 0;
			}
			break;
		}
	}

int Request_Data_Object::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context, int t_byteorder)
	{
	// Parse "prefix"
	prefix_ = new Prefix_Type(qualifier_field());
	int t_prefix__size;
	t_prefix__size = prefix_->Parse(t_begin_of_data, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_prefix = t_begin_of_data + (t_prefix__size);
	BINPAC_ASSERT(t_dataptr_after_prefix <= t_end_of_data);
	// Parse "data"
	int t_data__size;
	data_case_index_ =  ( object_type_field() ) ;
	switch ( data_case_index() )
		{
		case 211:
			// Parse "attrib211"
			{
			attrib211_ = new AttributeCommon();
			int t_attrib211__size;
			t_attrib211__size = attrib211_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib211__size;
			}
			break;
		case 212:
			// Parse "attrib212"
			{
			attrib212_ = new AttributeCommon();
			int t_attrib212__size;
			t_attrib212__size = attrib212_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib212__size;
			}
			break;
		case 213:
			// Parse "attrib213"
			{
			attrib213_ = new AttributeCommon();
			int t_attrib213__size;
			t_attrib213__size = attrib213_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib213__size;
			}
			break;
		case 214:
			// Parse "attrib214"
			{
			attrib214_ = new AttributeCommon();
			int t_attrib214__size;
			t_attrib214__size = attrib214_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib214__size;
			}
			break;
		case 215:
			// Parse "attrib215"
			{
			attrib215_ = new AttributeCommon();
			int t_attrib215__size;
			t_attrib215__size = attrib215_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib215__size;
			}
			break;
		case 216:
			// Parse "attrib216"
			{
			attrib216_ = new AttributeCommon();
			int t_attrib216__size;
			t_attrib216__size = attrib216_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib216__size;
			}
			break;
		case 217:
			// Parse "attrib217"
			{
			attrib217_ = new AttributeCommon();
			int t_attrib217__size;
			t_attrib217__size = attrib217_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib217__size;
			}
			break;
		case 218:
			// Parse "attrib218"
			{
			attrib218_ = new AttributeCommon();
			int t_attrib218__size;
			t_attrib218__size = attrib218_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib218__size;
			}
			break;
		case 219:
			// Parse "attrib219"
			{
			attrib219_ = new AttributeCommon();
			int t_attrib219__size;
			t_attrib219__size = attrib219_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib219__size;
			}
			break;
		case 220:
			// Parse "attrib220"
			{
			attrib220_ = new AttributeCommon();
			int t_attrib220__size;
			t_attrib220__size = attrib220_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib220__size;
			}
			break;
		case 221:
			// Parse "attrib221"
			{
			attrib221_ = new AttributeCommon();
			int t_attrib221__size;
			t_attrib221__size = attrib221_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib221__size;
			}
			break;
		case 222:
			// Parse "attrib222"
			{
			attrib222_ = new AttributeCommon();
			int t_attrib222__size;
			t_attrib222__size = attrib222_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib222__size;
			}
			break;
		case 223:
			// Parse "attrib223"
			{
			attrib223_ = new AttributeCommon();
			int t_attrib223__size;
			t_attrib223__size = attrib223_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib223__size;
			}
			break;
		case 224:
			// Parse "attrib224"
			{
			attrib224_ = new AttributeCommon();
			int t_attrib224__size;
			t_attrib224__size = attrib224_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib224__size;
			}
			break;
		case 225:
			// Parse "attrib225"
			{
			attrib225_ = new AttributeCommon();
			int t_attrib225__size;
			t_attrib225__size = attrib225_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib225__size;
			}
			break;
		case 226:
			// Parse "attrib226"
			{
			attrib226_ = new AttributeCommon();
			int t_attrib226__size;
			t_attrib226__size = attrib226_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib226__size;
			}
			break;
		case 227:
			// Parse "attrib227"
			{
			attrib227_ = new AttributeCommon();
			int t_attrib227__size;
			t_attrib227__size = attrib227_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib227__size;
			}
			break;
		case 228:
			// Parse "attrib228"
			{
			attrib228_ = new AttributeCommon();
			int t_attrib228__size;
			t_attrib228__size = attrib228_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib228__size;
			}
			break;
		case 229:
			// Parse "attrib229"
			{
			attrib229_ = new AttributeCommon();
			int t_attrib229__size;
			t_attrib229__size = attrib229_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib229__size;
			}
			break;
		case 230:
			// Parse "attrib230"
			{
			attrib230_ = new AttributeCommon();
			int t_attrib230__size;
			t_attrib230__size = attrib230_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib230__size;
			}
			break;
		case 231:
			// Parse "attrib231"
			{
			attrib231_ = new AttributeCommon();
			int t_attrib231__size;
			t_attrib231__size = attrib231_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib231__size;
			}
			break;
		case 232:
			// Parse "attrib232"
			{
			attrib232_ = new AttributeCommon();
			int t_attrib232__size;
			t_attrib232__size = attrib232_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib232__size;
			}
			break;
		case 233:
			// Parse "attrib233"
			{
			attrib233_ = new AttributeCommon();
			int t_attrib233__size;
			t_attrib233__size = attrib233_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib233__size;
			}
			break;
		case 234:
			// Parse "attrib234"
			{
			attrib234_ = new AttributeCommon();
			int t_attrib234__size;
			t_attrib234__size = attrib234_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib234__size;
			}
			break;
		case 235:
			// Parse "attrib235"
			{
			attrib235_ = new AttributeCommon();
			int t_attrib235__size;
			t_attrib235__size = attrib235_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib235__size;
			}
			break;
		case 236:
			// Parse "attrib236"
			{
			attrib236_ = new AttributeCommon();
			int t_attrib236__size;
			t_attrib236__size = attrib236_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib236__size;
			}
			break;
		case 237:
			// Parse "attrib237"
			{
			attrib237_ = new AttributeCommon();
			int t_attrib237__size;
			t_attrib237__size = attrib237_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib237__size;
			}
			break;
		case 238:
			// Parse "attrib238"
			{
			attrib238_ = new AttributeCommon();
			int t_attrib238__size;
			t_attrib238__size = attrib238_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib238__size;
			}
			break;
		case 239:
			// Parse "attrib239"
			{
			attrib239_ = new AttributeCommon();
			int t_attrib239__size;
			t_attrib239__size = attrib239_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib239__size;
			}
			break;
		case 240:
			// Parse "attrib240"
			{
			attrib240_ = new AttributeCommon();
			int t_attrib240__size;
			t_attrib240__size = attrib240_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib240__size;
			}
			break;
		case 241:
			// Parse "attrib241"
			{
			attrib241_ = new AttributeCommon();
			int t_attrib241__size;
			t_attrib241__size = attrib241_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib241__size;
			}
			break;
		case 242:
			// Parse "attrib242"
			{
			attrib242_ = new AttributeCommon();
			int t_attrib242__size;
			t_attrib242__size = attrib242_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib242__size;
			}
			break;
		case 243:
			// Parse "attrib243"
			{
			attrib243_ = new AttributeCommon();
			int t_attrib243__size;
			t_attrib243__size = attrib243_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib243__size;
			}
			break;
		case 245:
			// Parse "attrib245"
			{
			attrib245_ = new AttributeCommon();
			int t_attrib245__size;
			t_attrib245__size = attrib245_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib245__size;
			}
			break;
		case 246:
			// Parse "attrib246"
			{
			attrib246_ = new AttributeCommon();
			int t_attrib246__size;
			t_attrib246__size = attrib246_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib246__size;
			}
			break;
		case 247:
			// Parse "attrib247"
			{
			attrib247_ = new AttributeCommon();
			int t_attrib247__size;
			t_attrib247__size = attrib247_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib247__size;
			}
			break;
		case 248:
			// Parse "attrib248"
			{
			attrib248_ = new AttributeCommon();
			int t_attrib248__size;
			t_attrib248__size = attrib248_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib248__size;
			}
			break;
		case 249:
			// Parse "attrib249"
			{
			attrib249_ = new AttributeCommon();
			int t_attrib249__size;
			t_attrib249__size = attrib249_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib249__size;
			}
			break;
		case 250:
			// Parse "attrib250"
			{
			attrib250_ = new AttributeCommon();
			int t_attrib250__size;
			t_attrib250__size = attrib250_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib250__size;
			}
			break;
		case 252:
			// Parse "attrib252"
			{
			attrib252_ = new AttributeCommon();
			int t_attrib252__size;
			t_attrib252__size = attrib252_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib252__size;
			}
			break;
		case 254:
			// Parse "attrib254"
			{
			attrib254_ = new AttributeCommon();
			int t_attrib254__size;
			t_attrib254__size = attrib254_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib254__size;
			}
			break;
		case 255:
			// Parse "attrib255"
			{
			attrib255_ = new AttributeCommon();
			int t_attrib255__size;
			t_attrib255__size = attrib255_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib255__size;
			}
			break;
		case 256:
			// Parse "bi_default"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 257:
			// Parse "bi_packed"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 258:
			// Parse "bi_flag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 512:
			// Parse "biedefault"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 513:
			// Parse "biewotime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 514:
			// Parse "biewatime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 515:
			// Parse "biewrtime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 768:
			// Parse "dbiDefault"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 769:
			// Parse "dbibytes"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 770:
			// Parse "dbiflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 1024:
			// Parse "dbieDefault"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 1025:
			// Parse "dbieatime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 1026:
			// Parse "dbiertime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 2560:
			// Parse "boDefault"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 2561:
			// Parse "bowoflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 2562:
			// Parse "bowflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 2816:
			// Parse "bowDefault"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 2817:
			// Parse "boewflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 2818:
			// Parse "boewatime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 3073:
			// Parse "bocmd_CROB"
			{
			bocmd_CROB_ = new CROB();
			bocmd_CROB_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 11;
			}
			break;
		case 3074:
			// Parse "bocmd_PCB"
			{
			bocmd_PCB_ = new PCB();
			bocmd_PCB_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 11;
			}
			break;
		case 3075:
			// Parse "bocmd_PM"
			{
			// Checking out-of-bound for "Request_Data_Object:bocmd_PM"
			if ( t_dataptr_after_prefix + (1) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Request_Data_Object:bocmd_PM",
					((t_dataptr_after_prefix - t_begin_of_data)) + (1), 
					(t_end_of_data) - (t_begin_of_data));
				}
			bocmd_PM_ = *((uint8 const *) (t_dataptr_after_prefix));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 1;
			}
			break;
		case 3328:
			// Parse "boceDefault"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 3329:
			// Parse "boceFlag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 3330:
			// Parse "boceAtime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5120:
			// Parse "counter_default"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5121:
			// Parse "counter_32_wflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5122:
			// Parse "counter_16_wflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5123:
			// Parse "counter_32_wflag_delta"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5124:
			// Parse "counter_16_wflag_delta"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5125:
			// Parse "counter_32_woflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5126:
			// Parse "counter_16_woflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5127:
			// Parse "counter_32_woflag_delta"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5128:
			// Parse "counter_16_woflag_delta"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5376:
			// Parse "f_counter_default"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5377:
			// Parse "f_counter_32_wflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5378:
			// Parse "f_counter_16_wflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5379:
			// Parse "f_counter_32_wflag_delta"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5380:
			// Parse "f_counter_16_wflag_delta"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5381:
			// Parse "f_counter_32_wflag_time"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5382:
			// Parse "f_counter_16_wflag_time"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5383:
			// Parse "f_counter_32_wflag_time_delta"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5384:
			// Parse "f_counter_16_wflag_time_delta"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5385:
			// Parse "f_counter_32_woflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5386:
			// Parse "f_counter_16_woflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5387:
			// Parse "f_counter_32_woflag_delta"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5388:
			// Parse "f_counter_16_woflag_delta"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5632:
			// Parse "counter_event_default"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5633:
			// Parse "counter_event_32_wflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5634:
			// Parse "counter_event_16_wflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5635:
			// Parse "counter_event_32_wflag_delta"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5636:
			// Parse "counter_event_16_wflag_delta"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5637:
			// Parse "counter_event_32_wflag_time"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5638:
			// Parse "counter_event_16_wflag_time"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5639:
			// Parse "counter_event_32_wflag_time_delta"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5640:
			// Parse "counter_event_16_wflag_time_delat"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5888:
			// Parse "f_counter_event_default"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5889:
			// Parse "f_counter_event_32_wflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5890:
			// Parse "f_counter_event_16_wflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5891:
			// Parse "f_counter_event_32_wflag_delta"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5892:
			// Parse "f_counter_event_16_wflag_delta"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5893:
			// Parse "f_counter_event_32_wflag_time"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5894:
			// Parse "f_counter_event_16_wflag_time"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5895:
			// Parse "f_counter_event_32_wflag_time_delta"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 5896:
			// Parse "f_counter_event_16_wflag_time_delat"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 7680:
			// Parse "ai_default"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 7681:
			// Parse "ai_32_wflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 7682:
			// Parse "ai_16_wflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 7683:
			// Parse "ai_32_woflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 7684:
			// Parse "ai_16_woflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 7685:
			// Parse "ai_sp_wflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 7686:
			// Parse "ai_dp_wflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 7936:
			// Parse "f_ai_default"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 7937:
			// Parse "f_ai_32_wflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 7938:
			// Parse "f_ai_16_wflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 7939:
			// Parse "f_ai_32_wtime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 7940:
			// Parse "f_ai_16_wtime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 7941:
			// Parse "f_ai_32_woflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 7942:
			// Parse "f_ai_16_woflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 7943:
			// Parse "f_ai_sp_wflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 7944:
			// Parse "f_ai_dp_wflag"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8192:
			// Parse "aie_default"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8193:
			// Parse "ai32wotime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8194:
			// Parse "ai16wotime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8195:
			// Parse "ai32wtime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8196:
			// Parse "ai16wtime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8197:
			// Parse "aispwotime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8198:
			// Parse "aidpwotime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8199:
			// Parse "aispwtime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8200:
			// Parse "aidpwtime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8448:
			// Parse "f_aie_default"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8449:
			// Parse "f_aie_32_wotime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8450:
			// Parse "f_aie_16_wotime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8451:
			// Parse "f_aie_32_wtime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8452:
			// Parse "f_aie_16_wtime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8453:
			// Parse "f_aie_sp_wotime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8454:
			// Parse "f_aie_dp_wotime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8455:
			// Parse "f_aie_sp_wtime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8456:
			// Parse "f_aie_dp_wtime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8704:
			// Parse "ai_dead"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8705:
			// Parse "ai_dead_16"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8706:
			// Parse "ai_dead_32"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8707:
			// Parse "ai_dead_sp"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 10240:
			// Parse "aos_default"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 10241:
			// Parse "aos_32"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 10242:
			// Parse "aos_16"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 10243:
			// Parse "aos_sp"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 10244:
			// Parse "aos_dp"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 10497:
			// Parse "ao_32"
			{
			ao_32_ = new AnaOut32();
			ao_32_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 5;
			}
			break;
		case 10498:
			// Parse "ao_16"
			{
			ao_16_ = new AnaOut16();
			ao_16_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 3;
			}
			break;
		case 10499:
			// Parse "ao_sp"
			{
			ao_sp_ = new AnaOutSP();
			ao_sp_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 5;
			}
			break;
		case 10500:
			// Parse "ao_dp"
			{
			ao_dp_ = new AnaOutDP();
			ao_dp_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 9;
			}
			break;
		case 10752:
			// Parse "aoe_default"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 10753:
			// Parse "aoe32wotime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 10754:
			// Parse "aoe16wotime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 10755:
			// Parse "aoe32wtime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 10756:
			// Parse "aoe16wtime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 10757:
			// Parse "aoespwotime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 10758:
			// Parse "aoedpwotime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 10759:
			// Parse "aoespwtime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 10760:
			// Parse "aoedpwtime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 11008:
			// Parse "aoce_default"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 11009:
			// Parse "aoce32wotime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 11010:
			// Parse "aoce16wotime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 11011:
			// Parse "aoce32wtime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 11012:
			// Parse "aoce16wtime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 11013:
			// Parse "aocespwotime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 11014:
			// Parse "aocedpwotime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 11015:
			// Parse "aocespwtime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 11016:
			// Parse "aocedpwtime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 12800:
			// Parse "time_default"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 12801:
			// Parse "time_abs"
			{
			time_abs_ = new AbsTime();
			int t_time_abs__size;
			t_time_abs__size = time_abs_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_time_abs__size;
			}
			break;
		case 12802:
			// Parse "time_interval"
			{
			time_interval_ = new AbsTimeInterval();
			int t_time_interval__size;
			t_time_interval__size = time_interval_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_time_interval__size;
			}
			break;
		case 12803:
			// Parse "time_abs_last"
			{
			time_abs_last_ = new Last_AbsTime();
			int t_time_abs_last__size;
			t_time_abs_last__size = time_abs_last_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_time_abs_last__size;
			}
			break;
		case 13057:
			// Parse "time_abs_sync"
			{
			time_abs_sync_ = new AbsTime();
			int t_time_abs_sync__size;
			t_time_abs_sync__size = time_abs_sync_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_time_abs_sync__size;
			}
			break;
		case 13058:
			// Parse "time_abs_unsync"
			{
			time_abs_unsync_ = new AbsTime();
			int t_time_abs_unsync__size;
			t_time_abs_unsync__size = time_abs_unsync_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_time_abs_unsync__size;
			}
			break;
		case 13313:
			// Parse "time_coarse"
			{
			// Checking out-of-bound for "Request_Data_Object:time_coarse"
			if ( t_dataptr_after_prefix + (2) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Request_Data_Object:time_coarse",
					((t_dataptr_after_prefix - t_begin_of_data)) + (2), 
					(t_end_of_data) - (t_begin_of_data));
				}
			time_coarse_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_dataptr_after_prefix)));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 2;
			}
			break;
		case 13314:
			// Parse "time_fine"
			{
			// Checking out-of-bound for "Request_Data_Object:time_fine"
			if ( t_dataptr_after_prefix + (2) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Request_Data_Object:time_fine",
					((t_dataptr_after_prefix - t_begin_of_data)) + (2), 
					(t_end_of_data) - (t_begin_of_data));
				}
			time_fine_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_dataptr_after_prefix)));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 2;
			}
			break;
		case 15361:
			// Parse "class0data"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 15362:
			// Parse "class1data"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 15363:
			// Parse "class2data"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 15364:
			// Parse "class3data"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 17921:
			// Parse "file_control_id"
			{
			file_control_id_ = new File_Control_ID();
			int t_file_control_id__size;
			t_file_control_id__size = file_control_id_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_file_control_id__size;
			}
			break;
		case 17922:
			// Parse "file_control_auth"
			{
			file_control_auth_ = new File_Control_Auth_Wrap(function_code());
			int t_file_control_auth__size;
			t_file_control_auth__size = file_control_auth_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_file_control_auth__size;
			}
			break;
		case 17923:
			// Parse "file_control_cmd"
			{
			file_control_cmd_ = new File_Control_Cmd();
			int t_file_control_cmd__size;
			t_file_control_cmd__size = file_control_cmd_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_file_control_cmd__size;
			}
			break;
		case 17924:
			// Parse "file_control_cmd_status"
			{
			file_control_cmd_status_ = new File_Control_Cmd_Status(prefix()->prefix_value());
			int t_file_control_cmd_status__size;
			t_file_control_cmd_status__size = file_control_cmd_status_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_file_control_cmd_status__size;
			}
			break;
		case 17925:
			// Parse "file_trans"
			{
			file_trans_ = new File_Transport(prefix()->prefix_value());
			int t_file_trans__size;
			t_file_trans__size = file_trans_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_file_trans__size;
			}
			break;
		case 17926:
			// Parse "file_trans_status"
			{
			file_trans_status_ = new File_Transport_Status(prefix()->prefix_value());
			int t_file_trans_status__size;
			t_file_trans_status__size = file_trans_status_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_file_trans_status__size;
			}
			break;
		case 17927:
			// Parse "file_desc"
			{
			file_desc_ = new File_Desc();
			int t_file_desc__size;
			t_file_desc__size = file_desc_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_file_desc__size;
			}
			break;
		case 20481:
			// Parse "iin"
			{
			int t_iin_string_length;
			t_iin_string_length = (t_end_of_data) - (t_dataptr_after_prefix);
			int t_iin__size;
			t_iin__size = t_iin_string_length;
			// check for negative sizes
			if ( t_iin_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-objects.pac:298", t_iin_string_length);
			iin_.init(t_dataptr_after_prefix, t_iin_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_iin__size;
			}
			break;
		case 20737:
			// Parse "dev_store"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 20993:
			// Parse "dev_profile"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 21249:
			// Parse "priregobj"
			{
			priregobj_ = new PrivRegObj();
			int t_priregobj__size;
			t_priregobj__size = priregobj_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_priregobj__size;
			}
			break;
		case 21250:
			// Parse "priregobjdesc"
			{
			priregobjdesc_ = new PrivRegObjDesc();
			int t_priregobjdesc__size;
			t_priregobjdesc__size = priregobjdesc_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_priregobjdesc__size;
			}
			break;
		case 21761:
			// Parse "desc_ele"
			{
			desc_ele_ = new DescEle();
			desc_ele_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 5;
			}
			break;
		case 22017:
			// Parse "desc_ele86"
			{
			desc_ele86_ = new DescEle();
			desc_ele86_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 5;
			}
			break;
		case 22018:
			// Parse "cha"
			{
			// Checking out-of-bound for "Request_Data_Object:cha"
			if ( t_dataptr_after_prefix + (1) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Request_Data_Object:cha",
					((t_dataptr_after_prefix - t_begin_of_data)) + (1), 
					(t_end_of_data) - (t_begin_of_data));
				}
			cha_ = *((uint8 const *) (t_dataptr_after_prefix));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 1;
			}
			break;
		case 22019:
			// Parse "point_index_attr"
			{
			point_index_attr_ = new Debug_Byte();
			int t_point_index_attr__size;
			t_point_index_attr__size = point_index_attr_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_point_index_attr__size;
			}
			break;
		case 22273:
			// Parse "present_value"
			{
			present_value_ = new Debug_Byte();
			int t_present_value__size;
			t_present_value__size = present_value_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_present_value__size;
			}
			break;
		case 22529:
			// Parse "snapshot"
			{
			snapshot_ = new Debug_Byte();
			int t_snapshot__size;
			t_snapshot__size = snapshot_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_snapshot__size;
			}
			break;
		case 23297:
			// Parse "activate_conf"
			{
			activate_conf_ = new ActivateConf();
			int t_activate_conf__size;
			t_activate_conf__size = activate_conf_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_activate_conf__size;
			}
			break;
		case 25857:
			// Parse "bcd_small"
			{
			// Checking out-of-bound for "Request_Data_Object:bcd_small"
			if ( t_dataptr_after_prefix + (2) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Request_Data_Object:bcd_small",
					((t_dataptr_after_prefix - t_begin_of_data)) + (2), 
					(t_end_of_data) - (t_begin_of_data));
				}
			bcd_small_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_dataptr_after_prefix)));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 2;
			}
			break;
		case 25858:
			// Parse "bcd_medium"
			{
			// Checking out-of-bound for "Request_Data_Object:bcd_medium"
			if ( t_dataptr_after_prefix + (4) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Request_Data_Object:bcd_medium",
					((t_dataptr_after_prefix - t_begin_of_data)) + (4), 
					(t_end_of_data) - (t_begin_of_data));
				}
			bcd_medium_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_dataptr_after_prefix)));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 4;
			}
			break;
		case 25859:
			// Parse "bcd_large"
			{
			bcd_large_ = new BCD_Large();
			bcd_large_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 8;
			}
			break;
		case 26113:
			// Parse "unsigned_integer"
			{
			// Checking out-of-bound for "Request_Data_Object:unsigned_integer"
			if ( t_dataptr_after_prefix + (1) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Request_Data_Object:unsigned_integer",
					((t_dataptr_after_prefix - t_begin_of_data)) + (1), 
					(t_end_of_data) - (t_begin_of_data));
				}
			unsigned_integer_ = *((uint8 const *) (t_dataptr_after_prefix));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 1;
			}
			break;
		case 30721:
			// Parse "challenge"
			{
			challenge_ = new AuthChallenge(prefix()->prefix_value());
			int t_challenge__size;
			t_challenge__size = challenge_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_challenge__size;
			}
			break;
		case 30722:
			// Parse "reply"
			{
			reply_ = new AuthRely(prefix()->prefix_value());
			int t_reply__size;
			t_reply__size = reply_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_reply__size;
			}
			break;
		case 30723:
			// Parse "aggrRequest"
			{
			aggrRequest_ = new AuthAggrRequest(prefix()->prefix_value());
			int t_aggrRequest__size;
			t_aggrRequest__size = aggrRequest_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_aggrRequest__size;
			}
			break;
		case 30724:
			// Parse "seesionKeyRequest"
			{
			// Checking out-of-bound for "Request_Data_Object:seesionKeyRequest"
			if ( t_dataptr_after_prefix + (1) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Request_Data_Object:seesionKeyRequest",
					((t_dataptr_after_prefix - t_begin_of_data)) + (1), 
					(t_end_of_data) - (t_begin_of_data));
				}
			seesionKeyRequest_ = *((uint8 const *) (t_dataptr_after_prefix));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 1;
			}
			break;
		case 30725:
			// Parse "status"
			{
			status_ = new AuthSessionKeyStatus(prefix()->prefix_value());
			int t_status__size;
			t_status__size = status_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_status__size;
			}
			break;
		case 30726:
			// Parse "keyChange"
			{
			keyChange_ = new AuthSessionKeyChange(prefix()->prefix_value());
			int t_keyChange__size;
			t_keyChange__size = keyChange_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_keyChange__size;
			}
			break;
		case 30727:
			// Parse "error"
			{
			error_ = new AuthError(prefix()->prefix_value());
			int t_error__size;
			t_error__size = error_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_error__size;
			}
			break;
		default:
			// Parse "unmatched"
			{
			unmatched_ = new Default_Wrap(object_type_field());
			int t_unmatched__size;
			t_unmatched__size = unmatched_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_unmatched__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_Request_Data_Object__size;
	const_byteptr const t_dataptr_after_data = t_dataptr_after_prefix + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_Request_Data_Object__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Request_Data_Object__size) <= t_end_of_data);
	return t_Request_Data_Object__size;
	}

Response_Data_Object::Response_Data_Object(uint8 function_code, uint8 qualifier_field, uint16 object_type_field)
	{
	prefix_ = 0;
	data_case_index_ = -1;
	attrib211_ = 0;
	attrib212_ = 0;
	attrib213_ = 0;
	attrib214_ = 0;
	attrib215_ = 0;
	attrib216_ = 0;
	attrib217_ = 0;
	attrib218_ = 0;
	attrib219_ = 0;
	attrib220_ = 0;
	attrib221_ = 0;
	attrib222_ = 0;
	attrib223_ = 0;
	attrib224_ = 0;
	attrib225_ = 0;
	attrib226_ = 0;
	attrib227_ = 0;
	attrib228_ = 0;
	attrib229_ = 0;
	attrib230_ = 0;
	attrib231_ = 0;
	attrib232_ = 0;
	attrib233_ = 0;
	attrib234_ = 0;
	attrib235_ = 0;
	attrib236_ = 0;
	attrib237_ = 0;
	attrib238_ = 0;
	attrib239_ = 0;
	attrib240_ = 0;
	attrib241_ = 0;
	attrib242_ = 0;
	attrib243_ = 0;
	attrib245_ = 0;
	attrib246_ = 0;
	attrib247_ = 0;
	attrib248_ = 0;
	attrib249_ = 0;
	attrib250_ = 0;
	attrib252_ = 0;
	attrib254_ = 0;
	attrib255_ = 0;
	biwoflag_ = 0;
	biwflag_ = 0;
	biewoflag_ = 0;
	biewatime_ = 0;
	biewrtime_ = 0;
	dbiflag_ = 0;
	dbieatime_ = 0;
	dbiertime_ = 0;
	bowoflag_ = 0;
	bowflag_ = 0;
	boewflag_ = 0;
	boewatime_ = 0;
	bocmd_CROB_ = 0;
	bocmd_PCB_ = 0;
	bocmd_PM_ = 0;
	boceFlag_ = 0;
	boceAtime_ = 0;
	counter_32_wflag_ = 0;
	counter_16_wflag_ = 0;
	counter_32_wflag_delta_ = 0;
	counter_16_wflag_delta_ = 0;
	counter_32_woflag_ = 0;
	counter_16_woflag_ = 0;
	counter_32_woflag_delta_ = 0;
	counter_16_woflag_delta_ = 0;
	f_counter_32_wflag_ = 0;
	f_counter_16_wflag_ = 0;
	f_counter_32_wflag_delta_ = 0;
	f_counter_16_wflag_delta_ = 0;
	f_counter_32_wflag_time_ = 0;
	f_counter_16_wflag_time_ = 0;
	f_counter_32_wflag_time_delta_ = 0;
	f_counter_16_wflag_time_delta_ = 0;
	f_counter_32_woflag_ = 0;
	f_counter_16_woflag_ = 0;
	f_counter_32_woflag_delta_ = 0;
	f_counter_16_woflag_delta_ = 0;
	counter_event_32_wflag_ = 0;
	counter_event_16_wflag_ = 0;
	counter_event_32_wflag_delta_ = 0;
	counter_event_16_wflag_delta_ = 0;
	counter_event_32_wflag_time_ = 0;
	counter_event_16_wflag_time_ = 0;
	counter_event_32_wflag_time_delta_ = 0;
	counter_event_16_wflag_time_delat_ = 0;
	f_counter_event_32_wflag_ = 0;
	f_counter_event_16_wflag_ = 0;
	f_counter_event_32_wflag_delta_ = 0;
	f_counter_event_16_wflag_delta_ = 0;
	f_counter_event_32_wflag_time_ = 0;
	f_counter_event_16_wflag_time_ = 0;
	f_counter_event_32_wflag_time_delta_ = 0;
	f_counter_event_16_wflag_time_delat_ = 0;
	ai_32_wflag_ = 0;
	ai_16_wflag_ = 0;
	ai_32_woflag_ = 0;
	ai_16_woflag_ = 0;
	ai_sp_wflag_ = 0;
	ai_dp_wflag_ = 0;
	f_ai_32_wflag_ = 0;
	f_ai_16_wflag_ = 0;
	f_ai_32_wtime_ = 0;
	f_ai_16_wtime_ = 0;
	f_ai_32_woflag_ = 0;
	f_ai_16_woflag_ = 0;
	f_ai_sp_wflag_ = 0;
	f_ai_dp_wflag_ = 0;
	ai32wotime_ = 0;
	ai16wotime_ = 0;
	ai32wtime_ = 0;
	ai16wtime_ = 0;
	aispwotime_ = 0;
	aidpwotime_ = 0;
	aispwtime_ = 0;
	aidpwtime_ = 0;
	faie_32_wotime_ = 0;
	faie_16_wotime_ = 0;
	faie_32_wtime_ = 0;
	faie_16_wtime_ = 0;
	faie_sp_wotime_ = 0;
	faie_dp_wotime_ = 0;
	faie_sp_wtime_ = 0;
	faie_dp_wtime_ = 0;
	ai_dead_16_ = 0;
	ai_dead_32_ = 0;
	ai_dead_sp_ = 0;
	aos_32_ = 0;
	aos_16_ = 0;
	aos_sp_ = 0;
	aos_dp_ = 0;
	ao_32_ = 0;
	ao_16_ = 0;
	ao_sp_ = 0;
	ao_dp_ = 0;
	aoe32wotime_ = 0;
	aoe16wotime_ = 0;
	aoe32wtime_ = 0;
	aoe16wtime_ = 0;
	aoespwotime_ = 0;
	aoedpwotime_ = 0;
	aoespwtime_ = 0;
	aoedpwtime_ = 0;
	aoce32wotime_ = 0;
	aoce16wotime_ = 0;
	aoce32wtime_ = 0;
	aoce16wtime_ = 0;
	aocespwotime_ = 0;
	aocedpwotime_ = 0;
	aocespwtime_ = 0;
	aocedpwtime_ = 0;
	time_abs_ = 0;
	time_interval_ = 0;
	time_abs_last_ = 0;
	time_abs_sync_ = 0;
	time_abs_unsync_ = 0;
	time_coarse_ = 0;
	time_fine_ = 0;
	file_control_id_ = 0;
	file_control_auth_ = 0;
	file_control_cmd_ = 0;
	file_control_cmd_status_ = 0;
	file_trans_ = 0;
	file_trans_status_ = 0;
	file_desc_ = 0;
	iin_ = 0;
	dev_store_ = 0;
	dev_profile_ = 0;
	priregobj_ = 0;
	priregobjdesc_ = 0;
	desc_ele_ = 0;
	desc_ele86_ = 0;
	cha_ = 0;
	point_index_attr_ = 0;
	present_value_ = 0;
	snapshot_ = 0;
	activate_conf_ = 0;
	bcd_small_ = 0;
	bcd_medium_ = 0;
	bcd_large_ = 0;
	unsigned_integer_ = 0;
	challenge_ = 0;
	reply_ = 0;
	aggrRequest_ = 0;
	seesionKeyRequest_ = 0;
	status_ = 0;
	keyChange_ = 0;
	error_ = 0;
	unmatched_ = 0;
	function_code_ = function_code;
	qualifier_field_ = qualifier_field;
	object_type_field_ = object_type_field;
	data_value_ = 0;
	process_request_ = 0;
	}

Response_Data_Object::~Response_Data_Object()
	{
	delete prefix_;
	prefix_ = 0;
	switch ( data_case_index() )
		{
		case 211:
			// Clean up "attrib211"
			{
			delete attrib211_;
			attrib211_ = 0;
			}
			break;
		case 212:
			// Clean up "attrib212"
			{
			delete attrib212_;
			attrib212_ = 0;
			}
			break;
		case 213:
			// Clean up "attrib213"
			{
			delete attrib213_;
			attrib213_ = 0;
			}
			break;
		case 214:
			// Clean up "attrib214"
			{
			delete attrib214_;
			attrib214_ = 0;
			}
			break;
		case 215:
			// Clean up "attrib215"
			{
			delete attrib215_;
			attrib215_ = 0;
			}
			break;
		case 216:
			// Clean up "attrib216"
			{
			delete attrib216_;
			attrib216_ = 0;
			}
			break;
		case 217:
			// Clean up "attrib217"
			{
			delete attrib217_;
			attrib217_ = 0;
			}
			break;
		case 218:
			// Clean up "attrib218"
			{
			delete attrib218_;
			attrib218_ = 0;
			}
			break;
		case 219:
			// Clean up "attrib219"
			{
			delete attrib219_;
			attrib219_ = 0;
			}
			break;
		case 220:
			// Clean up "attrib220"
			{
			delete attrib220_;
			attrib220_ = 0;
			}
			break;
		case 221:
			// Clean up "attrib221"
			{
			delete attrib221_;
			attrib221_ = 0;
			}
			break;
		case 222:
			// Clean up "attrib222"
			{
			delete attrib222_;
			attrib222_ = 0;
			}
			break;
		case 223:
			// Clean up "attrib223"
			{
			delete attrib223_;
			attrib223_ = 0;
			}
			break;
		case 224:
			// Clean up "attrib224"
			{
			delete attrib224_;
			attrib224_ = 0;
			}
			break;
		case 225:
			// Clean up "attrib225"
			{
			delete attrib225_;
			attrib225_ = 0;
			}
			break;
		case 226:
			// Clean up "attrib226"
			{
			delete attrib226_;
			attrib226_ = 0;
			}
			break;
		case 227:
			// Clean up "attrib227"
			{
			delete attrib227_;
			attrib227_ = 0;
			}
			break;
		case 228:
			// Clean up "attrib228"
			{
			delete attrib228_;
			attrib228_ = 0;
			}
			break;
		case 229:
			// Clean up "attrib229"
			{
			delete attrib229_;
			attrib229_ = 0;
			}
			break;
		case 230:
			// Clean up "attrib230"
			{
			delete attrib230_;
			attrib230_ = 0;
			}
			break;
		case 231:
			// Clean up "attrib231"
			{
			delete attrib231_;
			attrib231_ = 0;
			}
			break;
		case 232:
			// Clean up "attrib232"
			{
			delete attrib232_;
			attrib232_ = 0;
			}
			break;
		case 233:
			// Clean up "attrib233"
			{
			delete attrib233_;
			attrib233_ = 0;
			}
			break;
		case 234:
			// Clean up "attrib234"
			{
			delete attrib234_;
			attrib234_ = 0;
			}
			break;
		case 235:
			// Clean up "attrib235"
			{
			delete attrib235_;
			attrib235_ = 0;
			}
			break;
		case 236:
			// Clean up "attrib236"
			{
			delete attrib236_;
			attrib236_ = 0;
			}
			break;
		case 237:
			// Clean up "attrib237"
			{
			delete attrib237_;
			attrib237_ = 0;
			}
			break;
		case 238:
			// Clean up "attrib238"
			{
			delete attrib238_;
			attrib238_ = 0;
			}
			break;
		case 239:
			// Clean up "attrib239"
			{
			delete attrib239_;
			attrib239_ = 0;
			}
			break;
		case 240:
			// Clean up "attrib240"
			{
			delete attrib240_;
			attrib240_ = 0;
			}
			break;
		case 241:
			// Clean up "attrib241"
			{
			delete attrib241_;
			attrib241_ = 0;
			}
			break;
		case 242:
			// Clean up "attrib242"
			{
			delete attrib242_;
			attrib242_ = 0;
			}
			break;
		case 243:
			// Clean up "attrib243"
			{
			delete attrib243_;
			attrib243_ = 0;
			}
			break;
		case 245:
			// Clean up "attrib245"
			{
			delete attrib245_;
			attrib245_ = 0;
			}
			break;
		case 246:
			// Clean up "attrib246"
			{
			delete attrib246_;
			attrib246_ = 0;
			}
			break;
		case 247:
			// Clean up "attrib247"
			{
			delete attrib247_;
			attrib247_ = 0;
			}
			break;
		case 248:
			// Clean up "attrib248"
			{
			delete attrib248_;
			attrib248_ = 0;
			}
			break;
		case 249:
			// Clean up "attrib249"
			{
			delete attrib249_;
			attrib249_ = 0;
			}
			break;
		case 250:
			// Clean up "attrib250"
			{
			delete attrib250_;
			attrib250_ = 0;
			}
			break;
		case 252:
			// Clean up "attrib252"
			{
			delete attrib252_;
			attrib252_ = 0;
			}
			break;
		case 254:
			// Clean up "attrib254"
			{
			delete attrib254_;
			attrib254_ = 0;
			}
			break;
		case 255:
			// Clean up "attrib255"
			{
			delete attrib255_;
			attrib255_ = 0;
			}
			break;
		case 257:
			// Clean up "biwoflag"
			{
			}
			break;
		case 258:
			// Clean up "biwflag"
			{
			}
			break;
		case 513:
			// Clean up "biewoflag"
			{
			}
			break;
		case 514:
			// Clean up "biewatime"
			{
			delete biewatime_;
			biewatime_ = 0;
			}
			break;
		case 515:
			// Clean up "biewrtime"
			{
			delete biewrtime_;
			biewrtime_ = 0;
			}
			break;
		case 769:
			// Clean up "dbibytes"
			{
			dbibytes_.free();
			}
			break;
		case 770:
			// Clean up "dbiflag"
			{
			}
			break;
		case 1025:
			// Clean up "dbieatime"
			{
			delete dbieatime_;
			dbieatime_ = 0;
			}
			break;
		case 1026:
			// Clean up "dbiertime"
			{
			delete dbiertime_;
			dbiertime_ = 0;
			}
			break;
		case 2561:
			// Clean up "bowoflag"
			{
			}
			break;
		case 2562:
			// Clean up "bowflag"
			{
			}
			break;
		case 2817:
			// Clean up "boewflag"
			{
			}
			break;
		case 2818:
			// Clean up "boewatime"
			{
			delete boewatime_;
			boewatime_ = 0;
			}
			break;
		case 3073:
			// Clean up "bocmd_CROB"
			{
			delete bocmd_CROB_;
			bocmd_CROB_ = 0;
			}
			break;
		case 3074:
			// Clean up "bocmd_PCB"
			{
			delete bocmd_PCB_;
			bocmd_PCB_ = 0;
			}
			break;
		case 3075:
			// Clean up "bocmd_PM"
			{
			}
			break;
		case 3329:
			// Clean up "boceFlag"
			{
			}
			break;
		case 3330:
			// Clean up "boceAtime"
			{
			delete boceAtime_;
			boceAtime_ = 0;
			}
			break;
		case 5121:
			// Clean up "counter_32_wflag"
			{
			delete counter_32_wflag_;
			counter_32_wflag_ = 0;
			}
			break;
		case 5122:
			// Clean up "counter_16_wflag"
			{
			delete counter_16_wflag_;
			counter_16_wflag_ = 0;
			}
			break;
		case 5123:
			// Clean up "counter_32_wflag_delta"
			{
			delete counter_32_wflag_delta_;
			counter_32_wflag_delta_ = 0;
			}
			break;
		case 5124:
			// Clean up "counter_16_wflag_delta"
			{
			delete counter_16_wflag_delta_;
			counter_16_wflag_delta_ = 0;
			}
			break;
		case 5125:
			// Clean up "counter_32_woflag"
			{
			delete counter_32_woflag_;
			counter_32_woflag_ = 0;
			}
			break;
		case 5126:
			// Clean up "counter_16_woflag"
			{
			delete counter_16_woflag_;
			counter_16_woflag_ = 0;
			}
			break;
		case 5127:
			// Clean up "counter_32_woflag_delta"
			{
			delete counter_32_woflag_delta_;
			counter_32_woflag_delta_ = 0;
			}
			break;
		case 5128:
			// Clean up "counter_16_woflag_delta"
			{
			delete counter_16_woflag_delta_;
			counter_16_woflag_delta_ = 0;
			}
			break;
		case 5377:
			// Clean up "f_counter_32_wflag"
			{
			delete f_counter_32_wflag_;
			f_counter_32_wflag_ = 0;
			}
			break;
		case 5378:
			// Clean up "f_counter_16_wflag"
			{
			delete f_counter_16_wflag_;
			f_counter_16_wflag_ = 0;
			}
			break;
		case 5379:
			// Clean up "f_counter_32_wflag_delta"
			{
			delete f_counter_32_wflag_delta_;
			f_counter_32_wflag_delta_ = 0;
			}
			break;
		case 5380:
			// Clean up "f_counter_16_wflag_delta"
			{
			delete f_counter_16_wflag_delta_;
			f_counter_16_wflag_delta_ = 0;
			}
			break;
		case 5381:
			// Clean up "f_counter_32_wflag_time"
			{
			delete f_counter_32_wflag_time_;
			f_counter_32_wflag_time_ = 0;
			}
			break;
		case 5382:
			// Clean up "f_counter_16_wflag_time"
			{
			delete f_counter_16_wflag_time_;
			f_counter_16_wflag_time_ = 0;
			}
			break;
		case 5383:
			// Clean up "f_counter_32_wflag_time_delta"
			{
			delete f_counter_32_wflag_time_delta_;
			f_counter_32_wflag_time_delta_ = 0;
			}
			break;
		case 5384:
			// Clean up "f_counter_16_wflag_time_delta"
			{
			delete f_counter_16_wflag_time_delta_;
			f_counter_16_wflag_time_delta_ = 0;
			}
			break;
		case 5385:
			// Clean up "f_counter_32_woflag"
			{
			delete f_counter_32_woflag_;
			f_counter_32_woflag_ = 0;
			}
			break;
		case 5386:
			// Clean up "f_counter_16_woflag"
			{
			delete f_counter_16_woflag_;
			f_counter_16_woflag_ = 0;
			}
			break;
		case 5387:
			// Clean up "f_counter_32_woflag_delta"
			{
			delete f_counter_32_woflag_delta_;
			f_counter_32_woflag_delta_ = 0;
			}
			break;
		case 5388:
			// Clean up "f_counter_16_woflag_delta"
			{
			delete f_counter_16_woflag_delta_;
			f_counter_16_woflag_delta_ = 0;
			}
			break;
		case 5633:
			// Clean up "counter_event_32_wflag"
			{
			delete counter_event_32_wflag_;
			counter_event_32_wflag_ = 0;
			}
			break;
		case 5634:
			// Clean up "counter_event_16_wflag"
			{
			delete counter_event_16_wflag_;
			counter_event_16_wflag_ = 0;
			}
			break;
		case 5635:
			// Clean up "counter_event_32_wflag_delta"
			{
			delete counter_event_32_wflag_delta_;
			counter_event_32_wflag_delta_ = 0;
			}
			break;
		case 5636:
			// Clean up "counter_event_16_wflag_delta"
			{
			delete counter_event_16_wflag_delta_;
			counter_event_16_wflag_delta_ = 0;
			}
			break;
		case 5637:
			// Clean up "counter_event_32_wflag_time"
			{
			delete counter_event_32_wflag_time_;
			counter_event_32_wflag_time_ = 0;
			}
			break;
		case 5638:
			// Clean up "counter_event_16_wflag_time"
			{
			delete counter_event_16_wflag_time_;
			counter_event_16_wflag_time_ = 0;
			}
			break;
		case 5639:
			// Clean up "counter_event_32_wflag_time_delta"
			{
			delete counter_event_32_wflag_time_delta_;
			counter_event_32_wflag_time_delta_ = 0;
			}
			break;
		case 5640:
			// Clean up "counter_event_16_wflag_time_delat"
			{
			delete counter_event_16_wflag_time_delat_;
			counter_event_16_wflag_time_delat_ = 0;
			}
			break;
		case 5889:
			// Clean up "f_counter_event_32_wflag"
			{
			delete f_counter_event_32_wflag_;
			f_counter_event_32_wflag_ = 0;
			}
			break;
		case 5890:
			// Clean up "f_counter_event_16_wflag"
			{
			delete f_counter_event_16_wflag_;
			f_counter_event_16_wflag_ = 0;
			}
			break;
		case 5891:
			// Clean up "f_counter_event_32_wflag_delta"
			{
			delete f_counter_event_32_wflag_delta_;
			f_counter_event_32_wflag_delta_ = 0;
			}
			break;
		case 5892:
			// Clean up "f_counter_event_16_wflag_delta"
			{
			delete f_counter_event_16_wflag_delta_;
			f_counter_event_16_wflag_delta_ = 0;
			}
			break;
		case 5893:
			// Clean up "f_counter_event_32_wflag_time"
			{
			delete f_counter_event_32_wflag_time_;
			f_counter_event_32_wflag_time_ = 0;
			}
			break;
		case 5894:
			// Clean up "f_counter_event_16_wflag_time"
			{
			delete f_counter_event_16_wflag_time_;
			f_counter_event_16_wflag_time_ = 0;
			}
			break;
		case 5895:
			// Clean up "f_counter_event_32_wflag_time_delta"
			{
			delete f_counter_event_32_wflag_time_delta_;
			f_counter_event_32_wflag_time_delta_ = 0;
			}
			break;
		case 5896:
			// Clean up "f_counter_event_16_wflag_time_delat"
			{
			delete f_counter_event_16_wflag_time_delat_;
			f_counter_event_16_wflag_time_delat_ = 0;
			}
			break;
		case 7681:
			// Clean up "ai_32_wflag"
			{
			delete ai_32_wflag_;
			ai_32_wflag_ = 0;
			}
			break;
		case 7682:
			// Clean up "ai_16_wflag"
			{
			delete ai_16_wflag_;
			ai_16_wflag_ = 0;
			}
			break;
		case 7683:
			// Clean up "ai_32_woflag"
			{
			delete ai_32_woflag_;
			ai_32_woflag_ = 0;
			}
			break;
		case 7684:
			// Clean up "ai_16_woflag"
			{
			delete ai_16_woflag_;
			ai_16_woflag_ = 0;
			}
			break;
		case 7685:
			// Clean up "ai_sp_wflag"
			{
			delete ai_sp_wflag_;
			ai_sp_wflag_ = 0;
			}
			break;
		case 7686:
			// Clean up "ai_dp_wflag"
			{
			delete ai_dp_wflag_;
			ai_dp_wflag_ = 0;
			}
			break;
		case 7937:
			// Clean up "f_ai_32_wflag"
			{
			delete f_ai_32_wflag_;
			f_ai_32_wflag_ = 0;
			}
			break;
		case 7938:
			// Clean up "f_ai_16_wflag"
			{
			delete f_ai_16_wflag_;
			f_ai_16_wflag_ = 0;
			}
			break;
		case 7939:
			// Clean up "f_ai_32_wtime"
			{
			delete f_ai_32_wtime_;
			f_ai_32_wtime_ = 0;
			}
			break;
		case 7940:
			// Clean up "f_ai_16_wtime"
			{
			delete f_ai_16_wtime_;
			f_ai_16_wtime_ = 0;
			}
			break;
		case 7941:
			// Clean up "f_ai_32_woflag"
			{
			delete f_ai_32_woflag_;
			f_ai_32_woflag_ = 0;
			}
			break;
		case 7942:
			// Clean up "f_ai_16_woflag"
			{
			delete f_ai_16_woflag_;
			f_ai_16_woflag_ = 0;
			}
			break;
		case 7943:
			// Clean up "f_ai_sp_wflag"
			{
			delete f_ai_sp_wflag_;
			f_ai_sp_wflag_ = 0;
			}
			break;
		case 7944:
			// Clean up "f_ai_dp_wflag"
			{
			delete f_ai_dp_wflag_;
			f_ai_dp_wflag_ = 0;
			}
			break;
		case 8193:
			// Clean up "ai32wotime"
			{
			delete ai32wotime_;
			ai32wotime_ = 0;
			}
			break;
		case 8194:
			// Clean up "ai16wotime"
			{
			delete ai16wotime_;
			ai16wotime_ = 0;
			}
			break;
		case 8195:
			// Clean up "ai32wtime"
			{
			delete ai32wtime_;
			ai32wtime_ = 0;
			}
			break;
		case 8196:
			// Clean up "ai16wtime"
			{
			delete ai16wtime_;
			ai16wtime_ = 0;
			}
			break;
		case 8197:
			// Clean up "aispwotime"
			{
			delete aispwotime_;
			aispwotime_ = 0;
			}
			break;
		case 8198:
			// Clean up "aidpwotime"
			{
			delete aidpwotime_;
			aidpwotime_ = 0;
			}
			break;
		case 8199:
			// Clean up "aispwtime"
			{
			delete aispwtime_;
			aispwtime_ = 0;
			}
			break;
		case 8200:
			// Clean up "aidpwtime"
			{
			delete aidpwtime_;
			aidpwtime_ = 0;
			}
			break;
		case 8449:
			// Clean up "faie_32_wotime"
			{
			delete faie_32_wotime_;
			faie_32_wotime_ = 0;
			}
			break;
		case 8450:
			// Clean up "faie_16_wotime"
			{
			delete faie_16_wotime_;
			faie_16_wotime_ = 0;
			}
			break;
		case 8451:
			// Clean up "faie_32_wtime"
			{
			delete faie_32_wtime_;
			faie_32_wtime_ = 0;
			}
			break;
		case 8452:
			// Clean up "faie_16_wtime"
			{
			delete faie_16_wtime_;
			faie_16_wtime_ = 0;
			}
			break;
		case 8453:
			// Clean up "faie_sp_wotime"
			{
			delete faie_sp_wotime_;
			faie_sp_wotime_ = 0;
			}
			break;
		case 8454:
			// Clean up "faie_dp_wotime"
			{
			delete faie_dp_wotime_;
			faie_dp_wotime_ = 0;
			}
			break;
		case 8455:
			// Clean up "faie_sp_wtime"
			{
			delete faie_sp_wtime_;
			faie_sp_wtime_ = 0;
			}
			break;
		case 8456:
			// Clean up "faie_dp_wtime"
			{
			delete faie_dp_wtime_;
			faie_dp_wtime_ = 0;
			}
			break;
		case 8705:
			// Clean up "ai_dead_16"
			{
			}
			break;
		case 8706:
			// Clean up "ai_dead_32"
			{
			}
			break;
		case 8707:
			// Clean up "ai_dead_sp"
			{
			}
			break;
		case 10241:
			// Clean up "aos_32"
			{
			delete aos_32_;
			aos_32_ = 0;
			}
			break;
		case 10242:
			// Clean up "aos_16"
			{
			delete aos_16_;
			aos_16_ = 0;
			}
			break;
		case 10243:
			// Clean up "aos_sp"
			{
			delete aos_sp_;
			aos_sp_ = 0;
			}
			break;
		case 10244:
			// Clean up "aos_dp"
			{
			delete aos_dp_;
			aos_dp_ = 0;
			}
			break;
		case 10497:
			// Clean up "ao_32"
			{
			delete ao_32_;
			ao_32_ = 0;
			}
			break;
		case 10498:
			// Clean up "ao_16"
			{
			delete ao_16_;
			ao_16_ = 0;
			}
			break;
		case 10499:
			// Clean up "ao_sp"
			{
			delete ao_sp_;
			ao_sp_ = 0;
			}
			break;
		case 10500:
			// Clean up "ao_dp"
			{
			delete ao_dp_;
			ao_dp_ = 0;
			}
			break;
		case 10753:
			// Clean up "aoe32wotime"
			{
			delete aoe32wotime_;
			aoe32wotime_ = 0;
			}
			break;
		case 10754:
			// Clean up "aoe16wotime"
			{
			delete aoe16wotime_;
			aoe16wotime_ = 0;
			}
			break;
		case 10755:
			// Clean up "aoe32wtime"
			{
			delete aoe32wtime_;
			aoe32wtime_ = 0;
			}
			break;
		case 10756:
			// Clean up "aoe16wtime"
			{
			delete aoe16wtime_;
			aoe16wtime_ = 0;
			}
			break;
		case 10757:
			// Clean up "aoespwotime"
			{
			delete aoespwotime_;
			aoespwotime_ = 0;
			}
			break;
		case 10758:
			// Clean up "aoedpwotime"
			{
			delete aoedpwotime_;
			aoedpwotime_ = 0;
			}
			break;
		case 10759:
			// Clean up "aoespwtime"
			{
			delete aoespwtime_;
			aoespwtime_ = 0;
			}
			break;
		case 10760:
			// Clean up "aoedpwtime"
			{
			delete aoedpwtime_;
			aoedpwtime_ = 0;
			}
			break;
		case 11009:
			// Clean up "aoce32wotime"
			{
			delete aoce32wotime_;
			aoce32wotime_ = 0;
			}
			break;
		case 11010:
			// Clean up "aoce16wotime"
			{
			delete aoce16wotime_;
			aoce16wotime_ = 0;
			}
			break;
		case 11011:
			// Clean up "aoce32wtime"
			{
			delete aoce32wtime_;
			aoce32wtime_ = 0;
			}
			break;
		case 11012:
			// Clean up "aoce16wtime"
			{
			delete aoce16wtime_;
			aoce16wtime_ = 0;
			}
			break;
		case 11013:
			// Clean up "aocespwotime"
			{
			delete aocespwotime_;
			aocespwotime_ = 0;
			}
			break;
		case 11014:
			// Clean up "aocedpwotime"
			{
			delete aocedpwotime_;
			aocedpwotime_ = 0;
			}
			break;
		case 11015:
			// Clean up "aocespwtime"
			{
			delete aocespwtime_;
			aocespwtime_ = 0;
			}
			break;
		case 11016:
			// Clean up "aocedpwtime"
			{
			delete aocedpwtime_;
			aocedpwtime_ = 0;
			}
			break;
		case 12801:
			// Clean up "time_abs"
			{
			delete time_abs_;
			time_abs_ = 0;
			}
			break;
		case 12802:
			// Clean up "time_interval"
			{
			delete time_interval_;
			time_interval_ = 0;
			}
			break;
		case 12803:
			// Clean up "time_abs_last"
			{
			delete time_abs_last_;
			time_abs_last_ = 0;
			}
			break;
		case 13057:
			// Clean up "time_abs_sync"
			{
			delete time_abs_sync_;
			time_abs_sync_ = 0;
			}
			break;
		case 13058:
			// Clean up "time_abs_unsync"
			{
			delete time_abs_unsync_;
			time_abs_unsync_ = 0;
			}
			break;
		case 13313:
			// Clean up "time_coarse"
			{
			}
			break;
		case 13314:
			// Clean up "time_fine"
			{
			}
			break;
		case 17921:
			// Clean up "file_control_id"
			{
			delete file_control_id_;
			file_control_id_ = 0;
			}
			break;
		case 17922:
			// Clean up "file_control_auth"
			{
			delete file_control_auth_;
			file_control_auth_ = 0;
			}
			break;
		case 17923:
			// Clean up "file_control_cmd"
			{
			delete file_control_cmd_;
			file_control_cmd_ = 0;
			}
			break;
		case 17924:
			// Clean up "file_control_cmd_status"
			{
			delete file_control_cmd_status_;
			file_control_cmd_status_ = 0;
			}
			break;
		case 17925:
			// Clean up "file_trans"
			{
			delete file_trans_;
			file_trans_ = 0;
			}
			break;
		case 17926:
			// Clean up "file_trans_status"
			{
			delete file_trans_status_;
			file_trans_status_ = 0;
			}
			break;
		case 17927:
			// Clean up "file_desc"
			{
			delete file_desc_;
			file_desc_ = 0;
			}
			break;
		case 20481:
			// Clean up "iin"
			{
			}
			break;
		case 20737:
			// Clean up "dev_store"
			{
			delete dev_store_;
			dev_store_ = 0;
			}
			break;
		case 20993:
			// Clean up "dev_profile"
			{
			delete dev_profile_;
			dev_profile_ = 0;
			}
			break;
		case 21249:
			// Clean up "priregobj"
			{
			delete priregobj_;
			priregobj_ = 0;
			}
			break;
		case 21250:
			// Clean up "priregobjdesc"
			{
			delete priregobjdesc_;
			priregobjdesc_ = 0;
			}
			break;
		case 21761:
			// Clean up "desc_ele"
			{
			delete desc_ele_;
			desc_ele_ = 0;
			}
			break;
		case 22017:
			// Clean up "desc_ele86"
			{
			delete desc_ele86_;
			desc_ele86_ = 0;
			}
			break;
		case 22018:
			// Clean up "cha"
			{
			}
			break;
		case 22019:
			// Clean up "point_index_attr"
			{
			delete point_index_attr_;
			point_index_attr_ = 0;
			}
			break;
		case 22273:
			// Clean up "present_value"
			{
			delete present_value_;
			present_value_ = 0;
			}
			break;
		case 22529:
			// Clean up "snapshot"
			{
			delete snapshot_;
			snapshot_ = 0;
			}
			break;
		case 23297:
			// Clean up "activate_conf"
			{
			delete activate_conf_;
			activate_conf_ = 0;
			}
			break;
		case 25857:
			// Clean up "bcd_small"
			{
			}
			break;
		case 25858:
			// Clean up "bcd_medium"
			{
			}
			break;
		case 25859:
			// Clean up "bcd_large"
			{
			delete bcd_large_;
			bcd_large_ = 0;
			}
			break;
		case 26113:
			// Clean up "unsigned_integer"
			{
			}
			break;
		case 30721:
			// Clean up "challenge"
			{
			delete challenge_;
			challenge_ = 0;
			}
			break;
		case 30722:
			// Clean up "reply"
			{
			delete reply_;
			reply_ = 0;
			}
			break;
		case 30723:
			// Clean up "aggrRequest"
			{
			delete aggrRequest_;
			aggrRequest_ = 0;
			}
			break;
		case 30724:
			// Clean up "seesionKeyRequest"
			{
			}
			break;
		case 30725:
			// Clean up "status"
			{
			delete status_;
			status_ = 0;
			}
			break;
		case 30726:
			// Clean up "keyChange"
			{
			delete keyChange_;
			keyChange_ = 0;
			}
			break;
		case 30727:
			// Clean up "error"
			{
			delete error_;
			error_ = 0;
			}
			break;
		default:
			// Clean up "unmatched"
			{
			delete unmatched_;
			unmatched_ = 0;
			}
			break;
		}
	}

int Response_Data_Object::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context, int t_byteorder)
	{
	// Parse "prefix"
	prefix_ = new Prefix_Type(qualifier_field());
	int t_prefix__size;
	t_prefix__size = prefix_->Parse(t_begin_of_data, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_prefix = t_begin_of_data + (t_prefix__size);
	BINPAC_ASSERT(t_dataptr_after_prefix <= t_end_of_data);
	// Parse "data"
	int t_data__size;
	data_case_index_ =  ( object_type_field() ) ;
	switch ( data_case_index() )
		{
		case 211:
			// Parse "attrib211"
			{
			attrib211_ = new AttributeCommon();
			int t_attrib211__size;
			t_attrib211__size = attrib211_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib211__size;
			}
			break;
		case 212:
			// Parse "attrib212"
			{
			attrib212_ = new AttributeCommon();
			int t_attrib212__size;
			t_attrib212__size = attrib212_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib212__size;
			}
			break;
		case 213:
			// Parse "attrib213"
			{
			attrib213_ = new AttributeCommon();
			int t_attrib213__size;
			t_attrib213__size = attrib213_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib213__size;
			}
			break;
		case 214:
			// Parse "attrib214"
			{
			attrib214_ = new AttributeCommon();
			int t_attrib214__size;
			t_attrib214__size = attrib214_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib214__size;
			}
			break;
		case 215:
			// Parse "attrib215"
			{
			attrib215_ = new AttributeCommon();
			int t_attrib215__size;
			t_attrib215__size = attrib215_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib215__size;
			}
			break;
		case 216:
			// Parse "attrib216"
			{
			attrib216_ = new AttributeCommon();
			int t_attrib216__size;
			t_attrib216__size = attrib216_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib216__size;
			}
			break;
		case 217:
			// Parse "attrib217"
			{
			attrib217_ = new AttributeCommon();
			int t_attrib217__size;
			t_attrib217__size = attrib217_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib217__size;
			}
			break;
		case 218:
			// Parse "attrib218"
			{
			attrib218_ = new AttributeCommon();
			int t_attrib218__size;
			t_attrib218__size = attrib218_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib218__size;
			}
			break;
		case 219:
			// Parse "attrib219"
			{
			attrib219_ = new AttributeCommon();
			int t_attrib219__size;
			t_attrib219__size = attrib219_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib219__size;
			}
			break;
		case 220:
			// Parse "attrib220"
			{
			attrib220_ = new AttributeCommon();
			int t_attrib220__size;
			t_attrib220__size = attrib220_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib220__size;
			}
			break;
		case 221:
			// Parse "attrib221"
			{
			attrib221_ = new AttributeCommon();
			int t_attrib221__size;
			t_attrib221__size = attrib221_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib221__size;
			}
			break;
		case 222:
			// Parse "attrib222"
			{
			attrib222_ = new AttributeCommon();
			int t_attrib222__size;
			t_attrib222__size = attrib222_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib222__size;
			}
			break;
		case 223:
			// Parse "attrib223"
			{
			attrib223_ = new AttributeCommon();
			int t_attrib223__size;
			t_attrib223__size = attrib223_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib223__size;
			}
			break;
		case 224:
			// Parse "attrib224"
			{
			attrib224_ = new AttributeCommon();
			int t_attrib224__size;
			t_attrib224__size = attrib224_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib224__size;
			}
			break;
		case 225:
			// Parse "attrib225"
			{
			attrib225_ = new AttributeCommon();
			int t_attrib225__size;
			t_attrib225__size = attrib225_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib225__size;
			}
			break;
		case 226:
			// Parse "attrib226"
			{
			attrib226_ = new AttributeCommon();
			int t_attrib226__size;
			t_attrib226__size = attrib226_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib226__size;
			}
			break;
		case 227:
			// Parse "attrib227"
			{
			attrib227_ = new AttributeCommon();
			int t_attrib227__size;
			t_attrib227__size = attrib227_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib227__size;
			}
			break;
		case 228:
			// Parse "attrib228"
			{
			attrib228_ = new AttributeCommon();
			int t_attrib228__size;
			t_attrib228__size = attrib228_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib228__size;
			}
			break;
		case 229:
			// Parse "attrib229"
			{
			attrib229_ = new AttributeCommon();
			int t_attrib229__size;
			t_attrib229__size = attrib229_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib229__size;
			}
			break;
		case 230:
			// Parse "attrib230"
			{
			attrib230_ = new AttributeCommon();
			int t_attrib230__size;
			t_attrib230__size = attrib230_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib230__size;
			}
			break;
		case 231:
			// Parse "attrib231"
			{
			attrib231_ = new AttributeCommon();
			int t_attrib231__size;
			t_attrib231__size = attrib231_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib231__size;
			}
			break;
		case 232:
			// Parse "attrib232"
			{
			attrib232_ = new AttributeCommon();
			int t_attrib232__size;
			t_attrib232__size = attrib232_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib232__size;
			}
			break;
		case 233:
			// Parse "attrib233"
			{
			attrib233_ = new AttributeCommon();
			int t_attrib233__size;
			t_attrib233__size = attrib233_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib233__size;
			}
			break;
		case 234:
			// Parse "attrib234"
			{
			attrib234_ = new AttributeCommon();
			int t_attrib234__size;
			t_attrib234__size = attrib234_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib234__size;
			}
			break;
		case 235:
			// Parse "attrib235"
			{
			attrib235_ = new AttributeCommon();
			int t_attrib235__size;
			t_attrib235__size = attrib235_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib235__size;
			}
			break;
		case 236:
			// Parse "attrib236"
			{
			attrib236_ = new AttributeCommon();
			int t_attrib236__size;
			t_attrib236__size = attrib236_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib236__size;
			}
			break;
		case 237:
			// Parse "attrib237"
			{
			attrib237_ = new AttributeCommon();
			int t_attrib237__size;
			t_attrib237__size = attrib237_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib237__size;
			}
			break;
		case 238:
			// Parse "attrib238"
			{
			attrib238_ = new AttributeCommon();
			int t_attrib238__size;
			t_attrib238__size = attrib238_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib238__size;
			}
			break;
		case 239:
			// Parse "attrib239"
			{
			attrib239_ = new AttributeCommon();
			int t_attrib239__size;
			t_attrib239__size = attrib239_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib239__size;
			}
			break;
		case 240:
			// Parse "attrib240"
			{
			attrib240_ = new AttributeCommon();
			int t_attrib240__size;
			t_attrib240__size = attrib240_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib240__size;
			}
			break;
		case 241:
			// Parse "attrib241"
			{
			attrib241_ = new AttributeCommon();
			int t_attrib241__size;
			t_attrib241__size = attrib241_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib241__size;
			}
			break;
		case 242:
			// Parse "attrib242"
			{
			attrib242_ = new AttributeCommon();
			int t_attrib242__size;
			t_attrib242__size = attrib242_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib242__size;
			}
			break;
		case 243:
			// Parse "attrib243"
			{
			attrib243_ = new AttributeCommon();
			int t_attrib243__size;
			t_attrib243__size = attrib243_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib243__size;
			}
			break;
		case 245:
			// Parse "attrib245"
			{
			attrib245_ = new AttributeCommon();
			int t_attrib245__size;
			t_attrib245__size = attrib245_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib245__size;
			}
			break;
		case 246:
			// Parse "attrib246"
			{
			attrib246_ = new AttributeCommon();
			int t_attrib246__size;
			t_attrib246__size = attrib246_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib246__size;
			}
			break;
		case 247:
			// Parse "attrib247"
			{
			attrib247_ = new AttributeCommon();
			int t_attrib247__size;
			t_attrib247__size = attrib247_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib247__size;
			}
			break;
		case 248:
			// Parse "attrib248"
			{
			attrib248_ = new AttributeCommon();
			int t_attrib248__size;
			t_attrib248__size = attrib248_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib248__size;
			}
			break;
		case 249:
			// Parse "attrib249"
			{
			attrib249_ = new AttributeCommon();
			int t_attrib249__size;
			t_attrib249__size = attrib249_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib249__size;
			}
			break;
		case 250:
			// Parse "attrib250"
			{
			attrib250_ = new AttributeCommon();
			int t_attrib250__size;
			t_attrib250__size = attrib250_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib250__size;
			}
			break;
		case 252:
			// Parse "attrib252"
			{
			attrib252_ = new AttributeCommon();
			int t_attrib252__size;
			t_attrib252__size = attrib252_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib252__size;
			}
			break;
		case 254:
			// Parse "attrib254"
			{
			attrib254_ = new AttributeCommon();
			int t_attrib254__size;
			t_attrib254__size = attrib254_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib254__size;
			}
			break;
		case 255:
			// Parse "attrib255"
			{
			attrib255_ = new AttributeCommon();
			int t_attrib255__size;
			t_attrib255__size = attrib255_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_attrib255__size;
			}
			break;
		case 257:
			// Parse "biwoflag"
			{
			// Checking out-of-bound for "Response_Data_Object:biwoflag"
			if ( t_dataptr_after_prefix + (1) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Response_Data_Object:biwoflag",
					((t_dataptr_after_prefix - t_begin_of_data)) + (1), 
					(t_end_of_data) - (t_begin_of_data));
				}
			biwoflag_ = *((uint8 const *) (t_dataptr_after_prefix));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 1;
			}
			break;
		case 258:
			// Parse "biwflag"
			{
			// Checking out-of-bound for "Response_Data_Object:biwflag"
			if ( t_dataptr_after_prefix + (1) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Response_Data_Object:biwflag",
					((t_dataptr_after_prefix - t_begin_of_data)) + (1), 
					(t_end_of_data) - (t_begin_of_data));
				}
			biwflag_ = *((uint8 const *) (t_dataptr_after_prefix));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 1;
			}
			break;
		case 513:
			// Parse "biewoflag"
			{
			// Checking out-of-bound for "Response_Data_Object:biewoflag"
			if ( t_dataptr_after_prefix + (1) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Response_Data_Object:biewoflag",
					((t_dataptr_after_prefix - t_begin_of_data)) + (1), 
					(t_end_of_data) - (t_begin_of_data));
				}
			biewoflag_ = *((uint8 const *) (t_dataptr_after_prefix));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 1;
			}
			break;
		case 514:
			// Parse "biewatime"
			{
			biewatime_ = new BinInEveAtime();
			int t_biewatime__size;
			t_biewatime__size = biewatime_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_biewatime__size;
			}
			break;
		case 515:
			// Parse "biewrtime"
			{
			biewrtime_ = new BinInEveRtime();
			biewrtime_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 3;
			}
			break;
		case 769:
			// Parse "dbibytes"
			{
			int t_dbibytes_string_length;
			t_dbibytes_string_length = (t_end_of_data) - (t_dataptr_after_prefix);
			int t_dbibytes__size;
			t_dbibytes__size = t_dbibytes_string_length;
			// check for negative sizes
			if ( t_dbibytes_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-objects.pac:410", t_dbibytes_string_length);
			dbibytes_.init(t_dataptr_after_prefix, t_dbibytes_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_dbibytes__size;
			}
			break;
		case 770:
			// Parse "dbiflag"
			{
			// Checking out-of-bound for "Response_Data_Object:dbiflag"
			if ( t_dataptr_after_prefix + (1) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Response_Data_Object:dbiflag",
					((t_dataptr_after_prefix - t_begin_of_data)) + (1), 
					(t_end_of_data) - (t_begin_of_data));
				}
			dbiflag_ = *((uint8 const *) (t_dataptr_after_prefix));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 1;
			}
			break;
		case 1025:
			// Parse "dbieatime"
			{
			dbieatime_ = new DoubleInEveAtime();
			int t_dbieatime__size;
			t_dbieatime__size = dbieatime_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_dbieatime__size;
			}
			break;
		case 1026:
			// Parse "dbiertime"
			{
			dbiertime_ = new DoubleInEveRtime();
			dbiertime_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 3;
			}
			break;
		case 2561:
			// Parse "bowoflag"
			{
			// Checking out-of-bound for "Response_Data_Object:bowoflag"
			if ( t_dataptr_after_prefix + (1) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Response_Data_Object:bowoflag",
					((t_dataptr_after_prefix - t_begin_of_data)) + (1), 
					(t_end_of_data) - (t_begin_of_data));
				}
			bowoflag_ = *((uint8 const *) (t_dataptr_after_prefix));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 1;
			}
			break;
		case 2562:
			// Parse "bowflag"
			{
			// Checking out-of-bound for "Response_Data_Object:bowflag"
			if ( t_dataptr_after_prefix + (1) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Response_Data_Object:bowflag",
					((t_dataptr_after_prefix - t_begin_of_data)) + (1), 
					(t_end_of_data) - (t_begin_of_data));
				}
			bowflag_ = *((uint8 const *) (t_dataptr_after_prefix));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 1;
			}
			break;
		case 2817:
			// Parse "boewflag"
			{
			// Checking out-of-bound for "Response_Data_Object:boewflag"
			if ( t_dataptr_after_prefix + (1) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Response_Data_Object:boewflag",
					((t_dataptr_after_prefix - t_begin_of_data)) + (1), 
					(t_end_of_data) - (t_begin_of_data));
				}
			boewflag_ = *((uint8 const *) (t_dataptr_after_prefix));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 1;
			}
			break;
		case 2818:
			// Parse "boewatime"
			{
			boewatime_ = new BinOutEveAtime();
			int t_boewatime__size;
			t_boewatime__size = boewatime_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_boewatime__size;
			}
			break;
		case 3073:
			// Parse "bocmd_CROB"
			{
			bocmd_CROB_ = new CROB();
			bocmd_CROB_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 11;
			}
			break;
		case 3074:
			// Parse "bocmd_PCB"
			{
			bocmd_PCB_ = new PCB();
			bocmd_PCB_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 11;
			}
			break;
		case 3075:
			// Parse "bocmd_PM"
			{
			// Checking out-of-bound for "Response_Data_Object:bocmd_PM"
			if ( t_dataptr_after_prefix + (1) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Response_Data_Object:bocmd_PM",
					((t_dataptr_after_prefix - t_begin_of_data)) + (1), 
					(t_end_of_data) - (t_begin_of_data));
				}
			bocmd_PM_ = *((uint8 const *) (t_dataptr_after_prefix));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 1;
			}
			break;
		case 3329:
			// Parse "boceFlag"
			{
			// Checking out-of-bound for "Response_Data_Object:boceFlag"
			if ( t_dataptr_after_prefix + (1) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Response_Data_Object:boceFlag",
					((t_dataptr_after_prefix - t_begin_of_data)) + (1), 
					(t_end_of_data) - (t_begin_of_data));
				}
			boceFlag_ = *((uint8 const *) (t_dataptr_after_prefix));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 1;
			}
			break;
		case 3330:
			// Parse "boceAtime"
			{
			boceAtime_ = new BinOutCmdEveAtime();
			int t_boceAtime__size;
			t_boceAtime__size = boceAtime_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_boceAtime__size;
			}
			break;
		case 5121:
			// Parse "counter_32_wflag"
			{
			counter_32_wflag_ = new Counter32wFlag();
			counter_32_wflag_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 5;
			}
			break;
		case 5122:
			// Parse "counter_16_wflag"
			{
			counter_16_wflag_ = new Counter16wFlag();
			counter_16_wflag_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 3;
			}
			break;
		case 5123:
			// Parse "counter_32_wflag_delta"
			{
			counter_32_wflag_delta_ = new Debug_Byte();
			int t_counter_32_wflag_delta__size;
			t_counter_32_wflag_delta__size = counter_32_wflag_delta_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_counter_32_wflag_delta__size;
			}
			break;
		case 5124:
			// Parse "counter_16_wflag_delta"
			{
			counter_16_wflag_delta_ = new Debug_Byte();
			int t_counter_16_wflag_delta__size;
			t_counter_16_wflag_delta__size = counter_16_wflag_delta_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_counter_16_wflag_delta__size;
			}
			break;
		case 5125:
			// Parse "counter_32_woflag"
			{
			counter_32_woflag_ = new Counter32woFlag();
			counter_32_woflag_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 4;
			}
			break;
		case 5126:
			// Parse "counter_16_woflag"
			{
			counter_16_woflag_ = new Counter16woFlag();
			counter_16_woflag_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 2;
			}
			break;
		case 5127:
			// Parse "counter_32_woflag_delta"
			{
			counter_32_woflag_delta_ = new Debug_Byte();
			int t_counter_32_woflag_delta__size;
			t_counter_32_woflag_delta__size = counter_32_woflag_delta_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_counter_32_woflag_delta__size;
			}
			break;
		case 5128:
			// Parse "counter_16_woflag_delta"
			{
			counter_16_woflag_delta_ = new Debug_Byte();
			int t_counter_16_woflag_delta__size;
			t_counter_16_woflag_delta__size = counter_16_woflag_delta_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_counter_16_woflag_delta__size;
			}
			break;
		case 5377:
			// Parse "f_counter_32_wflag"
			{
			f_counter_32_wflag_ = new FrozenCounter32wFlag();
			f_counter_32_wflag_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 5;
			}
			break;
		case 5378:
			// Parse "f_counter_16_wflag"
			{
			f_counter_16_wflag_ = new FrozenCounter16wFlag();
			f_counter_16_wflag_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 3;
			}
			break;
		case 5379:
			// Parse "f_counter_32_wflag_delta"
			{
			f_counter_32_wflag_delta_ = new Debug_Byte();
			int t_f_counter_32_wflag_delta__size;
			t_f_counter_32_wflag_delta__size = f_counter_32_wflag_delta_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_f_counter_32_wflag_delta__size;
			}
			break;
		case 5380:
			// Parse "f_counter_16_wflag_delta"
			{
			f_counter_16_wflag_delta_ = new Debug_Byte();
			int t_f_counter_16_wflag_delta__size;
			t_f_counter_16_wflag_delta__size = f_counter_16_wflag_delta_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_f_counter_16_wflag_delta__size;
			}
			break;
		case 5381:
			// Parse "f_counter_32_wflag_time"
			{
			f_counter_32_wflag_time_ = new FrozenCounter32wFlagTime();
			int t_f_counter_32_wflag_time__size;
			t_f_counter_32_wflag_time__size = f_counter_32_wflag_time_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_f_counter_32_wflag_time__size;
			}
			break;
		case 5382:
			// Parse "f_counter_16_wflag_time"
			{
			f_counter_16_wflag_time_ = new FrozenCounter16wFlagTime();
			int t_f_counter_16_wflag_time__size;
			t_f_counter_16_wflag_time__size = f_counter_16_wflag_time_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_f_counter_16_wflag_time__size;
			}
			break;
		case 5383:
			// Parse "f_counter_32_wflag_time_delta"
			{
			f_counter_32_wflag_time_delta_ = new Debug_Byte();
			int t_f_counter_32_wflag_time_delta__size;
			t_f_counter_32_wflag_time_delta__size = f_counter_32_wflag_time_delta_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_f_counter_32_wflag_time_delta__size;
			}
			break;
		case 5384:
			// Parse "f_counter_16_wflag_time_delta"
			{
			f_counter_16_wflag_time_delta_ = new Debug_Byte();
			int t_f_counter_16_wflag_time_delta__size;
			t_f_counter_16_wflag_time_delta__size = f_counter_16_wflag_time_delta_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_f_counter_16_wflag_time_delta__size;
			}
			break;
		case 5385:
			// Parse "f_counter_32_woflag"
			{
			f_counter_32_woflag_ = new FrozenCounter32woFlag();
			f_counter_32_woflag_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 4;
			}
			break;
		case 5386:
			// Parse "f_counter_16_woflag"
			{
			f_counter_16_woflag_ = new FrozenCounter16woFlag();
			f_counter_16_woflag_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 2;
			}
			break;
		case 5387:
			// Parse "f_counter_32_woflag_delta"
			{
			f_counter_32_woflag_delta_ = new Debug_Byte();
			int t_f_counter_32_woflag_delta__size;
			t_f_counter_32_woflag_delta__size = f_counter_32_woflag_delta_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_f_counter_32_woflag_delta__size;
			}
			break;
		case 5388:
			// Parse "f_counter_16_woflag_delta"
			{
			f_counter_16_woflag_delta_ = new Debug_Byte();
			int t_f_counter_16_woflag_delta__size;
			t_f_counter_16_woflag_delta__size = f_counter_16_woflag_delta_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_f_counter_16_woflag_delta__size;
			}
			break;
		case 5633:
			// Parse "counter_event_32_wflag"
			{
			counter_event_32_wflag_ = new CounterEve32wFlag();
			counter_event_32_wflag_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 5;
			}
			break;
		case 5634:
			// Parse "counter_event_16_wflag"
			{
			counter_event_16_wflag_ = new CounterEve16wFlag();
			counter_event_16_wflag_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 3;
			}
			break;
		case 5635:
			// Parse "counter_event_32_wflag_delta"
			{
			counter_event_32_wflag_delta_ = new Debug_Byte();
			int t_counter_event_32_wflag_delta__size;
			t_counter_event_32_wflag_delta__size = counter_event_32_wflag_delta_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_counter_event_32_wflag_delta__size;
			}
			break;
		case 5636:
			// Parse "counter_event_16_wflag_delta"
			{
			counter_event_16_wflag_delta_ = new Debug_Byte();
			int t_counter_event_16_wflag_delta__size;
			t_counter_event_16_wflag_delta__size = counter_event_16_wflag_delta_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_counter_event_16_wflag_delta__size;
			}
			break;
		case 5637:
			// Parse "counter_event_32_wflag_time"
			{
			counter_event_32_wflag_time_ = new CounterEve32wFlagTime();
			int t_counter_event_32_wflag_time__size;
			t_counter_event_32_wflag_time__size = counter_event_32_wflag_time_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_counter_event_32_wflag_time__size;
			}
			break;
		case 5638:
			// Parse "counter_event_16_wflag_time"
			{
			counter_event_16_wflag_time_ = new CounterEve16wFlagTime();
			int t_counter_event_16_wflag_time__size;
			t_counter_event_16_wflag_time__size = counter_event_16_wflag_time_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_counter_event_16_wflag_time__size;
			}
			break;
		case 5639:
			// Parse "counter_event_32_wflag_time_delta"
			{
			counter_event_32_wflag_time_delta_ = new Debug_Byte();
			int t_counter_event_32_wflag_time_delta__size;
			t_counter_event_32_wflag_time_delta__size = counter_event_32_wflag_time_delta_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_counter_event_32_wflag_time_delta__size;
			}
			break;
		case 5640:
			// Parse "counter_event_16_wflag_time_delat"
			{
			counter_event_16_wflag_time_delat_ = new Debug_Byte();
			int t_counter_event_16_wflag_time_delat__size;
			t_counter_event_16_wflag_time_delat__size = counter_event_16_wflag_time_delat_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_counter_event_16_wflag_time_delat__size;
			}
			break;
		case 5889:
			// Parse "f_counter_event_32_wflag"
			{
			f_counter_event_32_wflag_ = new CounterEve32wFlag();
			f_counter_event_32_wflag_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 5;
			}
			break;
		case 5890:
			// Parse "f_counter_event_16_wflag"
			{
			f_counter_event_16_wflag_ = new CounterEve16wFlag();
			f_counter_event_16_wflag_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 3;
			}
			break;
		case 5891:
			// Parse "f_counter_event_32_wflag_delta"
			{
			f_counter_event_32_wflag_delta_ = new Debug_Byte();
			int t_f_counter_event_32_wflag_delta__size;
			t_f_counter_event_32_wflag_delta__size = f_counter_event_32_wflag_delta_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_f_counter_event_32_wflag_delta__size;
			}
			break;
		case 5892:
			// Parse "f_counter_event_16_wflag_delta"
			{
			f_counter_event_16_wflag_delta_ = new Debug_Byte();
			int t_f_counter_event_16_wflag_delta__size;
			t_f_counter_event_16_wflag_delta__size = f_counter_event_16_wflag_delta_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_f_counter_event_16_wflag_delta__size;
			}
			break;
		case 5893:
			// Parse "f_counter_event_32_wflag_time"
			{
			f_counter_event_32_wflag_time_ = new CounterEve32wFlagTime();
			int t_f_counter_event_32_wflag_time__size;
			t_f_counter_event_32_wflag_time__size = f_counter_event_32_wflag_time_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_f_counter_event_32_wflag_time__size;
			}
			break;
		case 5894:
			// Parse "f_counter_event_16_wflag_time"
			{
			f_counter_event_16_wflag_time_ = new CounterEve16wFlagTime();
			int t_f_counter_event_16_wflag_time__size;
			t_f_counter_event_16_wflag_time__size = f_counter_event_16_wflag_time_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_f_counter_event_16_wflag_time__size;
			}
			break;
		case 5895:
			// Parse "f_counter_event_32_wflag_time_delta"
			{
			f_counter_event_32_wflag_time_delta_ = new Debug_Byte();
			int t_f_counter_event_32_wflag_time_delta__size;
			t_f_counter_event_32_wflag_time_delta__size = f_counter_event_32_wflag_time_delta_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_f_counter_event_32_wflag_time_delta__size;
			}
			break;
		case 5896:
			// Parse "f_counter_event_16_wflag_time_delat"
			{
			f_counter_event_16_wflag_time_delat_ = new Debug_Byte();
			int t_f_counter_event_16_wflag_time_delat__size;
			t_f_counter_event_16_wflag_time_delat__size = f_counter_event_16_wflag_time_delat_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_f_counter_event_16_wflag_time_delat__size;
			}
			break;
		case 7681:
			// Parse "ai_32_wflag"
			{
			ai_32_wflag_ = new AnalogInput32wFlag();
			ai_32_wflag_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 5;
			}
			break;
		case 7682:
			// Parse "ai_16_wflag"
			{
			ai_16_wflag_ = new AnalogInput16wFlag();
			ai_16_wflag_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 3;
			}
			break;
		case 7683:
			// Parse "ai_32_woflag"
			{
			ai_32_woflag_ = new AnalogInput32woFlag();
			ai_32_woflag_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 4;
			}
			break;
		case 7684:
			// Parse "ai_16_woflag"
			{
			ai_16_woflag_ = new AnalogInput16woFlag();
			ai_16_woflag_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 2;
			}
			break;
		case 7685:
			// Parse "ai_sp_wflag"
			{
			ai_sp_wflag_ = new AnalogInputSPwFlag();
			ai_sp_wflag_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 5;
			}
			break;
		case 7686:
			// Parse "ai_dp_wflag"
			{
			ai_dp_wflag_ = new AnalogInputDPwFlag();
			ai_dp_wflag_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 9;
			}
			break;
		case 7937:
			// Parse "f_ai_32_wflag"
			{
			f_ai_32_wflag_ = new FrozenAnalogInput32wFlag();
			f_ai_32_wflag_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 5;
			}
			break;
		case 7938:
			// Parse "f_ai_16_wflag"
			{
			f_ai_16_wflag_ = new FrozenAnalogInput16wFlag();
			f_ai_16_wflag_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 3;
			}
			break;
		case 7939:
			// Parse "f_ai_32_wtime"
			{
			f_ai_32_wtime_ = new FrozenAnalogInput32wTime();
			int t_f_ai_32_wtime__size;
			t_f_ai_32_wtime__size = f_ai_32_wtime_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_f_ai_32_wtime__size;
			}
			break;
		case 7940:
			// Parse "f_ai_16_wtime"
			{
			f_ai_16_wtime_ = new FrozenAnalogInput16wTime();
			int t_f_ai_16_wtime__size;
			t_f_ai_16_wtime__size = f_ai_16_wtime_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_f_ai_16_wtime__size;
			}
			break;
		case 7941:
			// Parse "f_ai_32_woflag"
			{
			f_ai_32_woflag_ = new AnalogInput32woFlag();
			f_ai_32_woflag_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 4;
			}
			break;
		case 7942:
			// Parse "f_ai_16_woflag"
			{
			f_ai_16_woflag_ = new AnalogInput16woFlag();
			f_ai_16_woflag_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 2;
			}
			break;
		case 7943:
			// Parse "f_ai_sp_wflag"
			{
			f_ai_sp_wflag_ = new AnalogInputSPwFlag();
			f_ai_sp_wflag_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 5;
			}
			break;
		case 7944:
			// Parse "f_ai_dp_wflag"
			{
			f_ai_dp_wflag_ = new AnalogInputDPwFlag();
			f_ai_dp_wflag_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 9;
			}
			break;
		case 8193:
			// Parse "ai32wotime"
			{
			ai32wotime_ = new AnalogInput32woTime();
			ai32wotime_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 5;
			}
			break;
		case 8194:
			// Parse "ai16wotime"
			{
			ai16wotime_ = new AnalogInput16woTime();
			ai16wotime_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 3;
			}
			break;
		case 8195:
			// Parse "ai32wtime"
			{
			ai32wtime_ = new AnalogInput32wTime();
			int t_ai32wtime__size;
			t_ai32wtime__size = ai32wtime_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_ai32wtime__size;
			}
			break;
		case 8196:
			// Parse "ai16wtime"
			{
			ai16wtime_ = new AnalogInput16wTime();
			int t_ai16wtime__size;
			t_ai16wtime__size = ai16wtime_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_ai16wtime__size;
			}
			break;
		case 8197:
			// Parse "aispwotime"
			{
			aispwotime_ = new AnalogInputSPwoTime();
			aispwotime_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 5;
			}
			break;
		case 8198:
			// Parse "aidpwotime"
			{
			aidpwotime_ = new AnalogInputDPwoTime();
			aidpwotime_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 9;
			}
			break;
		case 8199:
			// Parse "aispwtime"
			{
			aispwtime_ = new AnalogInputSPwTime();
			int t_aispwtime__size;
			t_aispwtime__size = aispwtime_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_aispwtime__size;
			}
			break;
		case 8200:
			// Parse "aidpwtime"
			{
			aidpwtime_ = new AnalogInputDPwTime();
			int t_aidpwtime__size;
			t_aidpwtime__size = aidpwtime_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_aidpwtime__size;
			}
			break;
		case 8449:
			// Parse "faie_32_wotime"
			{
			faie_32_wotime_ = new FrozenAnaInputEve32woTime();
			faie_32_wotime_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 5;
			}
			break;
		case 8450:
			// Parse "faie_16_wotime"
			{
			faie_16_wotime_ = new FrozenAnaInputEve16woTime();
			faie_16_wotime_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 3;
			}
			break;
		case 8451:
			// Parse "faie_32_wtime"
			{
			faie_32_wtime_ = new FrozenAnaInputEve32wTime();
			int t_faie_32_wtime__size;
			t_faie_32_wtime__size = faie_32_wtime_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_faie_32_wtime__size;
			}
			break;
		case 8452:
			// Parse "faie_16_wtime"
			{
			faie_16_wtime_ = new FrozenAnaInputEve16wTime();
			int t_faie_16_wtime__size;
			t_faie_16_wtime__size = faie_16_wtime_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_faie_16_wtime__size;
			}
			break;
		case 8453:
			// Parse "faie_sp_wotime"
			{
			faie_sp_wotime_ = new FrozenAnaInputEveSPwoTime();
			faie_sp_wotime_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 5;
			}
			break;
		case 8454:
			// Parse "faie_dp_wotime"
			{
			faie_dp_wotime_ = new FrozenAnaInputEveDPwoTime();
			faie_dp_wotime_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 9;
			}
			break;
		case 8455:
			// Parse "faie_sp_wtime"
			{
			faie_sp_wtime_ = new FrozenAnaInputEveSPwTime();
			int t_faie_sp_wtime__size;
			t_faie_sp_wtime__size = faie_sp_wtime_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_faie_sp_wtime__size;
			}
			break;
		case 8456:
			// Parse "faie_dp_wtime"
			{
			faie_dp_wtime_ = new FrozenAnaInputEveDPwTime();
			int t_faie_dp_wtime__size;
			t_faie_dp_wtime__size = faie_dp_wtime_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_faie_dp_wtime__size;
			}
			break;
		case 8705:
			// Parse "ai_dead_16"
			{
			// Checking out-of-bound for "Response_Data_Object:ai_dead_16"
			if ( t_dataptr_after_prefix + (2) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Response_Data_Object:ai_dead_16",
					((t_dataptr_after_prefix - t_begin_of_data)) + (2), 
					(t_end_of_data) - (t_begin_of_data));
				}
			ai_dead_16_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_dataptr_after_prefix)));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 2;
			}
			break;
		case 8706:
			// Parse "ai_dead_32"
			{
			// Checking out-of-bound for "Response_Data_Object:ai_dead_32"
			if ( t_dataptr_after_prefix + (4) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Response_Data_Object:ai_dead_32",
					((t_dataptr_after_prefix - t_begin_of_data)) + (4), 
					(t_end_of_data) - (t_begin_of_data));
				}
			ai_dead_32_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_dataptr_after_prefix)));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 4;
			}
			break;
		case 8707:
			// Parse "ai_dead_sp"
			{
			// Checking out-of-bound for "Response_Data_Object:ai_dead_sp"
			if ( t_dataptr_after_prefix + (4) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Response_Data_Object:ai_dead_sp",
					((t_dataptr_after_prefix - t_begin_of_data)) + (4), 
					(t_end_of_data) - (t_begin_of_data));
				}
			ai_dead_sp_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_dataptr_after_prefix)));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 4;
			}
			break;
		case 10241:
			// Parse "aos_32"
			{
			aos_32_ = new AnaOutStatus32();
			aos_32_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 5;
			}
			break;
		case 10242:
			// Parse "aos_16"
			{
			aos_16_ = new AnaOutStatus16();
			aos_16_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 3;
			}
			break;
		case 10243:
			// Parse "aos_sp"
			{
			aos_sp_ = new AnaOutStatusSP();
			aos_sp_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 5;
			}
			break;
		case 10244:
			// Parse "aos_dp"
			{
			aos_dp_ = new AnaOutStatusDP();
			aos_dp_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 9;
			}
			break;
		case 10497:
			// Parse "ao_32"
			{
			ao_32_ = new AnaOut32();
			ao_32_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 5;
			}
			break;
		case 10498:
			// Parse "ao_16"
			{
			ao_16_ = new AnaOut16();
			ao_16_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 3;
			}
			break;
		case 10499:
			// Parse "ao_sp"
			{
			ao_sp_ = new AnaOutSP();
			ao_sp_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 5;
			}
			break;
		case 10500:
			// Parse "ao_dp"
			{
			ao_dp_ = new AnaOutDP();
			ao_dp_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 9;
			}
			break;
		case 10753:
			// Parse "aoe32wotime"
			{
			aoe32wotime_ = new AnaOutEve32woTime();
			aoe32wotime_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 5;
			}
			break;
		case 10754:
			// Parse "aoe16wotime"
			{
			aoe16wotime_ = new AnaOutEve16woTime();
			aoe16wotime_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 3;
			}
			break;
		case 10755:
			// Parse "aoe32wtime"
			{
			aoe32wtime_ = new AnaOutEve32wTime();
			int t_aoe32wtime__size;
			t_aoe32wtime__size = aoe32wtime_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_aoe32wtime__size;
			}
			break;
		case 10756:
			// Parse "aoe16wtime"
			{
			aoe16wtime_ = new AnaOutEve16wTime();
			int t_aoe16wtime__size;
			t_aoe16wtime__size = aoe16wtime_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_aoe16wtime__size;
			}
			break;
		case 10757:
			// Parse "aoespwotime"
			{
			aoespwotime_ = new AnaOutEveSPwoTime();
			aoespwotime_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 5;
			}
			break;
		case 10758:
			// Parse "aoedpwotime"
			{
			aoedpwotime_ = new AnaOutEveDPwoTime();
			aoedpwotime_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 9;
			}
			break;
		case 10759:
			// Parse "aoespwtime"
			{
			aoespwtime_ = new AnaOutEveSPwTime();
			int t_aoespwtime__size;
			t_aoespwtime__size = aoespwtime_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_aoespwtime__size;
			}
			break;
		case 10760:
			// Parse "aoedpwtime"
			{
			aoedpwtime_ = new AnaOutEveDPwTime();
			int t_aoedpwtime__size;
			t_aoedpwtime__size = aoedpwtime_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_aoedpwtime__size;
			}
			break;
		case 11009:
			// Parse "aoce32wotime"
			{
			aoce32wotime_ = new AnaOutEve32woTime();
			aoce32wotime_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 5;
			}
			break;
		case 11010:
			// Parse "aoce16wotime"
			{
			aoce16wotime_ = new AnaOutEve16woTime();
			aoce16wotime_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 3;
			}
			break;
		case 11011:
			// Parse "aoce32wtime"
			{
			aoce32wtime_ = new AnaOutEve32wTime();
			int t_aoce32wtime__size;
			t_aoce32wtime__size = aoce32wtime_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_aoce32wtime__size;
			}
			break;
		case 11012:
			// Parse "aoce16wtime"
			{
			aoce16wtime_ = new AnaOutEve16wTime();
			int t_aoce16wtime__size;
			t_aoce16wtime__size = aoce16wtime_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_aoce16wtime__size;
			}
			break;
		case 11013:
			// Parse "aocespwotime"
			{
			aocespwotime_ = new AnaOutEveSPwoTime();
			aocespwotime_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 5;
			}
			break;
		case 11014:
			// Parse "aocedpwotime"
			{
			aocedpwotime_ = new AnaOutEveDPwoTime();
			aocedpwotime_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 9;
			}
			break;
		case 11015:
			// Parse "aocespwtime"
			{
			aocespwtime_ = new AnaOutEveSPwTime();
			int t_aocespwtime__size;
			t_aocespwtime__size = aocespwtime_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_aocespwtime__size;
			}
			break;
		case 11016:
			// Parse "aocedpwtime"
			{
			aocedpwtime_ = new AnaOutEveDPwTime();
			int t_aocedpwtime__size;
			t_aocedpwtime__size = aocedpwtime_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_aocedpwtime__size;
			}
			break;
		case 12801:
			// Parse "time_abs"
			{
			time_abs_ = new AbsTime();
			int t_time_abs__size;
			t_time_abs__size = time_abs_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_time_abs__size;
			}
			break;
		case 12802:
			// Parse "time_interval"
			{
			time_interval_ = new AbsTimeInterval();
			int t_time_interval__size;
			t_time_interval__size = time_interval_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_time_interval__size;
			}
			break;
		case 12803:
			// Parse "time_abs_last"
			{
			time_abs_last_ = new Last_AbsTime();
			int t_time_abs_last__size;
			t_time_abs_last__size = time_abs_last_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_time_abs_last__size;
			}
			break;
		case 13057:
			// Parse "time_abs_sync"
			{
			time_abs_sync_ = new AbsTime();
			int t_time_abs_sync__size;
			t_time_abs_sync__size = time_abs_sync_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_time_abs_sync__size;
			}
			break;
		case 13058:
			// Parse "time_abs_unsync"
			{
			time_abs_unsync_ = new AbsTime();
			int t_time_abs_unsync__size;
			t_time_abs_unsync__size = time_abs_unsync_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_time_abs_unsync__size;
			}
			break;
		case 13313:
			// Parse "time_coarse"
			{
			// Checking out-of-bound for "Response_Data_Object:time_coarse"
			if ( t_dataptr_after_prefix + (2) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Response_Data_Object:time_coarse",
					((t_dataptr_after_prefix - t_begin_of_data)) + (2), 
					(t_end_of_data) - (t_begin_of_data));
				}
			time_coarse_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_dataptr_after_prefix)));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 2;
			}
			break;
		case 13314:
			// Parse "time_fine"
			{
			// Checking out-of-bound for "Response_Data_Object:time_fine"
			if ( t_dataptr_after_prefix + (2) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Response_Data_Object:time_fine",
					((t_dataptr_after_prefix - t_begin_of_data)) + (2), 
					(t_end_of_data) - (t_begin_of_data));
				}
			time_fine_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_dataptr_after_prefix)));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 2;
			}
			break;
		case 17921:
			// Parse "file_control_id"
			{
			file_control_id_ = new File_Control_ID();
			int t_file_control_id__size;
			t_file_control_id__size = file_control_id_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_file_control_id__size;
			}
			break;
		case 17922:
			// Parse "file_control_auth"
			{
			file_control_auth_ = new File_Control_Auth();
			int t_file_control_auth__size;
			t_file_control_auth__size = file_control_auth_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_file_control_auth__size;
			}
			break;
		case 17923:
			// Parse "file_control_cmd"
			{
			file_control_cmd_ = new File_Control_Cmd();
			int t_file_control_cmd__size;
			t_file_control_cmd__size = file_control_cmd_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_file_control_cmd__size;
			}
			break;
		case 17924:
			// Parse "file_control_cmd_status"
			{
			file_control_cmd_status_ = new File_Control_Cmd_Status(prefix()->prefix_value());
			int t_file_control_cmd_status__size;
			t_file_control_cmd_status__size = file_control_cmd_status_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_file_control_cmd_status__size;
			}
			break;
		case 17925:
			// Parse "file_trans"
			{
			file_trans_ = new File_Transport(prefix()->prefix_value());
			int t_file_trans__size;
			t_file_trans__size = file_trans_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_file_trans__size;
			}
			break;
		case 17926:
			// Parse "file_trans_status"
			{
			file_trans_status_ = new File_Transport_Status(prefix()->prefix_value());
			int t_file_trans_status__size;
			t_file_trans_status__size = file_trans_status_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_file_trans_status__size;
			}
			break;
		case 17927:
			// Parse "file_desc"
			{
			file_desc_ = new File_Desc();
			int t_file_desc__size;
			t_file_desc__size = file_desc_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_file_desc__size;
			}
			break;
		case 20481:
			// Parse "iin"
			{
			// Checking out-of-bound for "Response_Data_Object:iin"
			if ( t_dataptr_after_prefix + (2) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Response_Data_Object:iin",
					((t_dataptr_after_prefix - t_begin_of_data)) + (2), 
					(t_end_of_data) - (t_begin_of_data));
				}
			iin_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_dataptr_after_prefix)));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 2;
			}
			break;
		case 20737:
			// Parse "dev_store"
			{
			dev_store_ = new Dev_Store();
			dev_store_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 3;
			}
			break;
		case 20993:
			// Parse "dev_profile"
			{
			dev_profile_ = new Dev_Profile();
			int t_dev_profile__size;
			t_dev_profile__size = dev_profile_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_dev_profile__size;
			}
			break;
		case 21249:
			// Parse "priregobj"
			{
			priregobj_ = new PrivRegObj();
			int t_priregobj__size;
			t_priregobj__size = priregobj_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_priregobj__size;
			}
			break;
		case 21250:
			// Parse "priregobjdesc"
			{
			priregobjdesc_ = new PrivRegObjDesc();
			int t_priregobjdesc__size;
			t_priregobjdesc__size = priregobjdesc_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_priregobjdesc__size;
			}
			break;
		case 21761:
			// Parse "desc_ele"
			{
			desc_ele_ = new DescEle();
			desc_ele_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 5;
			}
			break;
		case 22017:
			// Parse "desc_ele86"
			{
			desc_ele86_ = new DescEle();
			desc_ele86_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 5;
			}
			break;
		case 22018:
			// Parse "cha"
			{
			// Checking out-of-bound for "Response_Data_Object:cha"
			if ( t_dataptr_after_prefix + (1) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Response_Data_Object:cha",
					((t_dataptr_after_prefix - t_begin_of_data)) + (1), 
					(t_end_of_data) - (t_begin_of_data));
				}
			cha_ = *((uint8 const *) (t_dataptr_after_prefix));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 1;
			}
			break;
		case 22019:
			// Parse "point_index_attr"
			{
			point_index_attr_ = new Debug_Byte();
			int t_point_index_attr__size;
			t_point_index_attr__size = point_index_attr_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_point_index_attr__size;
			}
			break;
		case 22273:
			// Parse "present_value"
			{
			present_value_ = new Debug_Byte();
			int t_present_value__size;
			t_present_value__size = present_value_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_present_value__size;
			}
			break;
		case 22529:
			// Parse "snapshot"
			{
			snapshot_ = new Debug_Byte();
			int t_snapshot__size;
			t_snapshot__size = snapshot_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_snapshot__size;
			}
			break;
		case 23297:
			// Parse "activate_conf"
			{
			activate_conf_ = new ActivateConf();
			int t_activate_conf__size;
			t_activate_conf__size = activate_conf_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_activate_conf__size;
			}
			break;
		case 25857:
			// Parse "bcd_small"
			{
			// Checking out-of-bound for "Response_Data_Object:bcd_small"
			if ( t_dataptr_after_prefix + (2) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Response_Data_Object:bcd_small",
					((t_dataptr_after_prefix - t_begin_of_data)) + (2), 
					(t_end_of_data) - (t_begin_of_data));
				}
			bcd_small_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_dataptr_after_prefix)));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 2;
			}
			break;
		case 25858:
			// Parse "bcd_medium"
			{
			// Checking out-of-bound for "Response_Data_Object:bcd_medium"
			if ( t_dataptr_after_prefix + (4) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Response_Data_Object:bcd_medium",
					((t_dataptr_after_prefix - t_begin_of_data)) + (4), 
					(t_end_of_data) - (t_begin_of_data));
				}
			bcd_medium_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_dataptr_after_prefix)));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 4;
			}
			break;
		case 25859:
			// Parse "bcd_large"
			{
			bcd_large_ = new BCD_Large();
			bcd_large_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 8;
			}
			break;
		case 26113:
			// Parse "unsigned_integer"
			{
			// Checking out-of-bound for "Response_Data_Object:unsigned_integer"
			if ( t_dataptr_after_prefix + (1) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Response_Data_Object:unsigned_integer",
					((t_dataptr_after_prefix - t_begin_of_data)) + (1), 
					(t_end_of_data) - (t_begin_of_data));
				}
			unsigned_integer_ = *((uint8 const *) (t_dataptr_after_prefix));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 1;
			}
			break;
		case 30721:
			// Parse "challenge"
			{
			challenge_ = new AuthChallenge(prefix()->prefix_value());
			int t_challenge__size;
			t_challenge__size = challenge_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_challenge__size;
			}
			break;
		case 30722:
			// Parse "reply"
			{
			reply_ = new AuthRely(prefix()->prefix_value());
			int t_reply__size;
			t_reply__size = reply_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_reply__size;
			}
			break;
		case 30723:
			// Parse "aggrRequest"
			{
			aggrRequest_ = new AuthAggrRequest(prefix()->prefix_value());
			int t_aggrRequest__size;
			t_aggrRequest__size = aggrRequest_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_aggrRequest__size;
			}
			break;
		case 30724:
			// Parse "seesionKeyRequest"
			{
			// Checking out-of-bound for "Response_Data_Object:seesionKeyRequest"
			if ( t_dataptr_after_prefix + (1) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Response_Data_Object:seesionKeyRequest",
					((t_dataptr_after_prefix - t_begin_of_data)) + (1), 
					(t_end_of_data) - (t_begin_of_data));
				}
			seesionKeyRequest_ = *((uint8 const *) (t_dataptr_after_prefix));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 1;
			}
			break;
		case 30725:
			// Parse "status"
			{
			status_ = new AuthSessionKeyStatus(prefix()->prefix_value());
			int t_status__size;
			t_status__size = status_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_status__size;
			}
			break;
		case 30726:
			// Parse "keyChange"
			{
			keyChange_ = new AuthSessionKeyChange(prefix()->prefix_value());
			int t_keyChange__size;
			t_keyChange__size = keyChange_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_keyChange__size;
			}
			break;
		case 30727:
			// Parse "error"
			{
			error_ = new AuthError(prefix()->prefix_value());
			int t_error__size;
			t_error__size = error_->Parse(t_dataptr_after_prefix, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_error__size;
			}
			break;
		default:
			// Parse "unmatched"
			{
			unmatched_ = new Default_Wrap(object_type_field());
			int t_unmatched__size;
			t_unmatched__size = unmatched_->Parse(t_dataptr_after_prefix, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_unmatched__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_Response_Data_Object__size;
	const_byteptr const t_dataptr_after_data = t_dataptr_after_prefix + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_Response_Data_Object__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	uint8 t_t_var_005;
	switch (  ( object_type_field() )  )
		{
		case 257:
			t_t_var_005 = biwoflag();
			break;
		case 258:
			t_t_var_005 = biwflag();
			break;
		case 2561:
			t_t_var_005 = bowoflag();
			break;
		case 2562:
			t_t_var_005 = bowflag();
			break;
		default:
			t_t_var_005 = 0xff;
			break;
		}
	data_value_ = t_t_var_005;
	process_request_ = t_context->flow()->get_dnp3_response_data_object(data_value());
	BINPAC_ASSERT(t_begin_of_data + (t_Response_Data_Object__size) <= t_end_of_data);
	return t_Response_Data_Object__size;
	}

Default_Wrap::Default_Wrap(uint32 obj_type)
	{
	unresolved_case_index_ = -1;
	unknown_ = 0;
	obj_type_ = obj_type;
	}

Default_Wrap::~Default_Wrap()
	{
	switch ( unresolved_case_index() )
		{
		case 28160:
			// Clean up "oct_str"
			{
			oct_str_.free();
			}
			break;
		case 28416:
			// Clean up "oct_str_eve"
			{
			oct_str_eve_.free();
			}
			break;
		case 28672:
			// Clean up "vir_ter_out_blk"
			{
			vir_ter_out_blk_.free();
			}
			break;
		case 28928:
			// Clean up "vir_ter_eve"
			{
			vir_ter_eve_.free();
			}
			break;
		default:
			// Clean up "unknown"
			{
			delete unknown_;
			unknown_ = 0;
			}
			break;
		}
	}

int Default_Wrap::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Parse "unresolved"
	int t_unresolved__size;
	unresolved_case_index_ =  ( obj_type() & 0xFF00 ) ;
	switch ( unresolved_case_index() )
		{
		case 28160:
			// Parse "oct_str"
			{
			int t_oct_str__size;
			t_oct_str__size =  ( obj_type() & 0x00FF ) ;
			// Checking out-of-bound for "Default_Wrap:oct_str"
			if ( t_begin_of_data + (t_oct_str__size) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Default_Wrap:oct_str",
					(0) + (t_oct_str__size), 
					(t_end_of_data) - (t_begin_of_data));
				}
			{
			// Setting t_end_of_data with &length
			const_byteptr t_end_of_data = t_begin_of_data + t_oct_str__size;
			int t_oct_str_string_length;
			t_oct_str_string_length =  ( obj_type() & 0x00FF ) ;
			// check for negative sizes
			if ( t_oct_str_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-objects.pac:646", t_oct_str_string_length);
			oct_str_.init(t_begin_of_data, t_oct_str_string_length);
			// Evaluate 'let' and 'withinput' fields
			}
			t_unresolved__size = t_oct_str__size;
			}
			break;
		case 28416:
			// Parse "oct_str_eve"
			{
			int t_oct_str_eve__size;
			t_oct_str_eve__size =  ( obj_type() & 0x00FF ) ;
			// Checking out-of-bound for "Default_Wrap:oct_str_eve"
			if ( t_begin_of_data + (t_oct_str_eve__size) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Default_Wrap:oct_str_eve",
					(0) + (t_oct_str_eve__size), 
					(t_end_of_data) - (t_begin_of_data));
				}
			{
			// Setting t_end_of_data with &length
			const_byteptr t_end_of_data = t_begin_of_data + t_oct_str_eve__size;
			int t_oct_str_eve_string_length;
			t_oct_str_eve_string_length =  ( obj_type() & 0x00FF ) ;
			// check for negative sizes
			if ( t_oct_str_eve_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-objects.pac:647", t_oct_str_eve_string_length);
			oct_str_eve_.init(t_begin_of_data, t_oct_str_eve_string_length);
			// Evaluate 'let' and 'withinput' fields
			}
			t_unresolved__size = t_oct_str_eve__size;
			}
			break;
		case 28672:
			// Parse "vir_ter_out_blk"
			{
			int t_vir_ter_out_blk__size;
			t_vir_ter_out_blk__size =  ( obj_type() & 0x00FF ) ;
			// Checking out-of-bound for "Default_Wrap:vir_ter_out_blk"
			if ( t_begin_of_data + (t_vir_ter_out_blk__size) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Default_Wrap:vir_ter_out_blk",
					(0) + (t_vir_ter_out_blk__size), 
					(t_end_of_data) - (t_begin_of_data));
				}
			{
			// Setting t_end_of_data with &length
			const_byteptr t_end_of_data = t_begin_of_data + t_vir_ter_out_blk__size;
			int t_vir_ter_out_blk_string_length;
			t_vir_ter_out_blk_string_length =  ( obj_type() & 0x00FF ) ;
			// check for negative sizes
			if ( t_vir_ter_out_blk_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-objects.pac:648", t_vir_ter_out_blk_string_length);
			vir_ter_out_blk_.init(t_begin_of_data, t_vir_ter_out_blk_string_length);
			// Evaluate 'let' and 'withinput' fields
			}
			t_unresolved__size = t_vir_ter_out_blk__size;
			}
			break;
		case 28928:
			// Parse "vir_ter_eve"
			{
			int t_vir_ter_eve__size;
			t_vir_ter_eve__size =  ( obj_type() & 0x00FF ) ;
			// Checking out-of-bound for "Default_Wrap:vir_ter_eve"
			if ( t_begin_of_data + (t_vir_ter_eve__size) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Default_Wrap:vir_ter_eve",
					(0) + (t_vir_ter_eve__size), 
					(t_end_of_data) - (t_begin_of_data));
				}
			{
			// Setting t_end_of_data with &length
			const_byteptr t_end_of_data = t_begin_of_data + t_vir_ter_eve__size;
			int t_vir_ter_eve_string_length;
			t_vir_ter_eve_string_length =  ( obj_type() & 0x00FF ) ;
			// check for negative sizes
			if ( t_vir_ter_eve_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-objects.pac:649", t_vir_ter_eve_string_length);
			vir_ter_eve_.init(t_begin_of_data, t_vir_ter_eve_string_length);
			// Evaluate 'let' and 'withinput' fields
			}
			t_unresolved__size = t_vir_ter_eve__size;
			}
			break;
		default:
			// Parse "unknown"
			{
			unknown_ = new Debug_Byte();
			int t_unknown__size;
			t_unknown__size = unknown_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_unresolved__size = t_unknown__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_Default_Wrap__size;
	const_byteptr const t_dataptr_after_unresolved = t_begin_of_data + (t_unresolved__size);
	BINPAC_ASSERT(t_dataptr_after_unresolved <= t_end_of_data);
	t_Default_Wrap__size = t_dataptr_after_unresolved - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Default_Wrap__size) <= t_end_of_data);
	return t_Default_Wrap__size;
	}

AttributeCommon::AttributeCommon()
	{
	data_type_code_ = 0;
	leng_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

AttributeCommon::~AttributeCommon()
	{
	attribute_obj_.free();
	}

int AttributeCommon::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "AttributeCommon:leng"
	if ( (t_begin_of_data + 1) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AttributeCommon:leng",
			(1) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "data_type_code"
	data_type_code_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "leng"
	leng_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "attribute_obj"
	int t_attribute_obj__size;
	t_attribute_obj__size = leng();
	// Checking out-of-bound for "AttributeCommon:attribute_obj"
	if ( (t_begin_of_data + 2) + (t_attribute_obj__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AttributeCommon:attribute_obj",
			(2) + (t_attribute_obj__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 2) + t_attribute_obj__size;
	int t_attribute_obj_string_length;
	t_attribute_obj_string_length = leng();
	// check for negative sizes
	if ( t_attribute_obj_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-objects.pac:664", t_attribute_obj_string_length);
	attribute_obj_.init((t_begin_of_data + 2), t_attribute_obj_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_AttributeCommon__size;
	const_byteptr const t_dataptr_after_attribute_obj = (t_begin_of_data + 2) + (t_attribute_obj__size);
	BINPAC_ASSERT(t_dataptr_after_attribute_obj <= t_end_of_data);
	t_AttributeCommon__size = t_dataptr_after_attribute_obj - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_attribute_common(data_type_code(), leng(), attribute_obj());
	BINPAC_ASSERT(t_begin_of_data + (t_AttributeCommon__size) <= t_end_of_data);
	return t_AttributeCommon__size;
	}

BinInEveAtime::BinInEveAtime()
	{
	flag_ = 0;
	byteorder_ = littleendian;
	}

BinInEveAtime::~BinInEveAtime()
	{
	time48_.free();
	}

int BinInEveAtime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "BinInEveAtime:flag"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("BinInEveAtime:flag",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time48"
	// Checking out-of-bound for "BinInEveAtime:time48"
	if ( (t_begin_of_data + 1) + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("BinInEveAtime:time48",
			(1) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 1) + 6;
	int t_time48_string_length;
	t_time48_string_length = 6;
	int t_time48__size;
	t_time48__size = t_time48_string_length;
	time48_.init((t_begin_of_data + 1), t_time48_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_BinInEveAtime__size;
	const_byteptr const t_dataptr_after_time48 = (t_begin_of_data + 1) + (6);
	BINPAC_ASSERT(t_dataptr_after_time48 <= t_end_of_data);
	t_BinInEveAtime__size = t_dataptr_after_time48 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_BinInEveAtime__size) <= t_end_of_data);
	return t_BinInEveAtime__size;
	}

BinInEveRtime::BinInEveRtime()
	{
	flag_ = 0;
	time16_ = 0;
	byteorder_ = littleendian;
	}

BinInEveRtime::~BinInEveRtime()
	{
	}

int BinInEveRtime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "BinInEveRtime"
	if ( t_begin_of_data + (3) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("BinInEveRtime",
			(0) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time16"
	time16_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (3) <= t_end_of_data);
	return 3;
	}

DoubleInEveAtime::DoubleInEveAtime()
	{
	flag_ = 0;
	byteorder_ = littleendian;
	}

DoubleInEveAtime::~DoubleInEveAtime()
	{
	time48_.free();
	}

int DoubleInEveAtime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "DoubleInEveAtime:flag"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DoubleInEveAtime:flag",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time48"
	// Checking out-of-bound for "DoubleInEveAtime:time48"
	if ( (t_begin_of_data + 1) + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DoubleInEveAtime:time48",
			(1) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 1) + 6;
	int t_time48_string_length;
	t_time48_string_length = 6;
	int t_time48__size;
	t_time48__size = t_time48_string_length;
	time48_.init((t_begin_of_data + 1), t_time48_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_DoubleInEveAtime__size;
	const_byteptr const t_dataptr_after_time48 = (t_begin_of_data + 1) + (6);
	BINPAC_ASSERT(t_dataptr_after_time48 <= t_end_of_data);
	t_DoubleInEveAtime__size = t_dataptr_after_time48 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_DoubleInEveAtime__size) <= t_end_of_data);
	return t_DoubleInEveAtime__size;
	}

DoubleInEveRtime::DoubleInEveRtime()
	{
	flag_ = 0;
	time16_ = 0;
	byteorder_ = littleendian;
	}

DoubleInEveRtime::~DoubleInEveRtime()
	{
	}

int DoubleInEveRtime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "DoubleInEveRtime"
	if ( t_begin_of_data + (3) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DoubleInEveRtime",
			(0) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time16"
	time16_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (3) <= t_end_of_data);
	return 3;
	}

BinOutEveAtime::BinOutEveAtime()
	{
	flag_ = 0;
	byteorder_ = littleendian;
	}

BinOutEveAtime::~BinOutEveAtime()
	{
	time48_.free();
	}

int BinOutEveAtime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "BinOutEveAtime:flag"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("BinOutEveAtime:flag",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time48"
	// Checking out-of-bound for "BinOutEveAtime:time48"
	if ( (t_begin_of_data + 1) + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("BinOutEveAtime:time48",
			(1) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 1) + 6;
	int t_time48_string_length;
	t_time48_string_length = 6;
	int t_time48__size;
	t_time48__size = t_time48_string_length;
	time48_.init((t_begin_of_data + 1), t_time48_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_BinOutEveAtime__size;
	const_byteptr const t_dataptr_after_time48 = (t_begin_of_data + 1) + (6);
	BINPAC_ASSERT(t_dataptr_after_time48 <= t_end_of_data);
	t_BinOutEveAtime__size = t_dataptr_after_time48 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_BinOutEveAtime__size) <= t_end_of_data);
	return t_BinOutEveAtime__size;
	}

CROB::CROB()
	{
	control_code_ = 0;
	count_ = 0;
	on_time_ = 0;
	off_time_ = 0;
	status_code_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

CROB::~CROB()
	{
	}

int CROB::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "CROB"
	if ( t_begin_of_data + (11) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("CROB",
			(0) + (11), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "control_code"
	control_code_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "count"
	count_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "on_time"
	on_time_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "off_time"
	off_time_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 6))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "status_code"
	status_code_ = *((uint8 const *) ((t_begin_of_data + 10)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_crob(control_code(), count(), on_time(), off_time(), status_code());
	BINPAC_ASSERT(t_begin_of_data + (11) <= t_end_of_data);
	return 11;
	}

PCB::PCB()
	{
	control_code_ = 0;
	count_ = 0;
	on_time_ = 0;
	off_time_ = 0;
	status_code_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

PCB::~PCB()
	{
	}

int PCB::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "PCB"
	if ( t_begin_of_data + (11) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("PCB",
			(0) + (11), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "control_code"
	control_code_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "count"
	count_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "on_time"
	on_time_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "off_time"
	off_time_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 6))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "status_code"
	status_code_ = *((uint8 const *) ((t_begin_of_data + 10)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_pcb(control_code(), count(), on_time(), off_time(), status_code());
	BINPAC_ASSERT(t_begin_of_data + (11) <= t_end_of_data);
	return 11;
	}

BinOutCmdEveAtime::BinOutCmdEveAtime()
	{
	flag_ = 0;
	byteorder_ = littleendian;
	}

BinOutCmdEveAtime::~BinOutCmdEveAtime()
	{
	time48_.free();
	}

int BinOutCmdEveAtime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "BinOutCmdEveAtime:flag"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("BinOutCmdEveAtime:flag",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time48"
	// Checking out-of-bound for "BinOutCmdEveAtime:time48"
	if ( (t_begin_of_data + 1) + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("BinOutCmdEveAtime:time48",
			(1) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 1) + 6;
	int t_time48_string_length;
	t_time48_string_length = 6;
	int t_time48__size;
	t_time48__size = t_time48_string_length;
	time48_.init((t_begin_of_data + 1), t_time48_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_BinOutCmdEveAtime__size;
	const_byteptr const t_dataptr_after_time48 = (t_begin_of_data + 1) + (6);
	BINPAC_ASSERT(t_dataptr_after_time48 <= t_end_of_data);
	t_BinOutCmdEveAtime__size = t_dataptr_after_time48 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_BinOutCmdEveAtime__size) <= t_end_of_data);
	return t_BinOutCmdEveAtime__size;
	}

Counter32wFlag::Counter32wFlag()
	{
	flag_ = 0;
	count_value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

Counter32wFlag::~Counter32wFlag()
	{
	}

int Counter32wFlag::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "Counter32wFlag"
	if ( t_begin_of_data + (5) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Counter32wFlag",
			(0) + (5), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "count_value"
	count_value_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_counter_32wFlag(flag(), count_value());
	BINPAC_ASSERT(t_begin_of_data + (5) <= t_end_of_data);
	return 5;
	}

Counter16wFlag::Counter16wFlag()
	{
	flag_ = 0;
	count_value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

Counter16wFlag::~Counter16wFlag()
	{
	}

int Counter16wFlag::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "Counter16wFlag"
	if ( t_begin_of_data + (3) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Counter16wFlag",
			(0) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "count_value"
	count_value_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_counter_16wFlag(flag(), count_value());
	BINPAC_ASSERT(t_begin_of_data + (3) <= t_end_of_data);
	return 3;
	}

Counter32woFlag::Counter32woFlag()
	{
	count_value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

Counter32woFlag::~Counter32woFlag()
	{
	}

int Counter32woFlag::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "Counter32woFlag"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Counter32woFlag",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "count_value"
	count_value_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_counter_32woFlag(count_value());
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

Counter16woFlag::Counter16woFlag()
	{
	count_value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

Counter16woFlag::~Counter16woFlag()
	{
	}

int Counter16woFlag::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "Counter16woFlag"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Counter16woFlag",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "count_value"
	count_value_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_counter_16woFlag(count_value());
	BINPAC_ASSERT(t_begin_of_data + (2) <= t_end_of_data);
	return 2;
	}

FrozenCounter32wFlag::FrozenCounter32wFlag()
	{
	flag_ = 0;
	count_value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

FrozenCounter32wFlag::~FrozenCounter32wFlag()
	{
	}

int FrozenCounter32wFlag::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "FrozenCounter32wFlag"
	if ( t_begin_of_data + (5) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenCounter32wFlag",
			(0) + (5), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "count_value"
	count_value_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_frozen_counter_32wFlag(flag(), count_value());
	BINPAC_ASSERT(t_begin_of_data + (5) <= t_end_of_data);
	return 5;
	}

FrozenCounter16wFlag::FrozenCounter16wFlag()
	{
	flag_ = 0;
	count_value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

FrozenCounter16wFlag::~FrozenCounter16wFlag()
	{
	}

int FrozenCounter16wFlag::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "FrozenCounter16wFlag"
	if ( t_begin_of_data + (3) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenCounter16wFlag",
			(0) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "count_value"
	count_value_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_frozen_counter_16wFlag(flag(), count_value());
	BINPAC_ASSERT(t_begin_of_data + (3) <= t_end_of_data);
	return 3;
	}

FrozenCounter32wFlagTime::FrozenCounter32wFlagTime()
	{
	flag_ = 0;
	count_value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

FrozenCounter32wFlagTime::~FrozenCounter32wFlagTime()
	{
	time48_.free();
	}

int FrozenCounter32wFlagTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "FrozenCounter32wFlagTime:count_value"
	if ( (t_begin_of_data + 1) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenCounter32wFlagTime:count_value",
			(1) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "count_value"
	count_value_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time48"
	// Checking out-of-bound for "FrozenCounter32wFlagTime:time48"
	if ( (t_begin_of_data + 5) + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenCounter32wFlagTime:time48",
			(5) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 5) + 6;
	int t_time48_string_length;
	t_time48_string_length = 6;
	int t_time48__size;
	t_time48__size = t_time48_string_length;
	time48_.init((t_begin_of_data + 5), t_time48_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_FrozenCounter32wFlagTime__size;
	const_byteptr const t_dataptr_after_time48 = (t_begin_of_data + 5) + (6);
	BINPAC_ASSERT(t_dataptr_after_time48 <= t_end_of_data);
	t_FrozenCounter32wFlagTime__size = t_dataptr_after_time48 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_frozen_counter_32wFlagTime(flag(), count_value(), time48());
	BINPAC_ASSERT(t_begin_of_data + (t_FrozenCounter32wFlagTime__size) <= t_end_of_data);
	return t_FrozenCounter32wFlagTime__size;
	}

FrozenCounter16wFlagTime::FrozenCounter16wFlagTime()
	{
	flag_ = 0;
	count_value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

FrozenCounter16wFlagTime::~FrozenCounter16wFlagTime()
	{
	time48_.free();
	}

int FrozenCounter16wFlagTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "FrozenCounter16wFlagTime:count_value"
	if ( (t_begin_of_data + 1) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenCounter16wFlagTime:count_value",
			(1) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "count_value"
	count_value_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time48"
	// Checking out-of-bound for "FrozenCounter16wFlagTime:time48"
	if ( (t_begin_of_data + 3) + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenCounter16wFlagTime:time48",
			(3) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 3) + 6;
	int t_time48_string_length;
	t_time48_string_length = 6;
	int t_time48__size;
	t_time48__size = t_time48_string_length;
	time48_.init((t_begin_of_data + 3), t_time48_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_FrozenCounter16wFlagTime__size;
	const_byteptr const t_dataptr_after_time48 = (t_begin_of_data + 3) + (6);
	BINPAC_ASSERT(t_dataptr_after_time48 <= t_end_of_data);
	t_FrozenCounter16wFlagTime__size = t_dataptr_after_time48 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_frozen_counter_16wFlagTime(flag(), count_value(), time48());
	BINPAC_ASSERT(t_begin_of_data + (t_FrozenCounter16wFlagTime__size) <= t_end_of_data);
	return t_FrozenCounter16wFlagTime__size;
	}

FrozenCounter32woFlag::FrozenCounter32woFlag()
	{
	count_value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

FrozenCounter32woFlag::~FrozenCounter32woFlag()
	{
	}

int FrozenCounter32woFlag::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "FrozenCounter32woFlag"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenCounter32woFlag",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "count_value"
	count_value_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_frozen_counter_32woFlag(count_value());
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

FrozenCounter16woFlag::FrozenCounter16woFlag()
	{
	count_value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

FrozenCounter16woFlag::~FrozenCounter16woFlag()
	{
	}

int FrozenCounter16woFlag::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "FrozenCounter16woFlag"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenCounter16woFlag",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "count_value"
	count_value_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_frozen_counter_16woFlag(count_value());
	BINPAC_ASSERT(t_begin_of_data + (2) <= t_end_of_data);
	return 2;
	}

CounterEve32wFlag::CounterEve32wFlag()
	{
	flag_ = 0;
	count_value_ = 0;
	byteorder_ = littleendian;
	}

CounterEve32wFlag::~CounterEve32wFlag()
	{
	}

int CounterEve32wFlag::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "CounterEve32wFlag"
	if ( t_begin_of_data + (5) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("CounterEve32wFlag",
			(0) + (5), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "count_value"
	count_value_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (5) <= t_end_of_data);
	return 5;
	}

CounterEve16wFlag::CounterEve16wFlag()
	{
	flag_ = 0;
	count_value_ = 0;
	byteorder_ = littleendian;
	}

CounterEve16wFlag::~CounterEve16wFlag()
	{
	}

int CounterEve16wFlag::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "CounterEve16wFlag"
	if ( t_begin_of_data + (3) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("CounterEve16wFlag",
			(0) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "count_value"
	count_value_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (3) <= t_end_of_data);
	return 3;
	}

CounterEve32wFlagTime::CounterEve32wFlagTime()
	{
	flag_ = 0;
	count_value_ = 0;
	byteorder_ = littleendian;
	}

CounterEve32wFlagTime::~CounterEve32wFlagTime()
	{
	time48_.free();
	}

int CounterEve32wFlagTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "CounterEve32wFlagTime:count_value"
	if ( (t_begin_of_data + 1) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("CounterEve32wFlagTime:count_value",
			(1) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "count_value"
	count_value_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time48"
	// Checking out-of-bound for "CounterEve32wFlagTime:time48"
	if ( (t_begin_of_data + 5) + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("CounterEve32wFlagTime:time48",
			(5) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 5) + 6;
	int t_time48_string_length;
	t_time48_string_length = 6;
	int t_time48__size;
	t_time48__size = t_time48_string_length;
	time48_.init((t_begin_of_data + 5), t_time48_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_CounterEve32wFlagTime__size;
	const_byteptr const t_dataptr_after_time48 = (t_begin_of_data + 5) + (6);
	BINPAC_ASSERT(t_dataptr_after_time48 <= t_end_of_data);
	t_CounterEve32wFlagTime__size = t_dataptr_after_time48 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_CounterEve32wFlagTime__size) <= t_end_of_data);
	return t_CounterEve32wFlagTime__size;
	}

CounterEve16wFlagTime::CounterEve16wFlagTime()
	{
	flag_ = 0;
	count_value_ = 0;
	byteorder_ = littleendian;
	}

CounterEve16wFlagTime::~CounterEve16wFlagTime()
	{
	time48_.free();
	}

int CounterEve16wFlagTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "CounterEve16wFlagTime:count_value"
	if ( (t_begin_of_data + 1) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("CounterEve16wFlagTime:count_value",
			(1) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "count_value"
	count_value_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time48"
	// Checking out-of-bound for "CounterEve16wFlagTime:time48"
	if ( (t_begin_of_data + 3) + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("CounterEve16wFlagTime:time48",
			(3) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 3) + 6;
	int t_time48_string_length;
	t_time48_string_length = 6;
	int t_time48__size;
	t_time48__size = t_time48_string_length;
	time48_.init((t_begin_of_data + 3), t_time48_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_CounterEve16wFlagTime__size;
	const_byteptr const t_dataptr_after_time48 = (t_begin_of_data + 3) + (6);
	BINPAC_ASSERT(t_dataptr_after_time48 <= t_end_of_data);
	t_CounterEve16wFlagTime__size = t_dataptr_after_time48 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_CounterEve16wFlagTime__size) <= t_end_of_data);
	return t_CounterEve16wFlagTime__size;
	}

FrozenCounterEve32wFlag::FrozenCounterEve32wFlag()
	{
	flag_ = 0;
	count_value_ = 0;
	byteorder_ = littleendian;
	}

FrozenCounterEve32wFlag::~FrozenCounterEve32wFlag()
	{
	}

int FrozenCounterEve32wFlag::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "FrozenCounterEve32wFlag"
	if ( t_begin_of_data + (5) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenCounterEve32wFlag",
			(0) + (5), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "count_value"
	count_value_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (5) <= t_end_of_data);
	return 5;
	}

FrozenCounterEve16wFlag::FrozenCounterEve16wFlag()
	{
	flag_ = 0;
	count_value_ = 0;
	byteorder_ = littleendian;
	}

FrozenCounterEve16wFlag::~FrozenCounterEve16wFlag()
	{
	}

int FrozenCounterEve16wFlag::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "FrozenCounterEve16wFlag"
	if ( t_begin_of_data + (3) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenCounterEve16wFlag",
			(0) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "count_value"
	count_value_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (3) <= t_end_of_data);
	return 3;
	}

FrozenCounterEve32wFlagTime::FrozenCounterEve32wFlagTime()
	{
	flag_ = 0;
	count_value_ = 0;
	byteorder_ = littleendian;
	}

FrozenCounterEve32wFlagTime::~FrozenCounterEve32wFlagTime()
	{
	time48_.free();
	}

int FrozenCounterEve32wFlagTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "FrozenCounterEve32wFlagTime:count_value"
	if ( (t_begin_of_data + 1) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenCounterEve32wFlagTime:count_value",
			(1) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "count_value"
	count_value_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time48"
	// Checking out-of-bound for "FrozenCounterEve32wFlagTime:time48"
	if ( (t_begin_of_data + 5) + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenCounterEve32wFlagTime:time48",
			(5) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 5) + 6;
	int t_time48_string_length;
	t_time48_string_length = 6;
	int t_time48__size;
	t_time48__size = t_time48_string_length;
	time48_.init((t_begin_of_data + 5), t_time48_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_FrozenCounterEve32wFlagTime__size;
	const_byteptr const t_dataptr_after_time48 = (t_begin_of_data + 5) + (6);
	BINPAC_ASSERT(t_dataptr_after_time48 <= t_end_of_data);
	t_FrozenCounterEve32wFlagTime__size = t_dataptr_after_time48 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_FrozenCounterEve32wFlagTime__size) <= t_end_of_data);
	return t_FrozenCounterEve32wFlagTime__size;
	}

FrozenCounterEve16wFlagTime::FrozenCounterEve16wFlagTime()
	{
	flag_ = 0;
	count_value_ = 0;
	byteorder_ = littleendian;
	}

FrozenCounterEve16wFlagTime::~FrozenCounterEve16wFlagTime()
	{
	time48_.free();
	}

int FrozenCounterEve16wFlagTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "FrozenCounterEve16wFlagTime:count_value"
	if ( (t_begin_of_data + 1) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenCounterEve16wFlagTime:count_value",
			(1) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "count_value"
	count_value_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time48"
	// Checking out-of-bound for "FrozenCounterEve16wFlagTime:time48"
	if ( (t_begin_of_data + 3) + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenCounterEve16wFlagTime:time48",
			(3) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 3) + 6;
	int t_time48_string_length;
	t_time48_string_length = 6;
	int t_time48__size;
	t_time48__size = t_time48_string_length;
	time48_.init((t_begin_of_data + 3), t_time48_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_FrozenCounterEve16wFlagTime__size;
	const_byteptr const t_dataptr_after_time48 = (t_begin_of_data + 3) + (6);
	BINPAC_ASSERT(t_dataptr_after_time48 <= t_end_of_data);
	t_FrozenCounterEve16wFlagTime__size = t_dataptr_after_time48 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_FrozenCounterEve16wFlagTime__size) <= t_end_of_data);
	return t_FrozenCounterEve16wFlagTime__size;
	}

AnalogInput32wFlag::AnalogInput32wFlag()
	{
	flag_ = 0;
	value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

AnalogInput32wFlag::~AnalogInput32wFlag()
	{
	}

int AnalogInput32wFlag::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "AnalogInput32wFlag"
	if ( t_begin_of_data + (5) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnalogInput32wFlag",
			(0) + (5), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	value_ = FixByteOrder(byteorder(), *((int32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_analog_input_32wFlag(flag(), value());
	BINPAC_ASSERT(t_begin_of_data + (5) <= t_end_of_data);
	return 5;
	}

AnalogInput16wFlag::AnalogInput16wFlag()
	{
	flag_ = 0;
	value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

AnalogInput16wFlag::~AnalogInput16wFlag()
	{
	}

int AnalogInput16wFlag::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "AnalogInput16wFlag"
	if ( t_begin_of_data + (3) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnalogInput16wFlag",
			(0) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	value_ = FixByteOrder(byteorder(), *((int16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_analog_input_16wFlag(flag(), value());
	BINPAC_ASSERT(t_begin_of_data + (3) <= t_end_of_data);
	return 3;
	}

AnalogInput32woFlag::AnalogInput32woFlag()
	{
	value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

AnalogInput32woFlag::~AnalogInput32woFlag()
	{
	}

int AnalogInput32woFlag::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "AnalogInput32woFlag"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnalogInput32woFlag",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "value"
	value_ = FixByteOrder(byteorder(), *((int32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_analog_input_32woFlag(value());
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

AnalogInput16woFlag::AnalogInput16woFlag()
	{
	value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

AnalogInput16woFlag::~AnalogInput16woFlag()
	{
	}

int AnalogInput16woFlag::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "AnalogInput16woFlag"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnalogInput16woFlag",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "value"
	value_ = FixByteOrder(byteorder(), *((int16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_analog_input_16woFlag(value());
	BINPAC_ASSERT(t_begin_of_data + (2) <= t_end_of_data);
	return 2;
	}

AnalogInputSPwFlag::AnalogInputSPwFlag()
	{
	flag_ = 0;
	value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

AnalogInputSPwFlag::~AnalogInputSPwFlag()
	{
	}

int AnalogInputSPwFlag::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "AnalogInputSPwFlag"
	if ( t_begin_of_data + (5) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnalogInputSPwFlag",
			(0) + (5), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	value_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_analog_input_SPwFlag(flag(), value());
	BINPAC_ASSERT(t_begin_of_data + (5) <= t_end_of_data);
	return 5;
	}

AnalogInputDPwFlag::AnalogInputDPwFlag()
	{
	flag_ = 0;
	value_low_ = 0;
	value_high_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

AnalogInputDPwFlag::~AnalogInputDPwFlag()
	{
	}

int AnalogInputDPwFlag::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "AnalogInputDPwFlag"
	if ( t_begin_of_data + (9) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnalogInputDPwFlag",
			(0) + (9), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value_low"
	value_low_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value_high"
	value_high_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 5))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_analog_input_DPwFlag(flag(), value_low(), value_high());
	BINPAC_ASSERT(t_begin_of_data + (9) <= t_end_of_data);
	return 9;
	}

FrozenAnalogInput32wFlag::FrozenAnalogInput32wFlag()
	{
	flag_ = 0;
	frozen_value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

FrozenAnalogInput32wFlag::~FrozenAnalogInput32wFlag()
	{
	}

int FrozenAnalogInput32wFlag::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "FrozenAnalogInput32wFlag"
	if ( t_begin_of_data + (5) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenAnalogInput32wFlag",
			(0) + (5), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "frozen_value"
	frozen_value_ = FixByteOrder(byteorder(), *((int32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_frozen_analog_input_32wFlag(flag(), frozen_value());
	BINPAC_ASSERT(t_begin_of_data + (5) <= t_end_of_data);
	return 5;
	}

FrozenAnalogInput16wFlag::FrozenAnalogInput16wFlag()
	{
	flag_ = 0;
	frozen_value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

FrozenAnalogInput16wFlag::~FrozenAnalogInput16wFlag()
	{
	}

int FrozenAnalogInput16wFlag::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "FrozenAnalogInput16wFlag"
	if ( t_begin_of_data + (3) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenAnalogInput16wFlag",
			(0) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "frozen_value"
	frozen_value_ = FixByteOrder(byteorder(), *((int16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_frozen_analog_input_16wFlag(flag(), frozen_value());
	BINPAC_ASSERT(t_begin_of_data + (3) <= t_end_of_data);
	return 3;
	}

FrozenAnalogInput32wTime::FrozenAnalogInput32wTime()
	{
	flag_ = 0;
	frozen_value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

FrozenAnalogInput32wTime::~FrozenAnalogInput32wTime()
	{
	time48_.free();
	}

int FrozenAnalogInput32wTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "FrozenAnalogInput32wTime:frozen_value"
	if ( (t_begin_of_data + 1) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenAnalogInput32wTime:frozen_value",
			(1) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "frozen_value"
	frozen_value_ = FixByteOrder(byteorder(), *((int32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time48"
	// Checking out-of-bound for "FrozenAnalogInput32wTime:time48"
	if ( (t_begin_of_data + 5) + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenAnalogInput32wTime:time48",
			(5) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 5) + 6;
	int t_time48_string_length;
	t_time48_string_length = 6;
	int t_time48__size;
	t_time48__size = t_time48_string_length;
	time48_.init((t_begin_of_data + 5), t_time48_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_FrozenAnalogInput32wTime__size;
	const_byteptr const t_dataptr_after_time48 = (t_begin_of_data + 5) + (6);
	BINPAC_ASSERT(t_dataptr_after_time48 <= t_end_of_data);
	t_FrozenAnalogInput32wTime__size = t_dataptr_after_time48 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_frozen_analog_input_32wTime(flag(), frozen_value(), time48());
	BINPAC_ASSERT(t_begin_of_data + (t_FrozenAnalogInput32wTime__size) <= t_end_of_data);
	return t_FrozenAnalogInput32wTime__size;
	}

FrozenAnalogInput16wTime::FrozenAnalogInput16wTime()
	{
	flag_ = 0;
	frozen_value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

FrozenAnalogInput16wTime::~FrozenAnalogInput16wTime()
	{
	time48_.free();
	}

int FrozenAnalogInput16wTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "FrozenAnalogInput16wTime:frozen_value"
	if ( (t_begin_of_data + 1) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenAnalogInput16wTime:frozen_value",
			(1) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "frozen_value"
	frozen_value_ = FixByteOrder(byteorder(), *((int16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time48"
	// Checking out-of-bound for "FrozenAnalogInput16wTime:time48"
	if ( (t_begin_of_data + 3) + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenAnalogInput16wTime:time48",
			(3) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 3) + 6;
	int t_time48_string_length;
	t_time48_string_length = 6;
	int t_time48__size;
	t_time48__size = t_time48_string_length;
	time48_.init((t_begin_of_data + 3), t_time48_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_FrozenAnalogInput16wTime__size;
	const_byteptr const t_dataptr_after_time48 = (t_begin_of_data + 3) + (6);
	BINPAC_ASSERT(t_dataptr_after_time48 <= t_end_of_data);
	t_FrozenAnalogInput16wTime__size = t_dataptr_after_time48 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_frozen_analog_input_16wTime(flag(), frozen_value(), time48());
	BINPAC_ASSERT(t_begin_of_data + (t_FrozenAnalogInput16wTime__size) <= t_end_of_data);
	return t_FrozenAnalogInput16wTime__size;
	}

FrozenAnalogInput32woFlag::FrozenAnalogInput32woFlag()
	{
	frozen_value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

FrozenAnalogInput32woFlag::~FrozenAnalogInput32woFlag()
	{
	}

int FrozenAnalogInput32woFlag::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "FrozenAnalogInput32woFlag"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenAnalogInput32woFlag",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "frozen_value"
	frozen_value_ = FixByteOrder(byteorder(), *((int32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_frozen_analog_input_32woFlag(frozen_value());
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

FrozenAnalogInput16woFlag::FrozenAnalogInput16woFlag()
	{
	frozen_value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

FrozenAnalogInput16woFlag::~FrozenAnalogInput16woFlag()
	{
	}

int FrozenAnalogInput16woFlag::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "FrozenAnalogInput16woFlag"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenAnalogInput16woFlag",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "frozen_value"
	frozen_value_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_frozen_analog_input_16woFlag(frozen_value());
	BINPAC_ASSERT(t_begin_of_data + (2) <= t_end_of_data);
	return 2;
	}

FrozenAnalogInputSPwFlag::FrozenAnalogInputSPwFlag()
	{
	flag_ = 0;
	frozen_value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

FrozenAnalogInputSPwFlag::~FrozenAnalogInputSPwFlag()
	{
	}

int FrozenAnalogInputSPwFlag::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "FrozenAnalogInputSPwFlag"
	if ( t_begin_of_data + (5) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenAnalogInputSPwFlag",
			(0) + (5), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "frozen_value"
	frozen_value_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_frozen_analog_input_SPwFlag(flag(), frozen_value());
	BINPAC_ASSERT(t_begin_of_data + (5) <= t_end_of_data);
	return 5;
	}

FrozenAnalogInputDPwFlag::FrozenAnalogInputDPwFlag()
	{
	flag_ = 0;
	frozen_value_low_ = 0;
	frozen_value_high_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

FrozenAnalogInputDPwFlag::~FrozenAnalogInputDPwFlag()
	{
	}

int FrozenAnalogInputDPwFlag::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "FrozenAnalogInputDPwFlag"
	if ( t_begin_of_data + (9) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenAnalogInputDPwFlag",
			(0) + (9), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "frozen_value_low"
	frozen_value_low_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "frozen_value_high"
	frozen_value_high_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 5))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_frozen_analog_input_DPwFlag(flag(), frozen_value_low(), frozen_value_high());
	BINPAC_ASSERT(t_begin_of_data + (9) <= t_end_of_data);
	return 9;
	}

AnalogInput32woTime::AnalogInput32woTime()
	{
	flag_ = 0;
	value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

AnalogInput32woTime::~AnalogInput32woTime()
	{
	}

int AnalogInput32woTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "AnalogInput32woTime"
	if ( t_begin_of_data + (5) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnalogInput32woTime",
			(0) + (5), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	value_ = FixByteOrder(byteorder(), *((int32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_analog_input_event_32woTime(flag(), value());
	BINPAC_ASSERT(t_begin_of_data + (5) <= t_end_of_data);
	return 5;
	}

AnalogInput16woTime::AnalogInput16woTime()
	{
	flag_ = 0;
	value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

AnalogInput16woTime::~AnalogInput16woTime()
	{
	}

int AnalogInput16woTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "AnalogInput16woTime"
	if ( t_begin_of_data + (3) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnalogInput16woTime",
			(0) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	value_ = FixByteOrder(byteorder(), *((int16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_analog_input_event_16woTime(flag(), value());
	BINPAC_ASSERT(t_begin_of_data + (3) <= t_end_of_data);
	return 3;
	}

AnalogInput32wTime::AnalogInput32wTime()
	{
	flag_ = 0;
	value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

AnalogInput32wTime::~AnalogInput32wTime()
	{
	time48_.free();
	}

int AnalogInput32wTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "AnalogInput32wTime:value"
	if ( (t_begin_of_data + 1) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnalogInput32wTime:value",
			(1) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	value_ = FixByteOrder(byteorder(), *((int32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time48"
	// Checking out-of-bound for "AnalogInput32wTime:time48"
	if ( (t_begin_of_data + 5) + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnalogInput32wTime:time48",
			(5) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 5) + 6;
	int t_time48_string_length;
	t_time48_string_length = 6;
	int t_time48__size;
	t_time48__size = t_time48_string_length;
	time48_.init((t_begin_of_data + 5), t_time48_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_AnalogInput32wTime__size;
	const_byteptr const t_dataptr_after_time48 = (t_begin_of_data + 5) + (6);
	BINPAC_ASSERT(t_dataptr_after_time48 <= t_end_of_data);
	t_AnalogInput32wTime__size = t_dataptr_after_time48 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_analog_input_event_32wTime(flag(), value(), time48());
	BINPAC_ASSERT(t_begin_of_data + (t_AnalogInput32wTime__size) <= t_end_of_data);
	return t_AnalogInput32wTime__size;
	}

AnalogInput16wTime::AnalogInput16wTime()
	{
	flag_ = 0;
	value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

AnalogInput16wTime::~AnalogInput16wTime()
	{
	time48_.free();
	}

int AnalogInput16wTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "AnalogInput16wTime:value"
	if ( (t_begin_of_data + 1) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnalogInput16wTime:value",
			(1) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	value_ = FixByteOrder(byteorder(), *((int16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time48"
	// Checking out-of-bound for "AnalogInput16wTime:time48"
	if ( (t_begin_of_data + 3) + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnalogInput16wTime:time48",
			(3) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 3) + 6;
	int t_time48_string_length;
	t_time48_string_length = 6;
	int t_time48__size;
	t_time48__size = t_time48_string_length;
	time48_.init((t_begin_of_data + 3), t_time48_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_AnalogInput16wTime__size;
	const_byteptr const t_dataptr_after_time48 = (t_begin_of_data + 3) + (6);
	BINPAC_ASSERT(t_dataptr_after_time48 <= t_end_of_data);
	t_AnalogInput16wTime__size = t_dataptr_after_time48 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_analog_input_event_16wTime(flag(), value(), time48());
	BINPAC_ASSERT(t_begin_of_data + (t_AnalogInput16wTime__size) <= t_end_of_data);
	return t_AnalogInput16wTime__size;
	}

AnalogInputSPwoTime::AnalogInputSPwoTime()
	{
	flag_ = 0;
	value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

AnalogInputSPwoTime::~AnalogInputSPwoTime()
	{
	}

int AnalogInputSPwoTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "AnalogInputSPwoTime"
	if ( t_begin_of_data + (5) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnalogInputSPwoTime",
			(0) + (5), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	value_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_analog_input_event_SPwoTime(flag(), value());
	BINPAC_ASSERT(t_begin_of_data + (5) <= t_end_of_data);
	return 5;
	}

AnalogInputDPwoTime::AnalogInputDPwoTime()
	{
	flag_ = 0;
	value_low_ = 0;
	value_high_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

AnalogInputDPwoTime::~AnalogInputDPwoTime()
	{
	}

int AnalogInputDPwoTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "AnalogInputDPwoTime"
	if ( t_begin_of_data + (9) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnalogInputDPwoTime",
			(0) + (9), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value_low"
	value_low_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value_high"
	value_high_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 5))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_analog_input_event_DPwoTime(flag(), value_low(), value_high());
	BINPAC_ASSERT(t_begin_of_data + (9) <= t_end_of_data);
	return 9;
	}

AnalogInputSPwTime::AnalogInputSPwTime()
	{
	flag_ = 0;
	value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

AnalogInputSPwTime::~AnalogInputSPwTime()
	{
	time48_.free();
	}

int AnalogInputSPwTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "AnalogInputSPwTime:value"
	if ( (t_begin_of_data + 1) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnalogInputSPwTime:value",
			(1) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	value_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time48"
	// Checking out-of-bound for "AnalogInputSPwTime:time48"
	if ( (t_begin_of_data + 5) + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnalogInputSPwTime:time48",
			(5) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 5) + 6;
	int t_time48_string_length;
	t_time48_string_length = 6;
	int t_time48__size;
	t_time48__size = t_time48_string_length;
	time48_.init((t_begin_of_data + 5), t_time48_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_AnalogInputSPwTime__size;
	const_byteptr const t_dataptr_after_time48 = (t_begin_of_data + 5) + (6);
	BINPAC_ASSERT(t_dataptr_after_time48 <= t_end_of_data);
	t_AnalogInputSPwTime__size = t_dataptr_after_time48 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_analog_input_event_SPwTime(flag(), value(), time48());
	BINPAC_ASSERT(t_begin_of_data + (t_AnalogInputSPwTime__size) <= t_end_of_data);
	return t_AnalogInputSPwTime__size;
	}

AnalogInputDPwTime::AnalogInputDPwTime()
	{
	flag_ = 0;
	value_low_ = 0;
	value_high_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

AnalogInputDPwTime::~AnalogInputDPwTime()
	{
	time48_.free();
	}

int AnalogInputDPwTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "AnalogInputDPwTime:value_high"
	if ( (t_begin_of_data + 5) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnalogInputDPwTime:value_high",
			(5) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value_low"
	value_low_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value_high"
	value_high_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 5))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time48"
	// Checking out-of-bound for "AnalogInputDPwTime:time48"
	if ( (t_begin_of_data + 9) + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnalogInputDPwTime:time48",
			(9) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 9) + 6;
	int t_time48_string_length;
	t_time48_string_length = 6;
	int t_time48__size;
	t_time48__size = t_time48_string_length;
	time48_.init((t_begin_of_data + 9), t_time48_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_AnalogInputDPwTime__size;
	const_byteptr const t_dataptr_after_time48 = (t_begin_of_data + 9) + (6);
	BINPAC_ASSERT(t_dataptr_after_time48 <= t_end_of_data);
	t_AnalogInputDPwTime__size = t_dataptr_after_time48 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_analog_input_event_DPwTime(flag(), value_low(), value_high(), time48());
	BINPAC_ASSERT(t_begin_of_data + (t_AnalogInputDPwTime__size) <= t_end_of_data);
	return t_AnalogInputDPwTime__size;
	}

FrozenAnaInputEve32woTime::FrozenAnaInputEve32woTime()
	{
	flag_ = 0;
	f_value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

FrozenAnaInputEve32woTime::~FrozenAnaInputEve32woTime()
	{
	}

int FrozenAnaInputEve32woTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "FrozenAnaInputEve32woTime"
	if ( t_begin_of_data + (5) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenAnaInputEve32woTime",
			(0) + (5), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "f_value"
	f_value_ = FixByteOrder(byteorder(), *((int32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_frozen_analog_input_event_32woTime(flag(), f_value());
	BINPAC_ASSERT(t_begin_of_data + (5) <= t_end_of_data);
	return 5;
	}

FrozenAnaInputEve16woTime::FrozenAnaInputEve16woTime()
	{
	flag_ = 0;
	f_value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

FrozenAnaInputEve16woTime::~FrozenAnaInputEve16woTime()
	{
	}

int FrozenAnaInputEve16woTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "FrozenAnaInputEve16woTime"
	if ( t_begin_of_data + (3) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenAnaInputEve16woTime",
			(0) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "f_value"
	f_value_ = FixByteOrder(byteorder(), *((int16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_frozen_analog_input_event_16woTime(flag(), f_value());
	BINPAC_ASSERT(t_begin_of_data + (3) <= t_end_of_data);
	return 3;
	}

FrozenAnaInputEve32wTime::FrozenAnaInputEve32wTime()
	{
	flag_ = 0;
	f_value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

FrozenAnaInputEve32wTime::~FrozenAnaInputEve32wTime()
	{
	time48_.free();
	}

int FrozenAnaInputEve32wTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "FrozenAnaInputEve32wTime:f_value"
	if ( (t_begin_of_data + 1) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenAnaInputEve32wTime:f_value",
			(1) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "f_value"
	f_value_ = FixByteOrder(byteorder(), *((int32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time48"
	// Checking out-of-bound for "FrozenAnaInputEve32wTime:time48"
	if ( (t_begin_of_data + 5) + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenAnaInputEve32wTime:time48",
			(5) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 5) + 6;
	int t_time48_string_length;
	t_time48_string_length = 6;
	int t_time48__size;
	t_time48__size = t_time48_string_length;
	time48_.init((t_begin_of_data + 5), t_time48_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_FrozenAnaInputEve32wTime__size;
	const_byteptr const t_dataptr_after_time48 = (t_begin_of_data + 5) + (6);
	BINPAC_ASSERT(t_dataptr_after_time48 <= t_end_of_data);
	t_FrozenAnaInputEve32wTime__size = t_dataptr_after_time48 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_frozen_analog_input_event_32wTime(flag(), f_value(), time48());
	BINPAC_ASSERT(t_begin_of_data + (t_FrozenAnaInputEve32wTime__size) <= t_end_of_data);
	return t_FrozenAnaInputEve32wTime__size;
	}

FrozenAnaInputEve16wTime::FrozenAnaInputEve16wTime()
	{
	flag_ = 0;
	f_value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

FrozenAnaInputEve16wTime::~FrozenAnaInputEve16wTime()
	{
	time48_.free();
	}

int FrozenAnaInputEve16wTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "FrozenAnaInputEve16wTime:f_value"
	if ( (t_begin_of_data + 1) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenAnaInputEve16wTime:f_value",
			(1) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "f_value"
	f_value_ = FixByteOrder(byteorder(), *((int32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time48"
	// Checking out-of-bound for "FrozenAnaInputEve16wTime:time48"
	if ( (t_begin_of_data + 5) + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenAnaInputEve16wTime:time48",
			(5) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 5) + 6;
	int t_time48_string_length;
	t_time48_string_length = 6;
	int t_time48__size;
	t_time48__size = t_time48_string_length;
	time48_.init((t_begin_of_data + 5), t_time48_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_FrozenAnaInputEve16wTime__size;
	const_byteptr const t_dataptr_after_time48 = (t_begin_of_data + 5) + (6);
	BINPAC_ASSERT(t_dataptr_after_time48 <= t_end_of_data);
	t_FrozenAnaInputEve16wTime__size = t_dataptr_after_time48 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_frozen_analog_input_event_16wTime(flag(), f_value(), time48());
	BINPAC_ASSERT(t_begin_of_data + (t_FrozenAnaInputEve16wTime__size) <= t_end_of_data);
	return t_FrozenAnaInputEve16wTime__size;
	}

FrozenAnaInputEveSPwoTime::FrozenAnaInputEveSPwoTime()
	{
	flag_ = 0;
	f_value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

FrozenAnaInputEveSPwoTime::~FrozenAnaInputEveSPwoTime()
	{
	}

int FrozenAnaInputEveSPwoTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "FrozenAnaInputEveSPwoTime"
	if ( t_begin_of_data + (5) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenAnaInputEveSPwoTime",
			(0) + (5), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "f_value"
	f_value_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_frozen_analog_input_event_SPwoTime(flag(), f_value());
	BINPAC_ASSERT(t_begin_of_data + (5) <= t_end_of_data);
	return 5;
	}

FrozenAnaInputEveDPwoTime::FrozenAnaInputEveDPwoTime()
	{
	flag_ = 0;
	f_value_low_ = 0;
	f_value_high_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

FrozenAnaInputEveDPwoTime::~FrozenAnaInputEveDPwoTime()
	{
	}

int FrozenAnaInputEveDPwoTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "FrozenAnaInputEveDPwoTime"
	if ( t_begin_of_data + (9) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenAnaInputEveDPwoTime",
			(0) + (9), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "f_value_low"
	f_value_low_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "f_value_high"
	f_value_high_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 5))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_frozen_analog_input_event_DPwoTime(flag(), f_value_low(), f_value_high());
	BINPAC_ASSERT(t_begin_of_data + (9) <= t_end_of_data);
	return 9;
	}

FrozenAnaInputEveSPwTime::FrozenAnaInputEveSPwTime()
	{
	flag_ = 0;
	f_value_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

FrozenAnaInputEveSPwTime::~FrozenAnaInputEveSPwTime()
	{
	time48_.free();
	}

int FrozenAnaInputEveSPwTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "FrozenAnaInputEveSPwTime:f_value"
	if ( (t_begin_of_data + 1) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenAnaInputEveSPwTime:f_value",
			(1) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "f_value"
	f_value_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time48"
	// Checking out-of-bound for "FrozenAnaInputEveSPwTime:time48"
	if ( (t_begin_of_data + 5) + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenAnaInputEveSPwTime:time48",
			(5) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 5) + 6;
	int t_time48_string_length;
	t_time48_string_length = 6;
	int t_time48__size;
	t_time48__size = t_time48_string_length;
	time48_.init((t_begin_of_data + 5), t_time48_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_FrozenAnaInputEveSPwTime__size;
	const_byteptr const t_dataptr_after_time48 = (t_begin_of_data + 5) + (6);
	BINPAC_ASSERT(t_dataptr_after_time48 <= t_end_of_data);
	t_FrozenAnaInputEveSPwTime__size = t_dataptr_after_time48 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_frozen_analog_input_event_SPwTime(flag(), f_value(), time48());
	BINPAC_ASSERT(t_begin_of_data + (t_FrozenAnaInputEveSPwTime__size) <= t_end_of_data);
	return t_FrozenAnaInputEveSPwTime__size;
	}

FrozenAnaInputEveDPwTime::FrozenAnaInputEveDPwTime()
	{
	flag_ = 0;
	f_value_low_ = 0;
	f_value_high_ = 0;
	byteorder_ = littleendian;
	process_request_ = 0;
	}

FrozenAnaInputEveDPwTime::~FrozenAnaInputEveDPwTime()
	{
	time48_.free();
	}

int FrozenAnaInputEveDPwTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "FrozenAnaInputEveDPwTime:f_value_high"
	if ( (t_begin_of_data + 5) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenAnaInputEveDPwTime:f_value_high",
			(5) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "f_value_low"
	f_value_low_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "f_value_high"
	f_value_high_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 5))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time48"
	// Checking out-of-bound for "FrozenAnaInputEveDPwTime:time48"
	if ( (t_begin_of_data + 9) + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FrozenAnaInputEveDPwTime:time48",
			(9) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 9) + 6;
	int t_time48_string_length;
	t_time48_string_length = 6;
	int t_time48__size;
	t_time48__size = t_time48_string_length;
	time48_.init((t_begin_of_data + 9), t_time48_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_FrozenAnaInputEveDPwTime__size;
	const_byteptr const t_dataptr_after_time48 = (t_begin_of_data + 9) + (6);
	BINPAC_ASSERT(t_dataptr_after_time48 <= t_end_of_data);
	t_FrozenAnaInputEveDPwTime__size = t_dataptr_after_time48 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	process_request_ = t_context->flow()->get_dnp3_frozen_analog_input_event_DPwTime(flag(), f_value_low(), f_value_high(), time48());
	BINPAC_ASSERT(t_begin_of_data + (t_FrozenAnaInputEveDPwTime__size) <= t_end_of_data);
	return t_FrozenAnaInputEveDPwTime__size;
	}

AnaOutStatus32::AnaOutStatus32()
	{
	flag_ = 0;
	status_ = 0;
	byteorder_ = littleendian;
	}

AnaOutStatus32::~AnaOutStatus32()
	{
	}

int AnaOutStatus32::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "AnaOutStatus32"
	if ( t_begin_of_data + (5) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnaOutStatus32",
			(0) + (5), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "status"
	status_ = FixByteOrder(byteorder(), *((int32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (5) <= t_end_of_data);
	return 5;
	}

AnaOutStatus16::AnaOutStatus16()
	{
	flag_ = 0;
	status_ = 0;
	byteorder_ = littleendian;
	}

AnaOutStatus16::~AnaOutStatus16()
	{
	}

int AnaOutStatus16::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "AnaOutStatus16"
	if ( t_begin_of_data + (3) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnaOutStatus16",
			(0) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "status"
	status_ = FixByteOrder(byteorder(), *((int16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (3) <= t_end_of_data);
	return 3;
	}

AnaOutStatusSP::AnaOutStatusSP()
	{
	flag_ = 0;
	status_ = 0;
	byteorder_ = littleendian;
	}

AnaOutStatusSP::~AnaOutStatusSP()
	{
	}

int AnaOutStatusSP::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "AnaOutStatusSP"
	if ( t_begin_of_data + (5) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnaOutStatusSP",
			(0) + (5), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "status"
	status_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (5) <= t_end_of_data);
	return 5;
	}

AnaOutStatusDP::AnaOutStatusDP()
	{
	flag_ = 0;
	status_low_ = 0;
	status_high_ = 0;
	byteorder_ = littleendian;
	}

AnaOutStatusDP::~AnaOutStatusDP()
	{
	}

int AnaOutStatusDP::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "AnaOutStatusDP"
	if ( t_begin_of_data + (9) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnaOutStatusDP",
			(0) + (9), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "status_low"
	status_low_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "status_high"
	status_high_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 5))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (9) <= t_end_of_data);
	return 9;
	}

AnaOut32::AnaOut32()
	{
	value_ = 0;
	con_status_ = 0;
	byteorder_ = littleendian;
	}

AnaOut32::~AnaOut32()
	{
	}

int AnaOut32::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "AnaOut32"
	if ( t_begin_of_data + (5) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnaOut32",
			(0) + (5), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "value"
	value_ = FixByteOrder(byteorder(), *((int32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "con_status"
	con_status_ = *((uint8 const *) ((t_begin_of_data + 4)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (5) <= t_end_of_data);
	return 5;
	}

AnaOut16::AnaOut16()
	{
	value_ = 0;
	con_status_ = 0;
	byteorder_ = littleendian;
	}

AnaOut16::~AnaOut16()
	{
	}

int AnaOut16::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "AnaOut16"
	if ( t_begin_of_data + (3) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnaOut16",
			(0) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "value"
	value_ = FixByteOrder(byteorder(), *((int16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "con_status"
	con_status_ = *((uint8 const *) ((t_begin_of_data + 2)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (3) <= t_end_of_data);
	return 3;
	}

AnaOutSP::AnaOutSP()
	{
	value_ = 0;
	con_status_ = 0;
	byteorder_ = littleendian;
	}

AnaOutSP::~AnaOutSP()
	{
	}

int AnaOutSP::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "AnaOutSP"
	if ( t_begin_of_data + (5) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnaOutSP",
			(0) + (5), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "value"
	value_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "con_status"
	con_status_ = *((uint8 const *) ((t_begin_of_data + 4)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (5) <= t_end_of_data);
	return 5;
	}

AnaOutDP::AnaOutDP()
	{
	value_low_ = 0;
	value_high_ = 0;
	con_status_ = 0;
	byteorder_ = littleendian;
	}

AnaOutDP::~AnaOutDP()
	{
	}

int AnaOutDP::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "AnaOutDP"
	if ( t_begin_of_data + (9) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnaOutDP",
			(0) + (9), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "value_low"
	value_low_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value_high"
	value_high_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "con_status"
	con_status_ = *((uint8 const *) ((t_begin_of_data + 8)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (9) <= t_end_of_data);
	return 9;
	}

AnaOutEve32woTime::AnaOutEve32woTime()
	{
	flag_ = 0;
	value_ = 0;
	byteorder_ = littleendian;
	}

AnaOutEve32woTime::~AnaOutEve32woTime()
	{
	}

int AnaOutEve32woTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "AnaOutEve32woTime"
	if ( t_begin_of_data + (5) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnaOutEve32woTime",
			(0) + (5), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	value_ = FixByteOrder(byteorder(), *((int32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (5) <= t_end_of_data);
	return 5;
	}

AnaOutEve16woTime::AnaOutEve16woTime()
	{
	flag_ = 0;
	value_ = 0;
	byteorder_ = littleendian;
	}

AnaOutEve16woTime::~AnaOutEve16woTime()
	{
	}

int AnaOutEve16woTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "AnaOutEve16woTime"
	if ( t_begin_of_data + (3) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnaOutEve16woTime",
			(0) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	value_ = FixByteOrder(byteorder(), *((int16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (3) <= t_end_of_data);
	return 3;
	}

AnaOutEve32wTime::AnaOutEve32wTime()
	{
	flag_ = 0;
	value_ = 0;
	byteorder_ = littleendian;
	}

AnaOutEve32wTime::~AnaOutEve32wTime()
	{
	time48_.free();
	}

int AnaOutEve32wTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "AnaOutEve32wTime:value"
	if ( (t_begin_of_data + 1) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnaOutEve32wTime:value",
			(1) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	value_ = FixByteOrder(byteorder(), *((int32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time48"
	// Checking out-of-bound for "AnaOutEve32wTime:time48"
	if ( (t_begin_of_data + 5) + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnaOutEve32wTime:time48",
			(5) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 5) + 6;
	int t_time48_string_length;
	t_time48_string_length = 6;
	int t_time48__size;
	t_time48__size = t_time48_string_length;
	time48_.init((t_begin_of_data + 5), t_time48_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_AnaOutEve32wTime__size;
	const_byteptr const t_dataptr_after_time48 = (t_begin_of_data + 5) + (6);
	BINPAC_ASSERT(t_dataptr_after_time48 <= t_end_of_data);
	t_AnaOutEve32wTime__size = t_dataptr_after_time48 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_AnaOutEve32wTime__size) <= t_end_of_data);
	return t_AnaOutEve32wTime__size;
	}

AnaOutEve16wTime::AnaOutEve16wTime()
	{
	flag_ = 0;
	value_ = 0;
	byteorder_ = littleendian;
	}

AnaOutEve16wTime::~AnaOutEve16wTime()
	{
	time48_.free();
	}

int AnaOutEve16wTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "AnaOutEve16wTime:value"
	if ( (t_begin_of_data + 1) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnaOutEve16wTime:value",
			(1) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	value_ = FixByteOrder(byteorder(), *((int16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time48"
	// Checking out-of-bound for "AnaOutEve16wTime:time48"
	if ( (t_begin_of_data + 3) + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnaOutEve16wTime:time48",
			(3) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 3) + 6;
	int t_time48_string_length;
	t_time48_string_length = 6;
	int t_time48__size;
	t_time48__size = t_time48_string_length;
	time48_.init((t_begin_of_data + 3), t_time48_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_AnaOutEve16wTime__size;
	const_byteptr const t_dataptr_after_time48 = (t_begin_of_data + 3) + (6);
	BINPAC_ASSERT(t_dataptr_after_time48 <= t_end_of_data);
	t_AnaOutEve16wTime__size = t_dataptr_after_time48 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_AnaOutEve16wTime__size) <= t_end_of_data);
	return t_AnaOutEve16wTime__size;
	}

AnaOutEveSPwoTime::AnaOutEveSPwoTime()
	{
	flag_ = 0;
	value_ = 0;
	byteorder_ = littleendian;
	}

AnaOutEveSPwoTime::~AnaOutEveSPwoTime()
	{
	}

int AnaOutEveSPwoTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "AnaOutEveSPwoTime"
	if ( t_begin_of_data + (5) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnaOutEveSPwoTime",
			(0) + (5), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	value_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (5) <= t_end_of_data);
	return 5;
	}

AnaOutEveDPwoTime::AnaOutEveDPwoTime()
	{
	flag_ = 0;
	value_low_ = 0;
	value_high_ = 0;
	byteorder_ = littleendian;
	}

AnaOutEveDPwoTime::~AnaOutEveDPwoTime()
	{
	}

int AnaOutEveDPwoTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "AnaOutEveDPwoTime"
	if ( t_begin_of_data + (9) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnaOutEveDPwoTime",
			(0) + (9), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value_low"
	value_low_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value_high"
	value_high_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 5))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (9) <= t_end_of_data);
	return 9;
	}

AnaOutEveSPwTime::AnaOutEveSPwTime()
	{
	flag_ = 0;
	value_ = 0;
	byteorder_ = littleendian;
	}

AnaOutEveSPwTime::~AnaOutEveSPwTime()
	{
	time48_.free();
	}

int AnaOutEveSPwTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "AnaOutEveSPwTime:value"
	if ( (t_begin_of_data + 1) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnaOutEveSPwTime:value",
			(1) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	value_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time48"
	// Checking out-of-bound for "AnaOutEveSPwTime:time48"
	if ( (t_begin_of_data + 5) + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnaOutEveSPwTime:time48",
			(5) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 5) + 6;
	int t_time48_string_length;
	t_time48_string_length = 6;
	int t_time48__size;
	t_time48__size = t_time48_string_length;
	time48_.init((t_begin_of_data + 5), t_time48_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_AnaOutEveSPwTime__size;
	const_byteptr const t_dataptr_after_time48 = (t_begin_of_data + 5) + (6);
	BINPAC_ASSERT(t_dataptr_after_time48 <= t_end_of_data);
	t_AnaOutEveSPwTime__size = t_dataptr_after_time48 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_AnaOutEveSPwTime__size) <= t_end_of_data);
	return t_AnaOutEveSPwTime__size;
	}

AnaOutEveDPwTime::AnaOutEveDPwTime()
	{
	flag_ = 0;
	value_low_ = 0;
	value_high_ = 0;
	byteorder_ = littleendian;
	}

AnaOutEveDPwTime::~AnaOutEveDPwTime()
	{
	time48_.free();
	}

int AnaOutEveDPwTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "AnaOutEveDPwTime:value_high"
	if ( (t_begin_of_data + 5) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnaOutEveDPwTime:value_high",
			(5) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value_low"
	value_low_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value_high"
	value_high_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 5))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time48"
	// Checking out-of-bound for "AnaOutEveDPwTime:time48"
	if ( (t_begin_of_data + 9) + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AnaOutEveDPwTime:time48",
			(9) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 9) + 6;
	int t_time48_string_length;
	t_time48_string_length = 6;
	int t_time48__size;
	t_time48__size = t_time48_string_length;
	time48_.init((t_begin_of_data + 9), t_time48_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_AnaOutEveDPwTime__size;
	const_byteptr const t_dataptr_after_time48 = (t_begin_of_data + 9) + (6);
	BINPAC_ASSERT(t_dataptr_after_time48 <= t_end_of_data);
	t_AnaOutEveDPwTime__size = t_dataptr_after_time48 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_AnaOutEveDPwTime__size) <= t_end_of_data);
	return t_AnaOutEveDPwTime__size;
	}

AbsTime::AbsTime()
	{
	byteorder_ = littleendian;
	}

AbsTime::~AbsTime()
	{
	time48_.free();
	}

int AbsTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "time48"
	// Checking out-of-bound for "AbsTime:time48"
	if ( t_begin_of_data + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AbsTime:time48",
			(0) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + 6;
	int t_time48_string_length;
	t_time48_string_length = 6;
	int t_time48__size;
	t_time48__size = t_time48_string_length;
	time48_.init(t_begin_of_data, t_time48_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_AbsTime__size;
	const_byteptr const t_dataptr_after_time48 = t_begin_of_data + (6);
	BINPAC_ASSERT(t_dataptr_after_time48 <= t_end_of_data);
	t_AbsTime__size = t_dataptr_after_time48 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_AbsTime__size) <= t_end_of_data);
	return t_AbsTime__size;
	}

AbsTimeInterval::AbsTimeInterval()
	{
	interval_ = 0;
	byteorder_ = littleendian;
	}

AbsTimeInterval::~AbsTimeInterval()
	{
	time48_.free();
	}

int AbsTimeInterval::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "time48"
	// Checking out-of-bound for "AbsTimeInterval:time48"
	if ( t_begin_of_data + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AbsTimeInterval:time48",
			(0) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + 6;
	int t_time48_string_length;
	t_time48_string_length = 6;
	int t_time48__size;
	t_time48__size = t_time48_string_length;
	time48_.init(t_begin_of_data, t_time48_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_time48 = t_begin_of_data + (6);
	BINPAC_ASSERT(t_dataptr_after_time48 <= t_end_of_data);
	// Checking out-of-bound for "AbsTimeInterval:interval"
	if ( t_dataptr_after_time48 + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AbsTimeInterval:interval",
			((t_dataptr_after_time48 - t_begin_of_data)) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "interval"
	interval_ = FixByteOrder(byteorder(), *((uint32 const *) (t_dataptr_after_time48)));
	// Evaluate 'let' and 'withinput' fields
	
	int t_AbsTimeInterval__size;
	t_AbsTimeInterval__size = (t_dataptr_after_time48 + 4) - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_AbsTimeInterval__size) <= t_end_of_data);
	return t_AbsTimeInterval__size;
	}

Last_AbsTime::Last_AbsTime()
	{
	byteorder_ = littleendian;
	}

Last_AbsTime::~Last_AbsTime()
	{
	time48_.free();
	}

int Last_AbsTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "time48"
	// Checking out-of-bound for "Last_AbsTime:time48"
	if ( t_begin_of_data + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Last_AbsTime:time48",
			(0) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + 6;
	int t_time48_string_length;
	t_time48_string_length = 6;
	int t_time48__size;
	t_time48__size = t_time48_string_length;
	time48_.init(t_begin_of_data, t_time48_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_Last_AbsTime__size;
	const_byteptr const t_dataptr_after_time48 = t_begin_of_data + (6);
	BINPAC_ASSERT(t_dataptr_after_time48 <= t_end_of_data);
	t_Last_AbsTime__size = t_dataptr_after_time48 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Last_AbsTime__size) <= t_end_of_data);
	return t_Last_AbsTime__size;
	}

Record_Obj::Record_Obj()
	{
	record_size_ = 0;
	byteorder_ = littleendian;
	}

Record_Obj::~Record_Obj()
	{
	record_oct_.free();
	}

int Record_Obj::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Record_Obj:record_size"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Record_Obj:record_size",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "record_size"
	record_size_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "record_oct"
	int t_record_oct__size;
	t_record_oct__size = record_size();
	// Checking out-of-bound for "Record_Obj:record_oct"
	if ( (t_begin_of_data + 2) + (t_record_oct__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Record_Obj:record_oct",
			(2) + (t_record_oct__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 2) + t_record_oct__size;
	int t_record_oct_string_length;
	t_record_oct_string_length = record_size();
	// check for negative sizes
	if ( t_record_oct_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-objects.pac:1184", t_record_oct_string_length);
	record_oct_.init((t_begin_of_data + 2), t_record_oct_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_Record_Obj__size;
	const_byteptr const t_dataptr_after_record_oct = (t_begin_of_data + 2) + (t_record_oct__size);
	BINPAC_ASSERT(t_dataptr_after_record_oct <= t_end_of_data);
	t_Record_Obj__size = t_dataptr_after_record_oct - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Record_Obj__size) <= t_end_of_data);
	return t_Record_Obj__size;
	}

File_Control_ID::File_Control_ID()
	{
	name_size_ = 0;
	type_code_ = 0;
	attr_code_ = 0;
	start_rec_ = 0;
	end_rec_ = 0;
	file_size_ = 0;
	permission_ = 0;
	file_id_ = 0;
	owner_id_ = 0;
	group_id_ = 0;
	function_code_ = 0;
	status_code_ = 0;
	records_ = 0;
	records__elem_ = 0;
	byteorder_ = littleendian;
	}

File_Control_ID::~File_Control_ID()
	{
	time_create_.free();
	file_name_.free();
	delete records__elem_;
	records__elem_ = 0;
	if ( records() )
		{
		for ( int i = 0; i < (int) records()->size(); ++i )
			{
			Record_Obj * records__elem_ = (*records_)[i];
			delete records__elem_;
			records__elem_ = 0;
			}
		}
	delete records_;
	}

int File_Control_ID::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "File_Control_ID:file_size"
	if ( (t_begin_of_data + 8) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("File_Control_ID:file_size",
			(8) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "name_size"
	name_size_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "type_code"
	type_code_ = *((uint8 const *) ((t_begin_of_data + 2)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "attr_code"
	attr_code_ = *((uint8 const *) ((t_begin_of_data + 3)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "start_rec"
	start_rec_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "end_rec"
	end_rec_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 6))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "file_size"
	file_size_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 8))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time_create"
	// Checking out-of-bound for "File_Control_ID:time_create"
	if ( (t_begin_of_data + 12) + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("File_Control_ID:time_create",
			(12) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 12) + 6;
	int t_time_create_string_length;
	t_time_create_string_length = 6;
	int t_time_create__size;
	t_time_create__size = t_time_create_string_length;
	time_create_.init((t_begin_of_data + 12), t_time_create_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_time_create = (t_begin_of_data + 12) + (6);
	BINPAC_ASSERT(t_dataptr_after_time_create <= t_end_of_data);
	// Checking out-of-bound for "File_Control_ID:status_code"
	if ( (t_dataptr_after_time_create + 15) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("File_Control_ID:status_code",
			(((t_dataptr_after_time_create + 15) - t_begin_of_data)) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "permission"
	permission_ = FixByteOrder(byteorder(), *((uint16 const *) (t_dataptr_after_time_create)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "file_id"
	file_id_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_dataptr_after_time_create + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "owner_id"
	owner_id_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_dataptr_after_time_create + 6))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "group_id"
	group_id_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_dataptr_after_time_create + 10))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "function_code"
	function_code_ = *((uint8 const *) ((t_dataptr_after_time_create + 14)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "status_code"
	status_code_ = *((uint8 const *) ((t_dataptr_after_time_create + 15)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "file_name"
	int t_file_name__size;
	t_file_name__size = name_size();
	// Checking out-of-bound for "File_Control_ID:file_name"
	if ( (t_dataptr_after_time_create + 16) + (t_file_name__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("File_Control_ID:file_name",
			(((t_dataptr_after_time_create + 16) - t_begin_of_data)) + (t_file_name__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_dataptr_after_time_create + 16) + t_file_name__size;
	int t_file_name_string_length;
	t_file_name_string_length = name_size();
	// check for negative sizes
	if ( t_file_name_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-objects.pac:1201", t_file_name_string_length);
	file_name_.init((t_dataptr_after_time_create + 16), t_file_name_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_file_name = (t_dataptr_after_time_create + 16) + (t_file_name__size);
	BINPAC_ASSERT(t_dataptr_after_file_name <= t_end_of_data);
	// Parse "records"
	int t_records__arraylength;
	t_records__arraylength = 0;
	records__elem_ = 0;
	int t_records__elem__it;
	t_records__elem__it = 0;
	int t_records__size;
	records_ = new vector<Record_Obj *>;
	const_byteptr t_records__elem__dataptr = t_dataptr_after_file_name;
	for (; /* forever */; ++t_records__elem__it)
		{
		// Check &until(records__elem__dataptr >= end_of_data)
		if ( t_records__elem__dataptr >= t_end_of_data )
			{
			records__elem_ = 0;
			goto end_of_records;
			}
		records__elem_ = new Record_Obj();
		int t_records__elem__size;
		t_records__elem__size = records__elem_->Parse(t_records__elem__dataptr, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		records_->push_back(records__elem_);
		t_records__elem__dataptr += t_records__elem__size;
		BINPAC_ASSERT(t_records__elem__dataptr <= t_end_of_data);
		records__elem_ = 0;
		}
end_of_records: ;
	t_records__size = t_records__elem__dataptr - (t_dataptr_after_file_name);
	// Evaluate 'let' and 'withinput' fields
	
	int t_File_Control_ID__size;
	const_byteptr const t_dataptr_after_records = t_dataptr_after_file_name + (t_records__size);
	BINPAC_ASSERT(t_dataptr_after_records <= t_end_of_data);
	t_File_Control_ID__size = t_dataptr_after_records - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_File_Control_ID__size) <= t_end_of_data);
	return t_File_Control_ID__size;
	}

File_Control_Auth_Wrap::File_Control_Auth_Wrap(uint8 fc)
	{
	data_case_index_ = -1;
	auth_file_ = 0;
	fc_ = fc;
	}

File_Control_Auth_Wrap::~File_Control_Auth_Wrap()
	{
	switch ( data_case_index() )
		{
		case 29:
			// Clean up "auth_file"
			{
			delete auth_file_;
			auth_file_ = 0;
			}
			break;
		default:
			// Clean up "null"
			{
			}
			break;
		}
	}

int File_Control_Auth_Wrap::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "data"
	int t_data__size;
	data_case_index_ =  ( fc() ) ;
	switch ( data_case_index() )
		{
		case 29:
			// Parse "auth_file"
			{
			auth_file_ = new File_Control_Auth();
			int t_auth_file__size;
			t_auth_file__size = auth_file_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_auth_file__size;
			}
			break;
		default:
			// Parse "null"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_File_Control_Auth_Wrap__size;
	const_byteptr const t_dataptr_after_data = t_begin_of_data + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_File_Control_Auth_Wrap__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_File_Control_Auth_Wrap__size) <= t_end_of_data);
	return t_File_Control_Auth_Wrap__size;
	}

File_Control_Auth::File_Control_Auth()
	{
	usr_name_offset_ = 0;
	usr_name_size_ = 0;
	pwd_offset_ = 0;
	pwd_size_ = 0;
	auth_key_ = 0;
	byteorder_ = littleendian;
	}

File_Control_Auth::~File_Control_Auth()
	{
	usr_name_.free();
	pwd_.free();
	}

int File_Control_Auth::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "File_Control_Auth:auth_key"
	if ( (t_begin_of_data + 8) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("File_Control_Auth:auth_key",
			(8) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "usr_name_offset"
	usr_name_offset_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "usr_name_size"
	usr_name_size_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "pwd_offset"
	pwd_offset_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "pwd_size"
	pwd_size_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 6))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "auth_key"
	auth_key_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 8))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "usr_name"
	int t_usr_name__size;
	t_usr_name__size = usr_name_size();
	// Checking out-of-bound for "File_Control_Auth:usr_name"
	if ( (t_begin_of_data + 12) + (t_usr_name__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("File_Control_Auth:usr_name",
			(12) + (t_usr_name__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 12) + t_usr_name__size;
	int t_usr_name_string_length;
	t_usr_name_string_length = usr_name_size();
	// check for negative sizes
	if ( t_usr_name_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-objects.pac:1219", t_usr_name_string_length);
	usr_name_.init((t_begin_of_data + 12), t_usr_name_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_usr_name = (t_begin_of_data + 12) + (t_usr_name__size);
	BINPAC_ASSERT(t_dataptr_after_usr_name <= t_end_of_data);
	// Parse "pwd"
	int t_pwd__size;
	t_pwd__size = pwd_size();
	// Checking out-of-bound for "File_Control_Auth:pwd"
	if ( t_dataptr_after_usr_name + (t_pwd__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("File_Control_Auth:pwd",
			((t_dataptr_after_usr_name - t_begin_of_data)) + (t_pwd__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_usr_name + t_pwd__size;
	int t_pwd_string_length;
	t_pwd_string_length = pwd_size();
	// check for negative sizes
	if ( t_pwd_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-objects.pac:1220", t_pwd_string_length);
	pwd_.init(t_dataptr_after_usr_name, t_pwd_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_File_Control_Auth__size;
	const_byteptr const t_dataptr_after_pwd = t_dataptr_after_usr_name + (t_pwd__size);
	BINPAC_ASSERT(t_dataptr_after_pwd <= t_end_of_data);
	t_File_Control_Auth__size = t_dataptr_after_pwd - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_File_Control_Auth__size) <= t_end_of_data);
	return t_File_Control_Auth__size;
	}

File_Control_Cmd_Wrap::File_Control_Cmd_Wrap(uint8 function_code)
	{
	data_obj_case_index_ = -1;
	fc_cmd_open_ = 0;
	fc_cmd_del_ = 0;
	function_code_ = function_code;
	}

File_Control_Cmd_Wrap::~File_Control_Cmd_Wrap()
	{
	switch ( data_obj_case_index() )
		{
		case 25:
			// Clean up "fc_cmd_open"
			{
			delete fc_cmd_open_;
			fc_cmd_open_ = 0;
			}
			break;
		case 27:
			// Clean up "fc_cmd_del"
			{
			delete fc_cmd_del_;
			fc_cmd_del_ = 0;
			}
			break;
		default:
			// Clean up "null"
			{
			}
			break;
		}
	}

int File_Control_Cmd_Wrap::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "data_obj"
	int t_data_obj__size;
	data_obj_case_index_ =  ( function_code() ) ;
	switch ( data_obj_case_index() )
		{
		case 25:
			// Parse "fc_cmd_open"
			{
			fc_cmd_open_ = new File_Control_Cmd();
			int t_fc_cmd_open__size;
			t_fc_cmd_open__size = fc_cmd_open_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data_obj__size = t_fc_cmd_open__size;
			}
			break;
		case 27:
			// Parse "fc_cmd_del"
			{
			fc_cmd_del_ = new File_Control_Cmd();
			int t_fc_cmd_del__size;
			t_fc_cmd_del__size = fc_cmd_del_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data_obj__size = t_fc_cmd_del__size;
			}
			break;
		default:
			// Parse "null"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data_obj__size = 0;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_File_Control_Cmd_Wrap__size;
	const_byteptr const t_dataptr_after_data_obj = t_begin_of_data + (t_data_obj__size);
	BINPAC_ASSERT(t_dataptr_after_data_obj <= t_end_of_data);
	t_File_Control_Cmd_Wrap__size = t_dataptr_after_data_obj - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_File_Control_Cmd_Wrap__size) <= t_end_of_data);
	return t_File_Control_Cmd_Wrap__size;
	}

File_Control_Cmd::File_Control_Cmd()
	{
	name_offset_ = 0;
	name_size_ = 0;
	permission_ = 0;
	auth_key_ = 0;
	file_size_ = 0;
	op_mode_ = 0;
	max_block_size_ = 0;
	req_id_ = 0;
	byteorder_ = littleendian;
	}

File_Control_Cmd::~File_Control_Cmd()
	{
	time_create_.free();
	file_name_.free();
	}

int File_Control_Cmd::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "File_Control_Cmd:name_size"
	if ( (t_begin_of_data + 2) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("File_Control_Cmd:name_size",
			(2) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "name_offset"
	name_offset_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "name_size"
	name_size_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time_create"
	// Checking out-of-bound for "File_Control_Cmd:time_create"
	if ( (t_begin_of_data + 4) + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("File_Control_Cmd:time_create",
			(4) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 4) + 6;
	int t_time_create_string_length;
	t_time_create_string_length = 6;
	int t_time_create__size;
	t_time_create__size = t_time_create_string_length;
	time_create_.init((t_begin_of_data + 4), t_time_create_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_time_create = (t_begin_of_data + 4) + (6);
	BINPAC_ASSERT(t_dataptr_after_time_create <= t_end_of_data);
	// Checking out-of-bound for "File_Control_Cmd:req_id"
	if ( (t_dataptr_after_time_create + 14) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("File_Control_Cmd:req_id",
			(((t_dataptr_after_time_create + 14) - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "permission"
	permission_ = FixByteOrder(byteorder(), *((uint16 const *) (t_dataptr_after_time_create)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "auth_key"
	auth_key_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_dataptr_after_time_create + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "file_size"
	file_size_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_dataptr_after_time_create + 6))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "op_mode"
	op_mode_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_dataptr_after_time_create + 10))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "max_block_size"
	max_block_size_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_dataptr_after_time_create + 12))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "req_id"
	req_id_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_dataptr_after_time_create + 14))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "file_name"
	int t_file_name__size;
	t_file_name__size = name_size();
	// Checking out-of-bound for "File_Control_Cmd:file_name"
	if ( (t_dataptr_after_time_create + 16) + (t_file_name__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("File_Control_Cmd:file_name",
			(((t_dataptr_after_time_create + 16) - t_begin_of_data)) + (t_file_name__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_dataptr_after_time_create + 16) + t_file_name__size;
	int t_file_name_string_length;
	t_file_name_string_length = name_size();
	// check for negative sizes
	if ( t_file_name_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-objects.pac:1243", t_file_name_string_length);
	file_name_.init((t_dataptr_after_time_create + 16), t_file_name_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_File_Control_Cmd__size;
	const_byteptr const t_dataptr_after_file_name = (t_dataptr_after_time_create + 16) + (t_file_name__size);
	BINPAC_ASSERT(t_dataptr_after_file_name <= t_end_of_data);
	t_File_Control_Cmd__size = t_dataptr_after_file_name - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_File_Control_Cmd__size) <= t_end_of_data);
	return t_File_Control_Cmd__size;
	}

File_Control_Cmd_Status_Wrap::File_Control_Cmd_Status_Wrap(uint8 function_code, uint32 obj_size)
	{
	data_obj_case_index_ = -1;
	abort_ = 0;
	fc_cmd_status_ = 0;
	function_code_ = function_code;
	obj_size_ = obj_size;
	}

File_Control_Cmd_Status_Wrap::~File_Control_Cmd_Status_Wrap()
	{
	switch ( data_obj_case_index() )
		{
		case 30:
			// Clean up "abort"
			{
			delete abort_;
			abort_ = 0;
			}
			break;
		case 129:
			// Clean up "fc_cmd_status"
			{
			delete fc_cmd_status_;
			fc_cmd_status_ = 0;
			}
			break;
		default:
			// Clean up "null"
			{
			}
			break;
		}
	}

int File_Control_Cmd_Status_Wrap::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "data_obj"
	int t_data_obj__size;
	data_obj_case_index_ =  ( function_code() ) ;
	switch ( data_obj_case_index() )
		{
		case 30:
			// Parse "abort"
			{
			abort_ = new File_Control_Cmd_Status(obj_size());
			int t_abort__size;
			t_abort__size = abort_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data_obj__size = t_abort__size;
			}
			break;
		case 129:
			// Parse "fc_cmd_status"
			{
			fc_cmd_status_ = new File_Control_Cmd_Status(obj_size());
			int t_fc_cmd_status__size;
			t_fc_cmd_status__size = fc_cmd_status_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data_obj__size = t_fc_cmd_status__size;
			}
			break;
		default:
			// Parse "null"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data_obj__size = 0;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_File_Control_Cmd_Status_Wrap__size;
	const_byteptr const t_dataptr_after_data_obj = t_begin_of_data + (t_data_obj__size);
	BINPAC_ASSERT(t_dataptr_after_data_obj <= t_end_of_data);
	t_File_Control_Cmd_Status_Wrap__size = t_dataptr_after_data_obj - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_File_Control_Cmd_Status_Wrap__size) <= t_end_of_data);
	return t_File_Control_Cmd_Status_Wrap__size;
	}

File_Control_Cmd_Status::File_Control_Cmd_Status(uint32 obj_size)
	{
	file_handle_ = 0;
	file_size_ = 0;
	max_block_size_ = 0;
	req_id_ = 0;
	status_code_ = 0;
	obj_size_ = obj_size;
	byteorder_ = littleendian;
	}

File_Control_Cmd_Status::~File_Control_Cmd_Status()
	{
	opt_text_.free();
	}

int File_Control_Cmd_Status::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "File_Control_Cmd_Status:status_code"
	if ( (t_begin_of_data + 12) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("File_Control_Cmd_Status:status_code",
			(12) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "file_handle"
	file_handle_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "file_size"
	file_size_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "max_block_size"
	max_block_size_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 8))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "req_id"
	req_id_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 10))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "status_code"
	status_code_ = *((uint8 const *) ((t_begin_of_data + 12)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "opt_text"
	int t_opt_text__size;
	t_opt_text__size =  ( obj_size() - 8 - 4 - 1 ) ;
	// Checking out-of-bound for "File_Control_Cmd_Status:opt_text"
	if ( (t_begin_of_data + 13) + (t_opt_text__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("File_Control_Cmd_Status:opt_text",
			(13) + (t_opt_text__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 13) + t_opt_text__size;
	int t_opt_text_string_length;
	t_opt_text_string_length =  ( obj_size() - 8 - 4 - 1 ) ;
	// check for negative sizes
	if ( t_opt_text_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-objects.pac:1262", t_opt_text_string_length);
	opt_text_.init((t_begin_of_data + 13), t_opt_text_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_File_Control_Cmd_Status__size;
	const_byteptr const t_dataptr_after_opt_text = (t_begin_of_data + 13) + (t_opt_text__size);
	BINPAC_ASSERT(t_dataptr_after_opt_text <= t_end_of_data);
	t_File_Control_Cmd_Status__size = t_dataptr_after_opt_text - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_File_Control_Cmd_Status__size) <= t_end_of_data);
	return t_File_Control_Cmd_Status__size;
	}

File_Transport::File_Transport(uint32 obj_size)
	{
	file_handle_ = 0;
	block_num_ = 0;
	obj_size_ = obj_size;
	byteorder_ = littleendian;
	result_ = 0;
	}

File_Transport::~File_Transport()
	{
	file_data_.free();
	}

int File_Transport::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNP3 * t_context)
	{
	// Checking out-of-bound for "File_Transport:block_num"
	if ( (t_begin_of_data + 4) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("File_Transport:block_num",
			(4) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "file_handle"
	file_handle_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "block_num"
	block_num_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "file_data"
	int t_file_data__size;
	t_file_data__size =  ( obj_size() - 8 ) ;
	// Checking out-of-bound for "File_Transport:file_data"
	if ( (t_begin_of_data + 8) + (t_file_data__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("File_Transport:file_data",
			(8) + (t_file_data__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 8) + t_file_data__size;
	int t_file_data_string_length;
	t_file_data_string_length =  ( obj_size() - 8 ) ;
	// check for negative sizes
	if ( t_file_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-objects.pac:1270", t_file_data_string_length);
	file_data_.init((t_begin_of_data + 8), t_file_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_File_Transport__size;
	const_byteptr const t_dataptr_after_file_data = (t_begin_of_data + 8) + (t_file_data__size);
	BINPAC_ASSERT(t_dataptr_after_file_data <= t_end_of_data);
	t_File_Transport__size = t_dataptr_after_file_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	result_ = t_context->flow()->get_dnp3_file_transport(file_handle(), block_num(), file_data());
	BINPAC_ASSERT(t_begin_of_data + (t_File_Transport__size) <= t_end_of_data);
	return t_File_Transport__size;
	}

File_Transport_Status::File_Transport_Status(uint32 obj_size)
	{
	file_handle_ = 0;
	block_num_ = 0;
	status_ = 0;
	obj_size_ = obj_size;
	byteorder_ = littleendian;
	}

File_Transport_Status::~File_Transport_Status()
	{
	opt_text_.free();
	}

int File_Transport_Status::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "File_Transport_Status:status"
	if ( (t_begin_of_data + 8) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("File_Transport_Status:status",
			(8) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "file_handle"
	file_handle_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "block_num"
	block_num_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "status"
	status_ = *((uint8 const *) ((t_begin_of_data + 8)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "opt_text"
	int t_opt_text__size;
	t_opt_text__size =  ( obj_size() - 4 - 4 - 1 ) ;
	// Checking out-of-bound for "File_Transport_Status:opt_text"
	if ( (t_begin_of_data + 9) + (t_opt_text__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("File_Transport_Status:opt_text",
			(9) + (t_opt_text__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 9) + t_opt_text__size;
	int t_opt_text_string_length;
	t_opt_text_string_length =  ( obj_size() - 4 - 4 - 1 ) ;
	// check for negative sizes
	if ( t_opt_text_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-objects.pac:1279", t_opt_text_string_length);
	opt_text_.init((t_begin_of_data + 9), t_opt_text_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_File_Transport_Status__size;
	const_byteptr const t_dataptr_after_opt_text = (t_begin_of_data + 9) + (t_opt_text__size);
	BINPAC_ASSERT(t_dataptr_after_opt_text <= t_end_of_data);
	t_File_Transport_Status__size = t_dataptr_after_opt_text - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_File_Transport_Status__size) <= t_end_of_data);
	return t_File_Transport_Status__size;
	}

File_Desc_Wrap::File_Desc_Wrap(uint8 function_code)
	{
	data_case_index_ = -1;
	get_file_info_ = 0;
	function_code_ = function_code;
	byteorder_ = littleendian;
	}

File_Desc_Wrap::~File_Desc_Wrap()
	{
	switch ( data_case_index() )
		{
		case 28:
			// Clean up "get_file_info"
			{
			delete get_file_info_;
			get_file_info_ = 0;
			}
			break;
		default:
			// Clean up "null"
			{
			}
			break;
		}
	}

int File_Desc_Wrap::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "data"
	int t_data__size;
	data_case_index_ =  ( function_code() ) ;
	switch ( data_case_index() )
		{
		case 28:
			// Parse "get_file_info"
			{
			get_file_info_ = new File_Desc();
			int t_get_file_info__size;
			t_get_file_info__size = get_file_info_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_get_file_info__size;
			}
			break;
		default:
			// Parse "null"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_File_Desc_Wrap__size;
	const_byteptr const t_dataptr_after_data = t_begin_of_data + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_File_Desc_Wrap__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_File_Desc_Wrap__size) <= t_end_of_data);
	return t_File_Desc_Wrap__size;
	}

File_Desc::File_Desc()
	{
	name_offset_ = 0;
	name_size_ = 0;
	type_ = 0;
	f_size_ = 0;
	time_create_low_ = 0;
	time_create_high_ = 0;
	permission_ = 0;
	req_id_ = 0;
	byteorder_ = littleendian;
	}

File_Desc::~File_Desc()
	{
	f_name_.free();
	}

int File_Desc::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "File_Desc:req_id"
	if ( (t_begin_of_data + 18) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("File_Desc:req_id",
			(18) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "name_offset"
	name_offset_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "name_size"
	name_size_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "type"
	type_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "f_size"
	f_size_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 6))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time_create_low"
	time_create_low_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 10))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time_create_high"
	time_create_high_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 14))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "permission"
	permission_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 16))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "req_id"
	req_id_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 18))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "f_name"
	int t_f_name__size;
	t_f_name__size = name_size();
	// Checking out-of-bound for "File_Desc:f_name"
	if ( (t_begin_of_data + 20) + (t_f_name__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("File_Desc:f_name",
			(20) + (t_f_name__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 20) + t_f_name__size;
	int t_f_name_string_length;
	t_f_name_string_length = name_size();
	// check for negative sizes
	if ( t_f_name_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-objects.pac:1303", t_f_name_string_length);
	f_name_.init((t_begin_of_data + 20), t_f_name_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_File_Desc__size;
	const_byteptr const t_dataptr_after_f_name = (t_begin_of_data + 20) + (t_f_name__size);
	BINPAC_ASSERT(t_dataptr_after_f_name <= t_end_of_data);
	t_File_Desc__size = t_dataptr_after_f_name - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_File_Desc__size) <= t_end_of_data);
	return t_File_Desc__size;
	}

File_Spec_Str::File_Spec_Str()
	{
	byteorder_ = littleendian;
	}

File_Spec_Str::~File_Spec_Str()
	{
	f_spec_.free();
	}

int File_Spec_Str::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "f_spec"
	int t_f_spec_string_length;
	t_f_spec_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_f_spec__size;
	t_f_spec__size = t_f_spec_string_length;
	// check for negative sizes
	if ( t_f_spec_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-objects.pac:1308", t_f_spec_string_length);
	f_spec_.init(t_begin_of_data, t_f_spec_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_File_Spec_Str__size;
	const_byteptr const t_dataptr_after_f_spec = t_begin_of_data + (t_f_spec__size);
	BINPAC_ASSERT(t_dataptr_after_f_spec <= t_end_of_data);
	t_File_Spec_Str__size = t_dataptr_after_f_spec - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_File_Spec_Str__size) <= t_end_of_data);
	return t_File_Spec_Str__size;
	}

Dev_Store::Dev_Store()
	{
	overflow_ = 0;
	obj_group_ = 0;
	variatiion_ = 0;
	byteorder_ = littleendian;
	}

Dev_Store::~Dev_Store()
	{
	}

int Dev_Store::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Dev_Store"
	if ( t_begin_of_data + (3) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Dev_Store",
			(0) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "overflow"
	overflow_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "obj_group"
	obj_group_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "variatiion"
	variatiion_ = *((uint8 const *) ((t_begin_of_data + 2)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (3) <= t_end_of_data);
	return 3;
	}

Dev_Profile::Dev_Profile()
	{
	fc_support_low_ = 0;
	fc_support_high_ = 0;
	count_ = 0;
	dev_headers_ = 0;
	dev_headers__elem_ = 0;
	byteorder_ = littleendian;
	}

Dev_Profile::~Dev_Profile()
	{
	delete dev_headers__elem_;
	dev_headers__elem_ = 0;
	if ( dev_headers() )
		{
		for ( int i = 0; i < (int) dev_headers()->size(); ++i )
			{
			Dev_Profile_OH * dev_headers__elem_ = (*dev_headers_)[i];
			delete dev_headers__elem_;
			dev_headers__elem_ = 0;
			}
		}
	delete dev_headers_;
	}

int Dev_Profile::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Dev_Profile:count"
	if ( (t_begin_of_data + 8) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Dev_Profile:count",
			(8) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "fc_support_low"
	fc_support_low_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "fc_support_high"
	fc_support_high_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "count"
	count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 8))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "dev_headers"
	int t_dev_headers__arraylength;
	t_dev_headers__arraylength = 0;
	t_dev_headers__arraylength = count();
	if ( t_begin_of_data + t_dev_headers__arraylength > t_end_of_data + 1 )
		{
		t_dev_headers__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_dev_headers__arraylength < 0 )
		{
		t_dev_headers__arraylength = 0;
		}
	dev_headers__elem_ = 0;
	int t_dev_headers__elem__it;
	t_dev_headers__elem__it = 0;
	int t_dev_headers__size;
	dev_headers_ = new vector<Dev_Profile_OH *>;
	dev_headers_->reserve(t_dev_headers__arraylength);
	const_byteptr t_dev_headers__elem__dataptr = (t_begin_of_data + 10);
	for (; t_dev_headers__elem__it < t_dev_headers__arraylength; ++t_dev_headers__elem__it)
		{
		// Check &until(dev_headers__elem__dataptr >= end_of_data)
		if ( t_dev_headers__elem__dataptr >= t_end_of_data )
			{
			dev_headers__elem_ = 0;
			goto end_of_dev_headers;
			}
		dev_headers__elem_ = new Dev_Profile_OH();
		dev_headers__elem_->Parse(t_dev_headers__elem__dataptr, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		dev_headers_->push_back(dev_headers__elem_);
		t_dev_headers__elem__dataptr += 4;
		BINPAC_ASSERT(t_dev_headers__elem__dataptr <= t_end_of_data);
		dev_headers__elem_ = 0;
		}
end_of_dev_headers: ;
	t_dev_headers__size = t_dev_headers__elem__dataptr - ((t_begin_of_data + 10));
	// Evaluate 'let' and 'withinput' fields
	
	int t_Dev_Profile__size;
	const_byteptr const t_dataptr_after_dev_headers = (t_begin_of_data + 10) + (t_dev_headers__size);
	BINPAC_ASSERT(t_dataptr_after_dev_headers <= t_end_of_data);
	t_Dev_Profile__size = t_dataptr_after_dev_headers - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Dev_Profile__size) <= t_end_of_data);
	return t_Dev_Profile__size;
	}

Dev_Profile_OH::Dev_Profile_OH()
	{
	group_ = 0;
	variation_ = 0;
	qualifier_ = 0;
	range_ = 0;
	byteorder_ = littleendian;
	}

Dev_Profile_OH::~Dev_Profile_OH()
	{
	}

int Dev_Profile_OH::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Dev_Profile_OH"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Dev_Profile_OH",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "group"
	group_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "variation"
	variation_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "qualifier"
	qualifier_ = *((uint8 const *) ((t_begin_of_data + 2)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "range"
	range_ = *((uint8 const *) ((t_begin_of_data + 3)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

PrivRegObj::PrivRegObj()
	{
	vendor_ = 0;
	obj_id_ = 0;
	len_ = 0;
	byteorder_ = littleendian;
	}

PrivRegObj::~PrivRegObj()
	{
	data_objs_.free();
	}

int PrivRegObj::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "PrivRegObj:len"
	if ( (t_begin_of_data + 6) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("PrivRegObj:len",
			(6) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "vendor"
	vendor_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "obj_id"
	obj_id_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "len"
	len_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 6))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data_objs"
	int t_data_objs__size;
	t_data_objs__size = len();
	// Checking out-of-bound for "PrivRegObj:data_objs"
	if ( (t_begin_of_data + 8) + (t_data_objs__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("PrivRegObj:data_objs",
			(8) + (t_data_objs__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 8) + t_data_objs__size;
	int t_data_objs_string_length;
	t_data_objs_string_length = len();
	// check for negative sizes
	if ( t_data_objs_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-objects.pac:1342", t_data_objs_string_length);
	data_objs_.init((t_begin_of_data + 8), t_data_objs_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_PrivRegObj__size;
	const_byteptr const t_dataptr_after_data_objs = (t_begin_of_data + 8) + (t_data_objs__size);
	BINPAC_ASSERT(t_dataptr_after_data_objs <= t_end_of_data);
	t_PrivRegObj__size = t_dataptr_after_data_objs - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_PrivRegObj__size) <= t_end_of_data);
	return t_PrivRegObj__size;
	}

PrivRegObjDesc::PrivRegObjDesc()
	{
	vendor_ = 0;
	obj_id_ = 0;
	count_ = 0;
	data_objs_ = 0;
	data_objs__elem_ = 0;
	byteorder_ = littleendian;
	}

PrivRegObjDesc::~PrivRegObjDesc()
	{
	delete data_objs__elem_;
	data_objs__elem_ = 0;
	if ( data_objs() )
		{
		for ( int i = 0; i < (int) data_objs()->size(); ++i )
			{
			ObjDescSpec * data_objs__elem_ = (*data_objs_)[i];
			delete data_objs__elem_;
			data_objs__elem_ = 0;
			}
		}
	delete data_objs_;
	}

int PrivRegObjDesc::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "PrivRegObjDesc:count"
	if ( (t_begin_of_data + 6) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("PrivRegObjDesc:count",
			(6) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "vendor"
	vendor_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "obj_id"
	obj_id_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "count"
	count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 6))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data_objs"
	int t_data_objs__arraylength;
	t_data_objs__arraylength = 0;
	t_data_objs__arraylength = count();
	if ( t_begin_of_data + t_data_objs__arraylength > t_end_of_data + 1 )
		{
		t_data_objs__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_data_objs__arraylength < 0 )
		{
		t_data_objs__arraylength = 0;
		}
	data_objs__elem_ = 0;
	int t_data_objs__elem__it;
	t_data_objs__elem__it = 0;
	int t_data_objs__size;
	data_objs_ = new vector<ObjDescSpec *>;
	data_objs_->reserve(t_data_objs__arraylength);
	const_byteptr t_data_objs__elem__dataptr = (t_begin_of_data + 8);
	for (; t_data_objs__elem__it < t_data_objs__arraylength; ++t_data_objs__elem__it)
		{
		// Check &until(data_objs__elem__dataptr >= end_of_data)
		if ( t_data_objs__elem__dataptr >= t_end_of_data )
			{
			data_objs__elem_ = 0;
			goto end_of_data_objs;
			}
		data_objs__elem_ = new ObjDescSpec();
		data_objs__elem_->Parse(t_data_objs__elem__dataptr, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		data_objs_->push_back(data_objs__elem_);
		t_data_objs__elem__dataptr += 4;
		BINPAC_ASSERT(t_data_objs__elem__dataptr <= t_end_of_data);
		data_objs__elem_ = 0;
		}
end_of_data_objs: ;
	t_data_objs__size = t_data_objs__elem__dataptr - ((t_begin_of_data + 8));
	// Evaluate 'let' and 'withinput' fields
	
	int t_PrivRegObjDesc__size;
	const_byteptr const t_dataptr_after_data_objs = (t_begin_of_data + 8) + (t_data_objs__size);
	BINPAC_ASSERT(t_dataptr_after_data_objs <= t_end_of_data);
	t_PrivRegObjDesc__size = t_dataptr_after_data_objs - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_PrivRegObjDesc__size) <= t_end_of_data);
	return t_PrivRegObjDesc__size;
	}

ObjDescSpec::ObjDescSpec()
	{
	obj_quantity_ = 0;
	obj_group_ = 0;
	obj_variation_ = 0;
	byteorder_ = littleendian;
	}

ObjDescSpec::~ObjDescSpec()
	{
	}

int ObjDescSpec::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "ObjDescSpec"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ObjDescSpec",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "obj_quantity"
	obj_quantity_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "obj_group"
	obj_group_ = *((uint8 const *) ((t_begin_of_data + 2)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "obj_variation"
	obj_variation_ = *((uint8 const *) ((t_begin_of_data + 3)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

DescEle::DescEle()
	{
	len_ = 0;
	desc_code_ = 0;
	data_type_ = 0;
	max_len_ = 0;
	ancillary_ = 0;
	byteorder_ = littleendian;
	}

DescEle::~DescEle()
	{
	}

int DescEle::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "DescEle"
	if ( t_begin_of_data + (5) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DescEle",
			(0) + (5), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "len"
	len_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "desc_code"
	desc_code_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data_type"
	data_type_ = *((uint8 const *) ((t_begin_of_data + 2)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "max_len"
	max_len_ = *((uint8 const *) ((t_begin_of_data + 3)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "ancillary"
	ancillary_ = *((uint8 const *) ((t_begin_of_data + 4)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (5) <= t_end_of_data);
	return 5;
	}

App_Id::App_Id(uint8 qualifier_field, uint16 object_size16)
	{
	app_id_case_index_ = -1;
	qualifier_field_ = qualifier_field;
	object_size16_ = object_size16;
	byteorder_ = littleendian;
	}

App_Id::~App_Id()
	{
	switch ( app_id_case_index() )
		{
		case 91:
			// Clean up "app_name"
			{
			app_name_.free();
			}
			break;
		case 6:
			// Clean up "all_app"
			{
			}
			break;
		default:
			// Clean up "illegal"
			{
			}
			break;
		}
	}

int App_Id::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "app_id"
	int t_app_id__size;
	app_id_case_index_ =  ( qualifier_field() ) ;
	switch ( app_id_case_index() )
		{
		case 91:
			// Parse "app_name"
			{
			int t_app_name__size;
			t_app_name__size = object_size16();
			// Checking out-of-bound for "App_Id:app_name"
			if ( t_begin_of_data + (t_app_name__size) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("App_Id:app_name",
					(0) + (t_app_name__size), 
					(t_end_of_data) - (t_begin_of_data));
				}
			{
			// Setting t_end_of_data with &length
			const_byteptr t_end_of_data = t_begin_of_data + t_app_name__size;
			int t_app_name_string_length;
			t_app_name_string_length = object_size16();
			// check for negative sizes
			if ( t_app_name_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-objects.pac:1383", t_app_name_string_length);
			app_name_.init(t_begin_of_data, t_app_name_string_length);
			// Evaluate 'let' and 'withinput' fields
			}
			t_app_id__size = t_app_name__size;
			}
			break;
		case 6:
			// Parse "all_app"
			{
			// Evaluate 'let' and 'withinput' fields
			t_app_id__size = 0;
			}
			break;
		default:
			// Parse "illegal"
			{
			// Evaluate 'let' and 'withinput' fields
			t_app_id__size = 0;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_App_Id__size;
	const_byteptr const t_dataptr_after_app_id = t_begin_of_data + (t_app_id__size);
	BINPAC_ASSERT(t_dataptr_after_app_id <= t_end_of_data);
	t_App_Id__size = t_dataptr_after_app_id - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_App_Id__size) <= t_end_of_data);
	return t_App_Id__size;
	}

ActivateConf::ActivateConf()
	{
	time_delay_ = 0;
	count_ = 0;
	elements_ = 0;
	elements__elem_ = 0;
	byteorder_ = littleendian;
	}

ActivateConf::~ActivateConf()
	{
	delete elements__elem_;
	elements__elem_ = 0;
	if ( elements() )
		{
		for ( int i = 0; i < (int) elements()->size(); ++i )
			{
			StatusEle * elements__elem_ = (*elements_)[i];
			delete elements__elem_;
			elements__elem_ = 0;
			}
		}
	delete elements_;
	}

int ActivateConf::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "ActivateConf:count"
	if ( (t_begin_of_data + 4) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ActivateConf:count",
			(4) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "time_delay"
	time_delay_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "count"
	count_ = *((uint8 const *) ((t_begin_of_data + 4)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "elements"
	int t_elements__arraylength;
	t_elements__arraylength = 0;
	t_elements__arraylength = count();
	if ( t_begin_of_data + t_elements__arraylength > t_end_of_data + 1 )
		{
		t_elements__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_elements__arraylength < 0 )
		{
		t_elements__arraylength = 0;
		}
	elements__elem_ = 0;
	int t_elements__elem__it;
	t_elements__elem__it = 0;
	int t_elements__size;
	elements_ = new vector<StatusEle *>;
	elements_->reserve(t_elements__arraylength);
	const_byteptr t_elements__elem__dataptr = (t_begin_of_data + 5);
	for (; t_elements__elem__it < t_elements__arraylength; ++t_elements__elem__it)
		{
		// Check &until(elements__elem__dataptr >= end_of_data)
		if ( t_elements__elem__dataptr >= t_end_of_data )
			{
			elements__elem_ = 0;
			goto end_of_elements;
			}
		elements__elem_ = new StatusEle();
		int t_elements__elem__size;
		t_elements__elem__size = elements__elem_->Parse(t_elements__elem__dataptr, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		elements_->push_back(elements__elem_);
		t_elements__elem__dataptr += t_elements__elem__size;
		BINPAC_ASSERT(t_elements__elem__dataptr <= t_end_of_data);
		elements__elem_ = 0;
		}
end_of_elements: ;
	t_elements__size = t_elements__elem__dataptr - ((t_begin_of_data + 5));
	// Evaluate 'let' and 'withinput' fields
	
	int t_ActivateConf__size;
	const_byteptr const t_dataptr_after_elements = (t_begin_of_data + 5) + (t_elements__size);
	BINPAC_ASSERT(t_dataptr_after_elements <= t_end_of_data);
	t_ActivateConf__size = t_dataptr_after_elements - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ActivateConf__size) <= t_end_of_data);
	return t_ActivateConf__size;
	}

StatusEle::StatusEle()
	{
	len_ = 0;
	status_code_ = 0;
	byteorder_ = littleendian;
	}

StatusEle::~StatusEle()
	{
	ancillary_.free();
	}

int StatusEle::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "StatusEle:status_code"
	if ( (t_begin_of_data + 1) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("StatusEle:status_code",
			(1) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "len"
	len_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "status_code"
	status_code_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "ancillary"
	int t_ancillary__size;
	t_ancillary__size =  ( len() - 1 ) ;
	// Checking out-of-bound for "StatusEle:ancillary"
	if ( (t_begin_of_data + 2) + (t_ancillary__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("StatusEle:ancillary",
			(2) + (t_ancillary__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 2) + t_ancillary__size;
	int t_ancillary_string_length;
	t_ancillary_string_length =  ( len() - 1 ) ;
	// check for negative sizes
	if ( t_ancillary_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-objects.pac:1399", t_ancillary_string_length);
	ancillary_.init((t_begin_of_data + 2), t_ancillary_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_StatusEle__size;
	const_byteptr const t_dataptr_after_ancillary = (t_begin_of_data + 2) + (t_ancillary__size);
	BINPAC_ASSERT(t_dataptr_after_ancillary <= t_end_of_data);
	t_StatusEle__size = t_dataptr_after_ancillary - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_StatusEle__size) <= t_end_of_data);
	return t_StatusEle__size;
	}

BCD_Large::BCD_Large()
	{
	value_low_ = 0;
	vlaue_high_ = 0;
	byteorder_ = littleendian;
	}

BCD_Large::~BCD_Large()
	{
	}

int BCD_Large::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "BCD_Large"
	if ( t_begin_of_data + (8) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("BCD_Large",
			(0) + (8), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "value_low"
	value_low_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "vlaue_high"
	vlaue_high_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (8) <= t_end_of_data);
	return 8;
	}

AuthChallenge::AuthChallenge(uint16 prefix)
	{
	csqUsr_ = 0;
	hal_ = 0;
	reason_ = 0;
	prefix_ = prefix;
	byteorder_ = littleendian;
	}

AuthChallenge::~AuthChallenge()
	{
	chan_data_.free();
	}

int AuthChallenge::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "AuthChallenge:reason"
	if ( (t_begin_of_data + 5) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AuthChallenge:reason",
			(5) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "csqUsr"
	csqUsr_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "hal"
	hal_ = *((uint8 const *) ((t_begin_of_data + 4)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "reason"
	reason_ = *((uint8 const *) ((t_begin_of_data + 5)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "chan_data"
	int t_chan_data__size;
	t_chan_data__size =  ( prefix() - 10 ) ;
	// Checking out-of-bound for "AuthChallenge:chan_data"
	if ( (t_begin_of_data + 6) + (t_chan_data__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AuthChallenge:chan_data",
			(6) + (t_chan_data__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 6) + t_chan_data__size;
	int t_chan_data_string_length;
	t_chan_data_string_length =  ( prefix() - 10 ) ;
	// check for negative sizes
	if ( t_chan_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-objects.pac:1417", t_chan_data_string_length);
	chan_data_.init((t_begin_of_data + 6), t_chan_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_AuthChallenge__size;
	const_byteptr const t_dataptr_after_chan_data = (t_begin_of_data + 6) + (t_chan_data__size);
	BINPAC_ASSERT(t_dataptr_after_chan_data <= t_end_of_data);
	t_AuthChallenge__size = t_dataptr_after_chan_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_AuthChallenge__size) <= t_end_of_data);
	return t_AuthChallenge__size;
	}

AuthRely::AuthRely(uint16 prefix)
	{
	csqUsr_ = 0;
	prefix_ = prefix;
	byteorder_ = littleendian;
	}

AuthRely::~AuthRely()
	{
	chan_data_.free();
	}

int AuthRely::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "AuthRely:csqUsr"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AuthRely:csqUsr",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "csqUsr"
	csqUsr_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "chan_data"
	int t_chan_data__size;
	t_chan_data__size =  ( prefix() - 4 ) ;
	// Checking out-of-bound for "AuthRely:chan_data"
	if ( (t_begin_of_data + 4) + (t_chan_data__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AuthRely:chan_data",
			(4) + (t_chan_data__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 4) + t_chan_data__size;
	int t_chan_data_string_length;
	t_chan_data_string_length =  ( prefix() - 4 ) ;
	// check for negative sizes
	if ( t_chan_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-objects.pac:1423", t_chan_data_string_length);
	chan_data_.init((t_begin_of_data + 4), t_chan_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_AuthRely__size;
	const_byteptr const t_dataptr_after_chan_data = (t_begin_of_data + 4) + (t_chan_data__size);
	BINPAC_ASSERT(t_dataptr_after_chan_data <= t_end_of_data);
	t_AuthRely__size = t_dataptr_after_chan_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_AuthRely__size) <= t_end_of_data);
	return t_AuthRely__size;
	}

AuthAggrRequest::AuthAggrRequest(uint16 prefix)
	{
	csqUsr_ = 0;
	prefix_ = prefix;
	byteorder_ = littleendian;
	}

AuthAggrRequest::~AuthAggrRequest()
	{
	chan_data_.free();
	}

int AuthAggrRequest::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "AuthAggrRequest:csqUsr"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AuthAggrRequest:csqUsr",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "csqUsr"
	csqUsr_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "chan_data"
	int t_chan_data__size;
	t_chan_data__size =  ( prefix() - 4 ) ;
	// Checking out-of-bound for "AuthAggrRequest:chan_data"
	if ( (t_begin_of_data + 4) + (t_chan_data__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AuthAggrRequest:chan_data",
			(4) + (t_chan_data__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 4) + t_chan_data__size;
	int t_chan_data_string_length;
	t_chan_data_string_length =  ( prefix() - 4 ) ;
	// check for negative sizes
	if ( t_chan_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-objects.pac:1429", t_chan_data_string_length);
	chan_data_.init((t_begin_of_data + 4), t_chan_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_AuthAggrRequest__size;
	const_byteptr const t_dataptr_after_chan_data = (t_begin_of_data + 4) + (t_chan_data__size);
	BINPAC_ASSERT(t_dataptr_after_chan_data <= t_end_of_data);
	t_AuthAggrRequest__size = t_dataptr_after_chan_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_AuthAggrRequest__size) <= t_end_of_data);
	return t_AuthAggrRequest__size;
	}

AuthSessionKeyStatus::AuthSessionKeyStatus(uint16 prefix)
	{
	csqUsr_ = 0;
	key_alg_ = 0;
	key_status_ = 0;
	prefix_ = prefix;
	byteorder_ = littleendian;
	}

AuthSessionKeyStatus::~AuthSessionKeyStatus()
	{
	chan_data_.free();
	}

int AuthSessionKeyStatus::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "AuthSessionKeyStatus:key_status"
	if ( (t_begin_of_data + 5) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AuthSessionKeyStatus:key_status",
			(5) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "csqUsr"
	csqUsr_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "key_alg"
	key_alg_ = *((uint8 const *) ((t_begin_of_data + 4)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "key_status"
	key_status_ = *((uint8 const *) ((t_begin_of_data + 5)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "chan_data"
	int t_chan_data__size;
	t_chan_data__size =  ( prefix() - 10 ) ;
	// Checking out-of-bound for "AuthSessionKeyStatus:chan_data"
	if ( (t_begin_of_data + 6) + (t_chan_data__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AuthSessionKeyStatus:chan_data",
			(6) + (t_chan_data__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 6) + t_chan_data__size;
	int t_chan_data_string_length;
	t_chan_data_string_length =  ( prefix() - 10 ) ;
	// check for negative sizes
	if ( t_chan_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-objects.pac:1437", t_chan_data_string_length);
	chan_data_.init((t_begin_of_data + 6), t_chan_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_AuthSessionKeyStatus__size;
	const_byteptr const t_dataptr_after_chan_data = (t_begin_of_data + 6) + (t_chan_data__size);
	BINPAC_ASSERT(t_dataptr_after_chan_data <= t_end_of_data);
	t_AuthSessionKeyStatus__size = t_dataptr_after_chan_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_AuthSessionKeyStatus__size) <= t_end_of_data);
	return t_AuthSessionKeyStatus__size;
	}

AuthSessionKeyChange::AuthSessionKeyChange(uint16 prefix)
	{
	csqUsr_ = 0;
	prefix_ = prefix;
	byteorder_ = littleendian;
	}

AuthSessionKeyChange::~AuthSessionKeyChange()
	{
	key_wrap_data_.free();
	}

int AuthSessionKeyChange::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "AuthSessionKeyChange:csqUsr"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AuthSessionKeyChange:csqUsr",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "csqUsr"
	csqUsr_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "key_wrap_data"
	int t_key_wrap_data__size;
	t_key_wrap_data__size =  ( prefix() - 5 ) ;
	// Checking out-of-bound for "AuthSessionKeyChange:key_wrap_data"
	if ( (t_begin_of_data + 4) + (t_key_wrap_data__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AuthSessionKeyChange:key_wrap_data",
			(4) + (t_key_wrap_data__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 4) + t_key_wrap_data__size;
	int t_key_wrap_data_string_length;
	t_key_wrap_data_string_length =  ( prefix() - 5 ) ;
	// check for negative sizes
	if ( t_key_wrap_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-objects.pac:1443", t_key_wrap_data_string_length);
	key_wrap_data_.init((t_begin_of_data + 4), t_key_wrap_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_AuthSessionKeyChange__size;
	const_byteptr const t_dataptr_after_key_wrap_data = (t_begin_of_data + 4) + (t_key_wrap_data__size);
	BINPAC_ASSERT(t_dataptr_after_key_wrap_data <= t_end_of_data);
	t_AuthSessionKeyChange__size = t_dataptr_after_key_wrap_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_AuthSessionKeyChange__size) <= t_end_of_data);
	return t_AuthSessionKeyChange__size;
	}

AuthError::AuthError(uint16 prefix)
	{
	csqUsr_ = 0;
	error_code_ = 0;
	prefix_ = prefix;
	byteorder_ = littleendian;
	}

AuthError::~AuthError()
	{
	key_wrap_data_.free();
	}

int AuthError::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "AuthError:error_code"
	if ( (t_begin_of_data + 4) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AuthError:error_code",
			(4) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "csqUsr"
	csqUsr_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "error_code"
	error_code_ = *((uint8 const *) ((t_begin_of_data + 4)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "key_wrap_data"
	int t_key_wrap_data__size;
	t_key_wrap_data__size =  ( prefix() - 6 ) ;
	// Checking out-of-bound for "AuthError:key_wrap_data"
	if ( (t_begin_of_data + 5) + (t_key_wrap_data__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("AuthError:key_wrap_data",
			(5) + (t_key_wrap_data__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 5) + t_key_wrap_data__size;
	int t_key_wrap_data_string_length;
	t_key_wrap_data_string_length =  ( prefix() - 6 ) ;
	// check for negative sizes
	if ( t_key_wrap_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/dnp3-objects.pac:1450", t_key_wrap_data_string_length);
	key_wrap_data_.init((t_begin_of_data + 5), t_key_wrap_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_AuthError__size;
	const_byteptr const t_dataptr_after_key_wrap_data = (t_begin_of_data + 5) + (t_key_wrap_data__size);
	BINPAC_ASSERT(t_dataptr_after_key_wrap_data <= t_end_of_data);
	t_AuthError__size = t_dataptr_after_key_wrap_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_AuthError__size) <= t_end_of_data);
	return t_AuthError__size;
	}

DNP3_Conn::DNP3_Conn(BroAnalyzer const & bro_analyzer)
	{
	upflow_ = new DNP3_Flow(this, true);
	downflow_ = new DNP3_Flow(this, false);
	bro_analyzer_ = bro_analyzer;
	}

DNP3_Conn::~DNP3_Conn()
	{
	delete upflow_;
	upflow_ = 0;
	delete downflow_;
	downflow_ = 0;
	}

void DNP3_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void DNP3_Conn::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void DNP3_Conn::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

DNP3_Flow::DNP3_Flow(DNP3_Conn * connection, bool is_orig)
	{
	flow_buffer_ = 0;
	connection_ = connection;
	is_orig_ = is_orig;
	dataunit_ = 0;
	context_ = 0;
	flow_buffer_ = new FlowBuffer();
	}

DNP3_Flow::~DNP3_Flow()
	{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;
	delete flow_buffer_;
	flow_buffer_ = 0;
	}

void DNP3_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		flow_buffer_->NewData(t_begin_of_data, t_end_of_data);
		while ( flow_buffer_->data_available() && 
			( !flow_buffer_->have_pending_request() || flow_buffer_->ready() ) )
			{
			if ( ! dataunit_ )
				{
				BINPAC_ASSERT(!context_);
				dataunit_ = new DNP3_PDU(is_orig());
				context_ = new ContextDNP3(connection(), this, flow_buffer());
				}
			bool t_dataunit_parsing_complete;
			t_dataunit_parsing_complete = false;
			t_dataunit_parsing_complete = dataunit_->ParseBuffer(flow_buffer(), context_);
			if ( t_dataunit_parsing_complete )
				{
				// Evaluate 'let' and 'withinput' fields
				}
			if ( t_dataunit_parsing_complete )
				{
				// Clean up the flow unit after parsing
				delete dataunit_;
				dataunit_ = 0;
				delete context_;
				context_ = 0;
				}
			else
				{
				// Resume upon next input segment
				BINPAC_ASSERT(!flow_buffer()->ready());
				break;
				}
			}
		}
	catch ( binpac::Exception const &e )
		{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		flow_buffer_->DiscardData();
		throw;
		}
	}

void DNP3_Flow::NewGap(int gap_length)
	{
	flow_buffer_->NewGap(gap_length);
	}
void DNP3_Flow::FlowEOF()
	{
	flow_buffer_->set_eof();
	NewData(0, 0);
	}
bool DNP3_Flow::get_dnp3_header_block(uint16 start, uint16 len, uint8 ctrl, uint16 dest_addr, uint16 src_addr)
	{

		if ( ::dnp3_header_block )
			{
			BifEvent::generate_dnp3_header_block(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), start, len, ctrl, dest_addr, src_addr);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_application_request_header(uint8 fc)
	{

		if ( ::dnp3_application_request_header )
			{
			BifEvent::generate_dnp3_application_request_header(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(),
				fc
				);
			}
		return true;
		
	}

bool DNP3_Flow::get_dnp3_application_response_header(uint8 fc, uint16 iin)
	{

		if ( ::dnp3_application_response_header )
			{
			BifEvent::generate_dnp3_application_response_header(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(),
				fc,
				iin
				);
			}
		return true;
		
	}

bool DNP3_Flow::get_dnp3_object_header(uint16 obj_type, uint8 qua_field, uint32 number, uint32 rf_low, uint32 rf_high)
	{

		if ( ::dnp3_object_header )
			{
			BifEvent::generate_dnp3_object_header(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), obj_type, qua_field, number, rf_low, rf_high);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_object_prefix(uint32 prefix_value)
	{

		if ( ::dnp3_object_prefix )
			{
			BifEvent::generate_dnp3_object_prefix(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), prefix_value);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_response_data_object(uint8 data_value)
	{

		if ( ::dnp3_response_data_object )
			{
			BifEvent::generate_dnp3_response_data_object(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), data_value);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_attribute_common(uint8 data_type_code, uint8 leng, const_bytestring const & attribute_obj)
	{

		if ( ::dnp3_attribute_common )
			{
			BifEvent::generate_dnp3_attribute_common(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), data_type_code, leng, bytestring_to_val(attribute_obj) );
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_crob(uint8 control_code, uint8 count8, uint32 on_time, uint32 off_time, uint8 status_code)
	{

		if ( ::dnp3_crob )
			{
			BifEvent::generate_dnp3_crob(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), control_code, count8, on_time, off_time, status_code);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_pcb(uint8 control_code, uint8 count8, uint32 on_time, uint32 off_time, uint8 status_code)
	{

		if ( ::dnp3_pcb )
			{
			BifEvent::generate_dnp3_pcb(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), control_code, count8, on_time, off_time, status_code);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_counter_32wFlag(uint8 flag, uint32 count_value)
	{

		if ( ::dnp3_counter_32wFlag )
			{
			BifEvent::generate_dnp3_counter_32wFlag(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, count_value);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_counter_16wFlag(uint8 flag, uint16 count_value)
	{

		if ( ::dnp3_counter_16wFlag )
			{
			BifEvent::generate_dnp3_counter_16wFlag(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, count_value);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_counter_32woFlag(uint32 count_value)
	{

		if ( ::dnp3_counter_32woFlag )
			{
			BifEvent::generate_dnp3_counter_32woFlag(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), count_value);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_counter_16woFlag(uint16 count_value)
	{

		if ( ::dnp3_counter_16woFlag )
			{
			BifEvent::generate_dnp3_counter_16woFlag(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), count_value);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_frozen_counter_32wFlag(uint8 flag, uint32 count_value)
	{

		if ( ::dnp3_frozen_counter_32wFlag )
			{
			BifEvent::generate_dnp3_frozen_counter_32wFlag(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, count_value);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_frozen_counter_16wFlag(uint8 flag, uint16 count_value)
	{

		if ( ::dnp3_frozen_counter_16wFlag )
			{
			BifEvent::generate_dnp3_frozen_counter_16wFlag(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, count_value);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_frozen_counter_32wFlagTime(uint8 flag, uint32 count_value, const_bytestring const & time48)
	{

		if ( ::dnp3_frozen_counter_32wFlagTime )
			{
			BifEvent::generate_dnp3_frozen_counter_32wFlagTime(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, count_value, bytestring_to_val(time48));
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_frozen_counter_16wFlagTime(uint8 flag, uint16 count_value, const_bytestring const & time48)
	{

		if ( ::dnp3_frozen_counter_16wFlagTime )
			{
			BifEvent::generate_dnp3_frozen_counter_16wFlagTime(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, count_value, bytestring_to_val(time48));
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_frozen_counter_32woFlag(uint32 count_value)
	{

		if ( ::dnp3_frozen_counter_32woFlag )
			{
			BifEvent::generate_dnp3_frozen_counter_32woFlag(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), count_value);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_frozen_counter_16woFlag(uint16 count_value)
	{

		if ( ::dnp3_frozen_counter_16woFlag )
			{
			BifEvent::generate_dnp3_frozen_counter_16woFlag(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), count_value);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_analog_input_32wFlag(uint8 flag, int32 value)
	{

		if ( ::dnp3_analog_input_32wFlag )
			{
			BifEvent::generate_dnp3_analog_input_32wFlag(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, value);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_analog_input_16wFlag(uint8 flag, int16 value)
	{

		if ( ::dnp3_analog_input_16wFlag )
			{
			BifEvent::generate_dnp3_analog_input_16wFlag(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, value);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_analog_input_32woFlag(int32 value)
	{

		if ( ::dnp3_analog_input_32woFlag )
			{
			BifEvent::generate_dnp3_analog_input_32woFlag(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), value);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_analog_input_16woFlag(int16 value)
	{

		if ( ::dnp3_analog_input_16woFlag )
			{
			BifEvent::generate_dnp3_analog_input_16woFlag(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), value);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_analog_input_SPwFlag(uint8 flag, uint32 value)
	{

		if ( ::dnp3_analog_input_SPwFlag )
			{
			BifEvent::generate_dnp3_analog_input_SPwFlag(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, value);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_analog_input_DPwFlag(uint8 flag, uint32 value_low, uint32 value_high)
	{

		if ( ::dnp3_analog_input_DPwFlag )
			{
			BifEvent::generate_dnp3_analog_input_DPwFlag(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, value_low, value_high);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_frozen_analog_input_32wFlag(uint8 flag, int32 frozen_value)
	{

		if ( ::dnp3_frozen_analog_input_32wFlag )
			{
			BifEvent::generate_dnp3_frozen_analog_input_32wFlag(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, frozen_value);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_frozen_analog_input_16wFlag(uint8 flag, int16 frozen_value)
	{

		if ( ::dnp3_frozen_analog_input_16wFlag )
			{
			BifEvent::generate_dnp3_frozen_analog_input_16wFlag(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, frozen_value);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_frozen_analog_input_32wTime(uint8 flag, int32 frozen_value, const_bytestring const & time48)
	{

		if ( ::dnp3_frozen_analog_input_32wTime )
			{
			BifEvent::generate_dnp3_frozen_analog_input_32wTime(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, frozen_value, bytestring_to_val(time48));
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_frozen_analog_input_16wTime(uint8 flag, int16 frozen_value, const_bytestring const & time48)
	{

		if ( ::dnp3_frozen_analog_input_16wTime )
			{
			BifEvent::generate_dnp3_frozen_analog_input_16wTime(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, frozen_value, bytestring_to_val(time48));
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_frozen_analog_input_32woFlag(int32 frozen_value)
	{

		if ( ::dnp3_frozen_analog_input_32woFlag )
			{
			BifEvent::generate_dnp3_frozen_analog_input_32woFlag(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), frozen_value);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_frozen_analog_input_16woFlag(int16 frozen_value)
	{

		if ( ::dnp3_frozen_analog_input_16woFlag )
			{
			BifEvent::generate_dnp3_frozen_analog_input_16woFlag(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), frozen_value);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_frozen_analog_input_SPwFlag(uint8 flag, uint32 frozen_value)
	{

		if ( ::dnp3_frozen_analog_input_SPwFlag )
			{
			BifEvent::generate_dnp3_frozen_analog_input_SPwFlag(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, frozen_value);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_frozen_analog_input_DPwFlag(uint8 flag, uint32 frozen_value_low, uint32 frozen_value_high)
	{

		if ( ::dnp3_frozen_analog_input_DPwFlag )
			{
			BifEvent::generate_dnp3_frozen_analog_input_DPwFlag(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, frozen_value_low, frozen_value_high);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_analog_input_event_32woTime(uint8 flag, int32 value)
	{

		if ( ::dnp3_analog_input_event_32woTime )
			{
			BifEvent::generate_dnp3_analog_input_event_32woTime(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, value);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_analog_input_event_16woTime(uint8 flag, int16 value)
	{

		if ( ::dnp3_analog_input_event_16woTime )
			{
			BifEvent::generate_dnp3_analog_input_event_16woTime(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, value);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_analog_input_event_32wTime(uint8 flag, int32 value, const_bytestring const & time48)
	{

		if ( ::dnp3_analog_input_event_32wTime )
			{
			BifEvent::generate_dnp3_analog_input_event_32wTime(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, value, bytestring_to_val(time48));
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_analog_input_event_16wTime(uint8 flag, int16 value, const_bytestring const & time48)
	{

		if ( ::dnp3_analog_input_event_16wTime )
			{
			BifEvent::generate_dnp3_analog_input_event_16wTime(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, value, bytestring_to_val(time48));
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_analog_input_event_SPwoTime(uint8 flag, uint32 value)
	{

		if ( ::dnp3_analog_input_event_SPwoTime )
			{
			BifEvent::generate_dnp3_analog_input_event_SPwoTime(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, value);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_analog_input_event_DPwoTime(uint8 flag, uint32 value_low, uint32 value_high)
	{

		if ( ::dnp3_analog_input_event_DPwoTime )
			{
			BifEvent::generate_dnp3_analog_input_event_DPwoTime(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, value_low, value_high);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_analog_input_event_SPwTime(uint8 flag, uint32 value, const_bytestring const & time48)
	{

		if ( ::dnp3_analog_input_event_SPwTime )
			{
			BifEvent::generate_dnp3_analog_input_event_SPwTime(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, value, bytestring_to_val(time48));
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_analog_input_event_DPwTime(uint8 flag, uint32 value_low, uint32 value_high, const_bytestring const & time48)
	{

		if ( ::dnp3_analog_input_event_DPwTime )
			{
			BifEvent::generate_dnp3_analog_input_event_DPwTime(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, value_low, value_high, bytestring_to_val(time48));
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_frozen_analog_input_event_32woTime(uint8 flag, int32 frozen_value)
	{

		if ( ::dnp3_frozen_analog_input_event_32woTime )
			{
			BifEvent::generate_dnp3_frozen_analog_input_event_32woTime(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, frozen_value);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_frozen_analog_input_event_16woTime(uint8 flag, int16 frozen_value)
	{

		if ( ::dnp3_frozen_analog_input_event_16woTime )
			{
			BifEvent::generate_dnp3_frozen_analog_input_event_16woTime(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, frozen_value);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_frozen_analog_input_event_32wTime(uint8 flag, int32 frozen_value, const_bytestring const & time48)
	{

		if ( ::dnp3_frozen_analog_input_event_32wTime )
			{
			BifEvent::generate_dnp3_frozen_analog_input_event_32wTime(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, frozen_value, bytestring_to_val(time48));
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_frozen_analog_input_event_16wTime(uint8 flag, int16 frozen_value, const_bytestring const & time48)
	{

		if ( ::dnp3_frozen_analog_input_event_16wTime )
			{
			BifEvent::generate_dnp3_frozen_analog_input_event_16wTime(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, frozen_value, bytestring_to_val(time48));
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_frozen_analog_input_event_SPwoTime(uint8 flag, uint32 frozen_value)
	{

		if ( ::dnp3_frozen_analog_input_event_SPwoTime )
			{
			BifEvent::generate_dnp3_frozen_analog_input_event_SPwoTime(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, frozen_value);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_frozen_analog_input_event_DPwoTime(uint8 flag, uint32 frozen_value_low, uint32 frozen_value_high)
	{

		if ( ::dnp3_frozen_analog_input_event_DPwoTime )
			{
			BifEvent::generate_dnp3_frozen_analog_input_event_DPwoTime(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, frozen_value_low, frozen_value_high);
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_frozen_analog_input_event_SPwTime(uint8 flag, uint32 frozen_value, const_bytestring const & time48)
	{

		if ( ::dnp3_frozen_analog_input_event_SPwTime )
			{
			BifEvent::generate_dnp3_frozen_analog_input_event_SPwTime(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, frozen_value, bytestring_to_val(time48));
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_frozen_analog_input_event_DPwTime(uint8 flag, uint32 frozen_value_low, uint32 frozen_value_high, const_bytestring const & time48)
	{

		if ( ::dnp3_frozen_analog_input_event_DPwTime )
			{
			BifEvent::generate_dnp3_frozen_analog_input_event_DPwTime(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), flag, frozen_value_low, frozen_value_high, bytestring_to_val(time48));
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_file_transport(uint32 file_handle, uint32 block_num, const_bytestring const & file_data)
	{

		if ( ::dnp3_file_transport )
			{
			BifEvent::generate_dnp3_file_transport(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), file_handle, block_num, bytestring_to_val(file_data));
			}

		return true;
		
	}

bool DNP3_Flow::get_dnp3_debug_byte(const_bytestring const & debug)
	{

		if ( ::dnp3_debug_byte )
			{
			BifEvent::generate_dnp3_debug_byte (
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), bytestring_to_val(debug));
			}

		return true;
		
	}

} // namespace DNP3
}  // namespace binpac

// This file was automatically generated by bifcl from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/dnp3/events.bif (plugin mode).


#include "events.bif.h"

EventHandlerPtr dnp3_application_request_header; 
void BifEvent::generate_dnp3_application_request_header(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t fc)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_application_request_header is NULL, which should happen *before*
	// BifEvent::generate_dnp3_application_request_header is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(fc, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_application_request_header, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_application_response_header; 
void BifEvent::generate_dnp3_application_response_header(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t fc, bro_uint_t iin)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_application_response_header is NULL, which should happen *before*
	// BifEvent::generate_dnp3_application_response_header is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(fc, TYPE_COUNT));
	vl->append(new Val(iin, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_application_response_header, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_object_header; 
void BifEvent::generate_dnp3_object_header(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t obj_type, bro_uint_t qua_field, bro_uint_t number, bro_uint_t rf_low, bro_uint_t rf_high)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_object_header is NULL, which should happen *before*
	// BifEvent::generate_dnp3_object_header is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(obj_type, TYPE_COUNT));
	vl->append(new Val(qua_field, TYPE_COUNT));
	vl->append(new Val(number, TYPE_COUNT));
	vl->append(new Val(rf_low, TYPE_COUNT));
	vl->append(new Val(rf_high, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_object_header, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_object_prefix; 
void BifEvent::generate_dnp3_object_prefix(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t prefix_value)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_object_prefix is NULL, which should happen *before*
	// BifEvent::generate_dnp3_object_prefix is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(prefix_value, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_object_prefix, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_header_block; 
void BifEvent::generate_dnp3_header_block(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t start, bro_uint_t len, bro_uint_t ctrl, bro_uint_t dest_addr, bro_uint_t src_addr)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_header_block is NULL, which should happen *before*
	// BifEvent::generate_dnp3_header_block is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(start, TYPE_COUNT));
	vl->append(new Val(len, TYPE_COUNT));
	vl->append(new Val(ctrl, TYPE_COUNT));
	vl->append(new Val(dest_addr, TYPE_COUNT));
	vl->append(new Val(src_addr, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_header_block, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_response_data_object; 
void BifEvent::generate_dnp3_response_data_object(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t data_value)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_response_data_object is NULL, which should happen *before*
	// BifEvent::generate_dnp3_response_data_object is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(data_value, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_response_data_object, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_attribute_common; 
void BifEvent::generate_dnp3_attribute_common(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t data_type_code, bro_uint_t leng, StringVal* attribute_obj)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_attribute_common is NULL, which should happen *before*
	// BifEvent::generate_dnp3_attribute_common is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(data_type_code, TYPE_COUNT));
	vl->append(new Val(leng, TYPE_COUNT));
	vl->append(attribute_obj);

	mgr.QueueEvent(::dnp3_attribute_common, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_crob; 
void BifEvent::generate_dnp3_crob(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t control_code, bro_uint_t count8, bro_uint_t on_time, bro_uint_t off_time, bro_uint_t status_code)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_crob is NULL, which should happen *before*
	// BifEvent::generate_dnp3_crob is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(control_code, TYPE_COUNT));
	vl->append(new Val(count8, TYPE_COUNT));
	vl->append(new Val(on_time, TYPE_COUNT));
	vl->append(new Val(off_time, TYPE_COUNT));
	vl->append(new Val(status_code, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_crob, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_pcb; 
void BifEvent::generate_dnp3_pcb(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t control_code, bro_uint_t count8, bro_uint_t on_time, bro_uint_t off_time, bro_uint_t status_code)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_pcb is NULL, which should happen *before*
	// BifEvent::generate_dnp3_pcb is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(control_code, TYPE_COUNT));
	vl->append(new Val(count8, TYPE_COUNT));
	vl->append(new Val(on_time, TYPE_COUNT));
	vl->append(new Val(off_time, TYPE_COUNT));
	vl->append(new Val(status_code, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_pcb, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_counter_32wFlag; 
void BifEvent::generate_dnp3_counter_32wFlag(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t count_value)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_counter_32wFlag is NULL, which should happen *before*
	// BifEvent::generate_dnp3_counter_32wFlag is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(count_value, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_counter_32wFlag, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_counter_16wFlag; 
void BifEvent::generate_dnp3_counter_16wFlag(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t count_value)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_counter_16wFlag is NULL, which should happen *before*
	// BifEvent::generate_dnp3_counter_16wFlag is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(count_value, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_counter_16wFlag, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_counter_32woFlag; 
void BifEvent::generate_dnp3_counter_32woFlag(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t count_value)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_counter_32woFlag is NULL, which should happen *before*
	// BifEvent::generate_dnp3_counter_32woFlag is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(count_value, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_counter_32woFlag, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_counter_16woFlag; 
void BifEvent::generate_dnp3_counter_16woFlag(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t count_value)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_counter_16woFlag is NULL, which should happen *before*
	// BifEvent::generate_dnp3_counter_16woFlag is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(count_value, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_counter_16woFlag, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_frozen_counter_32wFlag; 
void BifEvent::generate_dnp3_frozen_counter_32wFlag(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t count_value)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_frozen_counter_32wFlag is NULL, which should happen *before*
	// BifEvent::generate_dnp3_frozen_counter_32wFlag is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(count_value, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_frozen_counter_32wFlag, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_frozen_counter_16wFlag; 
void BifEvent::generate_dnp3_frozen_counter_16wFlag(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t count_value)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_frozen_counter_16wFlag is NULL, which should happen *before*
	// BifEvent::generate_dnp3_frozen_counter_16wFlag is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(count_value, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_frozen_counter_16wFlag, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_frozen_counter_32wFlagTime; 
void BifEvent::generate_dnp3_frozen_counter_32wFlagTime(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t count_value, StringVal* time48)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_frozen_counter_32wFlagTime is NULL, which should happen *before*
	// BifEvent::generate_dnp3_frozen_counter_32wFlagTime is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(count_value, TYPE_COUNT));
	vl->append(time48);

	mgr.QueueEvent(::dnp3_frozen_counter_32wFlagTime, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_frozen_counter_16wFlagTime; 
void BifEvent::generate_dnp3_frozen_counter_16wFlagTime(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t count_value, StringVal* time48)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_frozen_counter_16wFlagTime is NULL, which should happen *before*
	// BifEvent::generate_dnp3_frozen_counter_16wFlagTime is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(count_value, TYPE_COUNT));
	vl->append(time48);

	mgr.QueueEvent(::dnp3_frozen_counter_16wFlagTime, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_frozen_counter_32woFlag; 
void BifEvent::generate_dnp3_frozen_counter_32woFlag(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t count_value)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_frozen_counter_32woFlag is NULL, which should happen *before*
	// BifEvent::generate_dnp3_frozen_counter_32woFlag is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(count_value, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_frozen_counter_32woFlag, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_frozen_counter_16woFlag; 
void BifEvent::generate_dnp3_frozen_counter_16woFlag(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t count_value)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_frozen_counter_16woFlag is NULL, which should happen *before*
	// BifEvent::generate_dnp3_frozen_counter_16woFlag is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(count_value, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_frozen_counter_16woFlag, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_analog_input_32wFlag; 
void BifEvent::generate_dnp3_analog_input_32wFlag(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t value)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_analog_input_32wFlag is NULL, which should happen *before*
	// BifEvent::generate_dnp3_analog_input_32wFlag is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(value, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_analog_input_32wFlag, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_analog_input_16wFlag; 
void BifEvent::generate_dnp3_analog_input_16wFlag(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t value)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_analog_input_16wFlag is NULL, which should happen *before*
	// BifEvent::generate_dnp3_analog_input_16wFlag is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(value, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_analog_input_16wFlag, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_analog_input_32woFlag; 
void BifEvent::generate_dnp3_analog_input_32woFlag(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t value)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_analog_input_32woFlag is NULL, which should happen *before*
	// BifEvent::generate_dnp3_analog_input_32woFlag is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(value, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_analog_input_32woFlag, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_analog_input_16woFlag; 
void BifEvent::generate_dnp3_analog_input_16woFlag(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t value)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_analog_input_16woFlag is NULL, which should happen *before*
	// BifEvent::generate_dnp3_analog_input_16woFlag is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(value, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_analog_input_16woFlag, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_analog_input_SPwFlag; 
void BifEvent::generate_dnp3_analog_input_SPwFlag(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t value)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_analog_input_SPwFlag is NULL, which should happen *before*
	// BifEvent::generate_dnp3_analog_input_SPwFlag is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(value, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_analog_input_SPwFlag, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_analog_input_DPwFlag; 
void BifEvent::generate_dnp3_analog_input_DPwFlag(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t value_low, bro_uint_t value_high)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_analog_input_DPwFlag is NULL, which should happen *before*
	// BifEvent::generate_dnp3_analog_input_DPwFlag is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(value_low, TYPE_COUNT));
	vl->append(new Val(value_high, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_analog_input_DPwFlag, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_frozen_analog_input_32wFlag; 
void BifEvent::generate_dnp3_frozen_analog_input_32wFlag(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t frozen_value)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_frozen_analog_input_32wFlag is NULL, which should happen *before*
	// BifEvent::generate_dnp3_frozen_analog_input_32wFlag is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(frozen_value, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_frozen_analog_input_32wFlag, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_frozen_analog_input_16wFlag; 
void BifEvent::generate_dnp3_frozen_analog_input_16wFlag(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t frozen_value)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_frozen_analog_input_16wFlag is NULL, which should happen *before*
	// BifEvent::generate_dnp3_frozen_analog_input_16wFlag is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(frozen_value, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_frozen_analog_input_16wFlag, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_frozen_analog_input_32wTime; 
void BifEvent::generate_dnp3_frozen_analog_input_32wTime(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t frozen_value, StringVal* time48)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_frozen_analog_input_32wTime is NULL, which should happen *before*
	// BifEvent::generate_dnp3_frozen_analog_input_32wTime is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(frozen_value, TYPE_COUNT));
	vl->append(time48);

	mgr.QueueEvent(::dnp3_frozen_analog_input_32wTime, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_frozen_analog_input_16wTime; 
void BifEvent::generate_dnp3_frozen_analog_input_16wTime(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t frozen_value, StringVal* time48)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_frozen_analog_input_16wTime is NULL, which should happen *before*
	// BifEvent::generate_dnp3_frozen_analog_input_16wTime is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(frozen_value, TYPE_COUNT));
	vl->append(time48);

	mgr.QueueEvent(::dnp3_frozen_analog_input_16wTime, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_frozen_analog_input_32woFlag; 
void BifEvent::generate_dnp3_frozen_analog_input_32woFlag(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t frozen_value)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_frozen_analog_input_32woFlag is NULL, which should happen *before*
	// BifEvent::generate_dnp3_frozen_analog_input_32woFlag is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(frozen_value, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_frozen_analog_input_32woFlag, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_frozen_analog_input_16woFlag; 
void BifEvent::generate_dnp3_frozen_analog_input_16woFlag(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t frozen_value)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_frozen_analog_input_16woFlag is NULL, which should happen *before*
	// BifEvent::generate_dnp3_frozen_analog_input_16woFlag is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(frozen_value, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_frozen_analog_input_16woFlag, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_frozen_analog_input_SPwFlag; 
void BifEvent::generate_dnp3_frozen_analog_input_SPwFlag(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t frozen_value)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_frozen_analog_input_SPwFlag is NULL, which should happen *before*
	// BifEvent::generate_dnp3_frozen_analog_input_SPwFlag is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(frozen_value, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_frozen_analog_input_SPwFlag, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_frozen_analog_input_DPwFlag; 
void BifEvent::generate_dnp3_frozen_analog_input_DPwFlag(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t frozen_value_low, bro_uint_t frozen_value_high)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_frozen_analog_input_DPwFlag is NULL, which should happen *before*
	// BifEvent::generate_dnp3_frozen_analog_input_DPwFlag is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(frozen_value_low, TYPE_COUNT));
	vl->append(new Val(frozen_value_high, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_frozen_analog_input_DPwFlag, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_analog_input_event_32woTime; 
void BifEvent::generate_dnp3_analog_input_event_32woTime(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t value)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_analog_input_event_32woTime is NULL, which should happen *before*
	// BifEvent::generate_dnp3_analog_input_event_32woTime is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(value, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_analog_input_event_32woTime, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_analog_input_event_16woTime; 
void BifEvent::generate_dnp3_analog_input_event_16woTime(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t value)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_analog_input_event_16woTime is NULL, which should happen *before*
	// BifEvent::generate_dnp3_analog_input_event_16woTime is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(value, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_analog_input_event_16woTime, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_analog_input_event_32wTime; 
void BifEvent::generate_dnp3_analog_input_event_32wTime(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t value, StringVal* time48)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_analog_input_event_32wTime is NULL, which should happen *before*
	// BifEvent::generate_dnp3_analog_input_event_32wTime is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(value, TYPE_COUNT));
	vl->append(time48);

	mgr.QueueEvent(::dnp3_analog_input_event_32wTime, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_analog_input_event_16wTime; 
void BifEvent::generate_dnp3_analog_input_event_16wTime(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t value, StringVal* time48)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_analog_input_event_16wTime is NULL, which should happen *before*
	// BifEvent::generate_dnp3_analog_input_event_16wTime is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(value, TYPE_COUNT));
	vl->append(time48);

	mgr.QueueEvent(::dnp3_analog_input_event_16wTime, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_analog_input_event_SPwoTime; 
void BifEvent::generate_dnp3_analog_input_event_SPwoTime(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t value)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_analog_input_event_SPwoTime is NULL, which should happen *before*
	// BifEvent::generate_dnp3_analog_input_event_SPwoTime is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(value, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_analog_input_event_SPwoTime, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_analog_input_event_DPwoTime; 
void BifEvent::generate_dnp3_analog_input_event_DPwoTime(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t value_low, bro_uint_t value_high)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_analog_input_event_DPwoTime is NULL, which should happen *before*
	// BifEvent::generate_dnp3_analog_input_event_DPwoTime is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(value_low, TYPE_COUNT));
	vl->append(new Val(value_high, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_analog_input_event_DPwoTime, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_analog_input_event_SPwTime; 
void BifEvent::generate_dnp3_analog_input_event_SPwTime(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t value, StringVal* time48)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_analog_input_event_SPwTime is NULL, which should happen *before*
	// BifEvent::generate_dnp3_analog_input_event_SPwTime is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(value, TYPE_COUNT));
	vl->append(time48);

	mgr.QueueEvent(::dnp3_analog_input_event_SPwTime, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_analog_input_event_DPwTime; 
void BifEvent::generate_dnp3_analog_input_event_DPwTime(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t value_low, bro_uint_t value_high, StringVal* time48)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_analog_input_event_DPwTime is NULL, which should happen *before*
	// BifEvent::generate_dnp3_analog_input_event_DPwTime is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(value_low, TYPE_COUNT));
	vl->append(new Val(value_high, TYPE_COUNT));
	vl->append(time48);

	mgr.QueueEvent(::dnp3_analog_input_event_DPwTime, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_frozen_analog_input_event_32woTime; 
void BifEvent::generate_dnp3_frozen_analog_input_event_32woTime(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t frozen_value)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_frozen_analog_input_event_32woTime is NULL, which should happen *before*
	// BifEvent::generate_dnp3_frozen_analog_input_event_32woTime is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(frozen_value, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_frozen_analog_input_event_32woTime, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_frozen_analog_input_event_16woTime; 
void BifEvent::generate_dnp3_frozen_analog_input_event_16woTime(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t frozen_value)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_frozen_analog_input_event_16woTime is NULL, which should happen *before*
	// BifEvent::generate_dnp3_frozen_analog_input_event_16woTime is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(frozen_value, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_frozen_analog_input_event_16woTime, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_frozen_analog_input_event_32wTime; 
void BifEvent::generate_dnp3_frozen_analog_input_event_32wTime(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t frozen_value, StringVal* time48)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_frozen_analog_input_event_32wTime is NULL, which should happen *before*
	// BifEvent::generate_dnp3_frozen_analog_input_event_32wTime is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(frozen_value, TYPE_COUNT));
	vl->append(time48);

	mgr.QueueEvent(::dnp3_frozen_analog_input_event_32wTime, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_frozen_analog_input_event_16wTime; 
void BifEvent::generate_dnp3_frozen_analog_input_event_16wTime(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t frozen_value, StringVal* time48)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_frozen_analog_input_event_16wTime is NULL, which should happen *before*
	// BifEvent::generate_dnp3_frozen_analog_input_event_16wTime is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(frozen_value, TYPE_COUNT));
	vl->append(time48);

	mgr.QueueEvent(::dnp3_frozen_analog_input_event_16wTime, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_frozen_analog_input_event_SPwoTime; 
void BifEvent::generate_dnp3_frozen_analog_input_event_SPwoTime(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t frozen_value)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_frozen_analog_input_event_SPwoTime is NULL, which should happen *before*
	// BifEvent::generate_dnp3_frozen_analog_input_event_SPwoTime is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(frozen_value, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_frozen_analog_input_event_SPwoTime, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_frozen_analog_input_event_DPwoTime; 
void BifEvent::generate_dnp3_frozen_analog_input_event_DPwoTime(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t frozen_value_low, bro_uint_t frozen_value_high)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_frozen_analog_input_event_DPwoTime is NULL, which should happen *before*
	// BifEvent::generate_dnp3_frozen_analog_input_event_DPwoTime is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(frozen_value_low, TYPE_COUNT));
	vl->append(new Val(frozen_value_high, TYPE_COUNT));

	mgr.QueueEvent(::dnp3_frozen_analog_input_event_DPwoTime, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_frozen_analog_input_event_SPwTime; 
void BifEvent::generate_dnp3_frozen_analog_input_event_SPwTime(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t frozen_value, StringVal* time48)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_frozen_analog_input_event_SPwTime is NULL, which should happen *before*
	// BifEvent::generate_dnp3_frozen_analog_input_event_SPwTime is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(frozen_value, TYPE_COUNT));
	vl->append(time48);

	mgr.QueueEvent(::dnp3_frozen_analog_input_event_SPwTime, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_frozen_analog_input_event_DPwTime; 
void BifEvent::generate_dnp3_frozen_analog_input_event_DPwTime(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t flag, bro_uint_t frozen_value_low, bro_uint_t frozen_value_high, StringVal* time48)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_frozen_analog_input_event_DPwTime is NULL, which should happen *before*
	// BifEvent::generate_dnp3_frozen_analog_input_event_DPwTime is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(flag, TYPE_COUNT));
	vl->append(new Val(frozen_value_low, TYPE_COUNT));
	vl->append(new Val(frozen_value_high, TYPE_COUNT));
	vl->append(time48);

	mgr.QueueEvent(::dnp3_frozen_analog_input_event_DPwTime, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_file_transport; 
void BifEvent::generate_dnp3_file_transport(analyzer::Analyzer* analyzer, Connection* c, int is_orig, bro_uint_t file_handle, bro_uint_t block_num, StringVal* file_data)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_file_transport is NULL, which should happen *before*
	// BifEvent::generate_dnp3_file_transport is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(file_handle, TYPE_COUNT));
	vl->append(new Val(block_num, TYPE_COUNT));
	vl->append(file_data);

	mgr.QueueEvent(::dnp3_file_transport, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr dnp3_debug_byte; 
void BifEvent::generate_dnp3_debug_byte(analyzer::Analyzer* analyzer, Connection* c, int is_orig, StringVal* debug)
	{
	// Note that it is intentional that here we do not
	// check if ::dnp3_debug_byte is NULL, which should happen *before*
	// BifEvent::generate_dnp3_debug_byte is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(debug);

	mgr.QueueEvent(::dnp3_debug_byte, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation

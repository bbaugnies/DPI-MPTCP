// This file is automatically generated from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus.pac.


#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include "/home/benjamin/Bro/bro-2.3.1/build/src/analyzer/protocol/modbus/modbus_pac.h"

namespace binpac {






namespace ModbusTCP {
ContextModbusTCP::ContextModbusTCP(ModbusTCP_Conn * connection, ModbusTCP_Flow * flow, FlowBuffer * flow_buffer)
	{
	connection_ = connection;
	flow_ = flow;
	flow_buffer_ = flow_buffer;
	}

ContextModbusTCP::~ContextModbusTCP()
	{
	}

ModbusTCP_Conn::ModbusTCP_Conn(BroAnalyzer const & bro_analyzer)
	{
	upflow_ = new ModbusTCP_Flow(this, true);
	downflow_ = new ModbusTCP_Flow(this, false);
	bro_analyzer_ = bro_analyzer;
	}

ModbusTCP_Conn::~ModbusTCP_Conn()
	{
	delete upflow_;
	upflow_ = 0;
	delete downflow_;
	downflow_ = 0;
	}

void ModbusTCP_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void ModbusTCP_Conn::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void ModbusTCP_Conn::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

ModbusTCP_PDU::ModbusTCP_PDU(bool is_orig)
	{
	header_ = 0;
	body_case_index_ = -1;
	request_ = 0;
	response_ = 0;
	is_orig_ = is_orig;
	byteorder_ = bigendian;
	buffering_state_ = 0;
	buffering_state_ = 0;
	}

ModbusTCP_PDU::~ModbusTCP_PDU()
	{
	delete header_;
	header_ = 0;
	switch ( body_case_index() )
		{
		case 1:
			// Clean up "request"
			{
			delete request_;
			request_ = 0;
			}
			break;
		case 0:
			// Clean up "response"
			{
			delete response_;
			response_ = 0;
			}
			break;
		}
	}

bool ModbusTCP_PDU::ParseBuffer(flow_buffer_t t_flow_buffer, ContextModbusTCP * t_context)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	const_byteptr t_begin_of_data = t_flow_buffer->begin();
	const_byteptr t_end_of_data = t_flow_buffer->end();
	switch ( buffering_state_ )
		{
		case 0:
			if ( buffering_state_ == 0 )
				{
				t_flow_buffer->NewFrame(8, false);
				buffering_state_ = 1;
				}
			buffering_state_ = 1;
			break;
		case 1:
			{
			buffering_state_ = 2;
			// Checking out-of-bound for "ModbusTCP_PDU:header"
			if ( t_begin_of_data + (8) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("ModbusTCP_PDU:header",
					(0) + (8), 
					(t_end_of_data) - (t_begin_of_data));
				}
			// Parse "header"
			header_ = new ModbusTCP_TransportHeader();
			header_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_flow_buffer->GrowFrame(header()->len() + 6);
			}
			break;
		case 2:
			BINPAC_ASSERT(t_flow_buffer->ready());
			if ( t_flow_buffer->ready() )
				{
				
				// Parse "body"
				int t_body__size;
				body_case_index_ = is_orig();
				switch ( body_case_index() )
					{
					case 1:
						// Parse "request"
						{
						request_ = new ModbusTCP_Request(header());
						int t_request__size;
						t_request__size = request_->Parse((t_begin_of_data + 8), t_end_of_data, t_context);
						// Evaluate 'let' and 'withinput' fields
						t_body__size = t_request__size;
						}
						break;
					case 0:
						// Parse "response"
						{
						response_ = new ModbusTCP_Response(header());
						int t_response__size;
						t_response__size = response_->Parse((t_begin_of_data + 8), t_end_of_data, t_context);
						// Evaluate 'let' and 'withinput' fields
						t_body__size = t_response__size;
						}
						break;
					default:
						throw binpac::ExceptionInvalidCaseIndex("ModbusTCP_PDU", body_case_index());
						break;
					}
				// Evaluate 'let' and 'withinput' fields
				
				t_val_parsing_complete = true;
				if ( t_val_parsing_complete )
					{
					// Evaluate 'let' and 'withinput' fields
					}
				BINPAC_ASSERT(t_val_parsing_complete);
				buffering_state_ = 0;
				}
			break;
		default:
			BINPAC_ASSERT(buffering_state_ <= 2);
			break;
		}
	return t_val_parsing_complete;
	}

ModbusTCP_TransportHeader::ModbusTCP_TransportHeader()
	{
	tid_ = 0;
	pid_ = 0;
	len_ = 0;
	uid_ = 0;
	fc_ = 0;
	byteorder_ = bigendian;
	deliver_ = 0;
	}

ModbusTCP_TransportHeader::~ModbusTCP_TransportHeader()
	{
	}

int ModbusTCP_TransportHeader::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "ModbusTCP_TransportHeader"
	if ( t_begin_of_data + (8) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ModbusTCP_TransportHeader",
			(0) + (8), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "tid"
	tid_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "pid"
	pid_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "len"
	len_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "uid"
	uid_ = *((uint8 const *) ((t_begin_of_data + 6)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "fc"
	fc_ = *((uint8 const *) ((t_begin_of_data + 7)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_message(this);
	BINPAC_ASSERT(t_begin_of_data + (8) <= t_end_of_data);
	return 8;
	}

ModbusTCP_Request::ModbusTCP_Request(ModbusTCP_TransportHeader * header)
	{
	val_case_index_ = -1;
	readCoils_ = 0;
	readDiscreteInputs_ = 0;
	readHoldingRegisters_ = 0;
	readInputRegisters_ = 0;
	writeSingleCoil_ = 0;
	writeSingleRegister_ = 0;
	writeMultipleCoils_ = 0;
	writeMultRegisters_ = 0;
	readFileRecord_ = 0;
	writeFileRecord_ = 0;
	maskWriteRegister_ = 0;
	readWriteMultipleRegisters_ = 0;
	readFIFOQueue_ = 0;
	header_ = header;
	}

ModbusTCP_Request::~ModbusTCP_Request()
	{
	switch ( val_case_index() )
		{
		case 1:
			// Clean up "readCoils"
			{
			delete readCoils_;
			readCoils_ = 0;
			}
			break;
		case 2:
			// Clean up "readDiscreteInputs"
			{
			delete readDiscreteInputs_;
			readDiscreteInputs_ = 0;
			}
			break;
		case 3:
			// Clean up "readHoldingRegisters"
			{
			delete readHoldingRegisters_;
			readHoldingRegisters_ = 0;
			}
			break;
		case 4:
			// Clean up "readInputRegisters"
			{
			delete readInputRegisters_;
			readInputRegisters_ = 0;
			}
			break;
		case 5:
			// Clean up "writeSingleCoil"
			{
			delete writeSingleCoil_;
			writeSingleCoil_ = 0;
			}
			break;
		case 6:
			// Clean up "writeSingleRegister"
			{
			delete writeSingleRegister_;
			writeSingleRegister_ = 0;
			}
			break;
		case 15:
			// Clean up "writeMultipleCoils"
			{
			delete writeMultipleCoils_;
			writeMultipleCoils_ = 0;
			}
			break;
		case 16:
			// Clean up "writeMultRegisters"
			{
			delete writeMultRegisters_;
			writeMultRegisters_ = 0;
			}
			break;
		case 20:
			// Clean up "readFileRecord"
			{
			delete readFileRecord_;
			readFileRecord_ = 0;
			}
			break;
		case 21:
			// Clean up "writeFileRecord"
			{
			delete writeFileRecord_;
			writeFileRecord_ = 0;
			}
			break;
		case 22:
			// Clean up "maskWriteRegister"
			{
			delete maskWriteRegister_;
			maskWriteRegister_ = 0;
			}
			break;
		case 23:
			// Clean up "readWriteMultipleRegisters"
			{
			delete readWriteMultipleRegisters_;
			readWriteMultipleRegisters_ = 0;
			}
			break;
		case 24:
			// Clean up "readFIFOQueue"
			{
			delete readFIFOQueue_;
			readFIFOQueue_ = 0;
			}
			break;
		default:
			// Clean up "unknown"
			{
			unknown_.free();
			}
			break;
		}
	}

int ModbusTCP_Request::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	int t_val__size;
	val_case_index_ = header()->fc();
	switch ( val_case_index() )
		{
		case 1:
			// Parse "readCoils"
			{
			readCoils_ = new ReadCoilsRequest(header());
			readCoils_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 4;
			}
			break;
		case 2:
			// Parse "readDiscreteInputs"
			{
			readDiscreteInputs_ = new ReadDiscreteInputsRequest(header());
			readDiscreteInputs_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 4;
			}
			break;
		case 3:
			// Parse "readHoldingRegisters"
			{
			readHoldingRegisters_ = new ReadHoldingRegistersRequest(header());
			readHoldingRegisters_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 4;
			}
			break;
		case 4:
			// Parse "readInputRegisters"
			{
			readInputRegisters_ = new ReadInputRegistersRequest(header());
			readInputRegisters_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 4;
			}
			break;
		case 5:
			// Parse "writeSingleCoil"
			{
			writeSingleCoil_ = new WriteSingleCoilRequest(header());
			writeSingleCoil_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 4;
			}
			break;
		case 6:
			// Parse "writeSingleRegister"
			{
			writeSingleRegister_ = new WriteSingleRegisterRequest(header());
			writeSingleRegister_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 4;
			}
			break;
		case 15:
			// Parse "writeMultipleCoils"
			{
			writeMultipleCoils_ = new WriteMultipleCoilsRequest(header());
			int t_writeMultipleCoils__size;
			t_writeMultipleCoils__size = writeMultipleCoils_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_writeMultipleCoils__size;
			}
			break;
		case 16:
			// Parse "writeMultRegisters"
			{
			writeMultRegisters_ = new WriteMultipleRegistersRequest(header());
			int t_writeMultRegisters__size;
			t_writeMultRegisters__size = writeMultRegisters_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_writeMultRegisters__size;
			}
			break;
		case 20:
			// Parse "readFileRecord"
			{
			readFileRecord_ = new ReadFileRecordRequest(header());
			int t_readFileRecord__size;
			t_readFileRecord__size = readFileRecord_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_readFileRecord__size;
			}
			break;
		case 21:
			// Parse "writeFileRecord"
			{
			writeFileRecord_ = new WriteFileRecordRequest(header());
			int t_writeFileRecord__size;
			t_writeFileRecord__size = writeFileRecord_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_writeFileRecord__size;
			}
			break;
		case 22:
			// Parse "maskWriteRegister"
			{
			maskWriteRegister_ = new MaskWriteRegisterRequest(header());
			maskWriteRegister_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 6;
			}
			break;
		case 23:
			// Parse "readWriteMultipleRegisters"
			{
			readWriteMultipleRegisters_ = new ReadWriteMultipleRegistersRequest(header());
			int t_readWriteMultipleRegisters__size;
			t_readWriteMultipleRegisters__size = readWriteMultipleRegisters_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_readWriteMultipleRegisters__size;
			}
			break;
		case 24:
			// Parse "readFIFOQueue"
			{
			readFIFOQueue_ = new ReadFIFOQueueRequest(header());
			readFIFOQueue_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 2;
			}
			break;
		default:
			// Parse "unknown"
			{
			int t_unknown_string_length;
			t_unknown_string_length = (t_end_of_data) - (t_begin_of_data);
			int t_unknown__size;
			t_unknown__size = t_unknown_string_length;
			// check for negative sizes
			if ( t_unknown_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:101", t_unknown_string_length);
			unknown_.init(t_begin_of_data, t_unknown_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_unknown__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

ModbusTCP_Response::ModbusTCP_Response(ModbusTCP_TransportHeader * header)
	{
	val_case_index_ = -1;
	readCoils_ = 0;
	readDiscreteInputs_ = 0;
	readHoldingRegisters_ = 0;
	readInputRegisters_ = 0;
	writeSingleCoil_ = 0;
	writeSingleRegister_ = 0;
	writeMultipleCoils_ = 0;
	writeMultRegisters_ = 0;
	readFileRecord_ = 0;
	writeFileRecord_ = 0;
	maskWriteRegister_ = 0;
	readWriteMultipleRegisters_ = 0;
	readFIFOQueue_ = 0;
	readHoldingRegistersException_ = 0;
	writeMultRegistersException_ = 0;
	readCoilsException_ = 0;
	readDiscreteInputsException_ = 0;
	readInputRegistersException_ = 0;
	writeCoilException_ = 0;
	writeSingleRegisterException_ = 0;
	readExceptionStatusException_ = 0;
	forceMultipleCoilsException_ = 0;
	readGeneralReferenceException_ = 0;
	writeGeneralReferenceException_ = 0;
	maskWriteRegisterException_ = 0;
	readWriteRegistersException_ = 0;
	readFIFOQueueException_ = 0;
	header_ = header;
	}

ModbusTCP_Response::~ModbusTCP_Response()
	{
	switch ( val_case_index() )
		{
		case 1:
			// Clean up "readCoils"
			{
			delete readCoils_;
			readCoils_ = 0;
			}
			break;
		case 2:
			// Clean up "readDiscreteInputs"
			{
			delete readDiscreteInputs_;
			readDiscreteInputs_ = 0;
			}
			break;
		case 3:
			// Clean up "readHoldingRegisters"
			{
			delete readHoldingRegisters_;
			readHoldingRegisters_ = 0;
			}
			break;
		case 4:
			// Clean up "readInputRegisters"
			{
			delete readInputRegisters_;
			readInputRegisters_ = 0;
			}
			break;
		case 5:
			// Clean up "writeSingleCoil"
			{
			delete writeSingleCoil_;
			writeSingleCoil_ = 0;
			}
			break;
		case 6:
			// Clean up "writeSingleRegister"
			{
			delete writeSingleRegister_;
			writeSingleRegister_ = 0;
			}
			break;
		case 15:
			// Clean up "writeMultipleCoils"
			{
			delete writeMultipleCoils_;
			writeMultipleCoils_ = 0;
			}
			break;
		case 16:
			// Clean up "writeMultRegisters"
			{
			delete writeMultRegisters_;
			writeMultRegisters_ = 0;
			}
			break;
		case 20:
			// Clean up "readFileRecord"
			{
			delete readFileRecord_;
			readFileRecord_ = 0;
			}
			break;
		case 21:
			// Clean up "writeFileRecord"
			{
			delete writeFileRecord_;
			writeFileRecord_ = 0;
			}
			break;
		case 22:
			// Clean up "maskWriteRegister"
			{
			delete maskWriteRegister_;
			maskWriteRegister_ = 0;
			}
			break;
		case 23:
			// Clean up "readWriteMultipleRegisters"
			{
			delete readWriteMultipleRegisters_;
			readWriteMultipleRegisters_ = 0;
			}
			break;
		case 24:
			// Clean up "readFIFOQueue"
			{
			delete readFIFOQueue_;
			readFIFOQueue_ = 0;
			}
			break;
		case 131:
			// Clean up "readHoldingRegistersException"
			{
			delete readHoldingRegistersException_;
			readHoldingRegistersException_ = 0;
			}
			break;
		case 144:
			// Clean up "writeMultRegistersException"
			{
			delete writeMultRegistersException_;
			writeMultRegistersException_ = 0;
			}
			break;
		case 129:
			// Clean up "readCoilsException"
			{
			delete readCoilsException_;
			readCoilsException_ = 0;
			}
			break;
		case 130:
			// Clean up "readDiscreteInputsException"
			{
			delete readDiscreteInputsException_;
			readDiscreteInputsException_ = 0;
			}
			break;
		case 132:
			// Clean up "readInputRegistersException"
			{
			delete readInputRegistersException_;
			readInputRegistersException_ = 0;
			}
			break;
		case 133:
			// Clean up "writeCoilException"
			{
			delete writeCoilException_;
			writeCoilException_ = 0;
			}
			break;
		case 134:
			// Clean up "writeSingleRegisterException"
			{
			delete writeSingleRegisterException_;
			writeSingleRegisterException_ = 0;
			}
			break;
		case 135:
			// Clean up "readExceptionStatusException"
			{
			delete readExceptionStatusException_;
			readExceptionStatusException_ = 0;
			}
			break;
		case 143:
			// Clean up "forceMultipleCoilsException"
			{
			delete forceMultipleCoilsException_;
			forceMultipleCoilsException_ = 0;
			}
			break;
		case 148:
			// Clean up "readGeneralReferenceException"
			{
			delete readGeneralReferenceException_;
			readGeneralReferenceException_ = 0;
			}
			break;
		case 149:
			// Clean up "writeGeneralReferenceException"
			{
			delete writeGeneralReferenceException_;
			writeGeneralReferenceException_ = 0;
			}
			break;
		case 150:
			// Clean up "maskWriteRegisterException"
			{
			delete maskWriteRegisterException_;
			maskWriteRegisterException_ = 0;
			}
			break;
		case 151:
			// Clean up "readWriteRegistersException"
			{
			delete readWriteRegistersException_;
			readWriteRegistersException_ = 0;
			}
			break;
		case 152:
			// Clean up "readFIFOQueueException"
			{
			delete readFIFOQueueException_;
			readFIFOQueueException_ = 0;
			}
			break;
		default:
			// Clean up "unknown"
			{
			unknown_.free();
			}
			break;
		}
	}

int ModbusTCP_Response::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	int t_val__size;
	val_case_index_ = header()->fc();
	switch ( val_case_index() )
		{
		case 1:
			// Parse "readCoils"
			{
			readCoils_ = new ReadCoilsResponse(header());
			int t_readCoils__size;
			t_readCoils__size = readCoils_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_readCoils__size;
			}
			break;
		case 2:
			// Parse "readDiscreteInputs"
			{
			readDiscreteInputs_ = new ReadDiscreteInputsResponse(header());
			int t_readDiscreteInputs__size;
			t_readDiscreteInputs__size = readDiscreteInputs_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_readDiscreteInputs__size;
			}
			break;
		case 3:
			// Parse "readHoldingRegisters"
			{
			readHoldingRegisters_ = new ReadHoldingRegistersResponse(header());
			int t_readHoldingRegisters__size;
			t_readHoldingRegisters__size = readHoldingRegisters_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_readHoldingRegisters__size;
			}
			break;
		case 4:
			// Parse "readInputRegisters"
			{
			readInputRegisters_ = new ReadInputRegistersResponse(header());
			int t_readInputRegisters__size;
			t_readInputRegisters__size = readInputRegisters_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_readInputRegisters__size;
			}
			break;
		case 5:
			// Parse "writeSingleCoil"
			{
			writeSingleCoil_ = new WriteSingleCoilResponse(header());
			writeSingleCoil_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 4;
			}
			break;
		case 6:
			// Parse "writeSingleRegister"
			{
			writeSingleRegister_ = new WriteSingleRegisterResponse(header());
			writeSingleRegister_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 4;
			}
			break;
		case 15:
			// Parse "writeMultipleCoils"
			{
			writeMultipleCoils_ = new WriteMultipleCoilsResponse(header());
			writeMultipleCoils_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 4;
			}
			break;
		case 16:
			// Parse "writeMultRegisters"
			{
			writeMultRegisters_ = new WriteMultipleRegistersResponse(header());
			writeMultRegisters_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 4;
			}
			break;
		case 20:
			// Parse "readFileRecord"
			{
			readFileRecord_ = new ReadFileRecordResponse(header());
			int t_readFileRecord__size;
			t_readFileRecord__size = readFileRecord_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_readFileRecord__size;
			}
			break;
		case 21:
			// Parse "writeFileRecord"
			{
			writeFileRecord_ = new WriteFileRecordResponse(header());
			int t_writeFileRecord__size;
			t_writeFileRecord__size = writeFileRecord_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_writeFileRecord__size;
			}
			break;
		case 22:
			// Parse "maskWriteRegister"
			{
			maskWriteRegister_ = new MaskWriteRegisterResponse(header());
			maskWriteRegister_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 6;
			}
			break;
		case 23:
			// Parse "readWriteMultipleRegisters"
			{
			readWriteMultipleRegisters_ = new ReadWriteMultipleRegistersResponse(header());
			int t_readWriteMultipleRegisters__size;
			t_readWriteMultipleRegisters__size = readWriteMultipleRegisters_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_readWriteMultipleRegisters__size;
			}
			break;
		case 24:
			// Parse "readFIFOQueue"
			{
			readFIFOQueue_ = new ReadFIFOQueueResponse(header());
			int t_readFIFOQueue__size;
			t_readFIFOQueue__size = readFIFOQueue_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_readFIFOQueue__size;
			}
			break;
		case 131:
			// Parse "readHoldingRegistersException"
			{
			readHoldingRegistersException_ = new Exception(header());
			readHoldingRegistersException_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 1;
			}
			break;
		case 144:
			// Parse "writeMultRegistersException"
			{
			writeMultRegistersException_ = new Exception(header());
			writeMultRegistersException_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 1;
			}
			break;
		case 129:
			// Parse "readCoilsException"
			{
			readCoilsException_ = new Exception(header());
			readCoilsException_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 1;
			}
			break;
		case 130:
			// Parse "readDiscreteInputsException"
			{
			readDiscreteInputsException_ = new Exception(header());
			readDiscreteInputsException_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 1;
			}
			break;
		case 132:
			// Parse "readInputRegistersException"
			{
			readInputRegistersException_ = new Exception(header());
			readInputRegistersException_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 1;
			}
			break;
		case 133:
			// Parse "writeCoilException"
			{
			writeCoilException_ = new Exception(header());
			writeCoilException_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 1;
			}
			break;
		case 134:
			// Parse "writeSingleRegisterException"
			{
			writeSingleRegisterException_ = new Exception(header());
			writeSingleRegisterException_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 1;
			}
			break;
		case 135:
			// Parse "readExceptionStatusException"
			{
			readExceptionStatusException_ = new Exception(header());
			readExceptionStatusException_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 1;
			}
			break;
		case 143:
			// Parse "forceMultipleCoilsException"
			{
			forceMultipleCoilsException_ = new Exception(header());
			forceMultipleCoilsException_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 1;
			}
			break;
		case 148:
			// Parse "readGeneralReferenceException"
			{
			readGeneralReferenceException_ = new Exception(header());
			readGeneralReferenceException_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 1;
			}
			break;
		case 149:
			// Parse "writeGeneralReferenceException"
			{
			writeGeneralReferenceException_ = new Exception(header());
			writeGeneralReferenceException_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 1;
			}
			break;
		case 150:
			// Parse "maskWriteRegisterException"
			{
			maskWriteRegisterException_ = new Exception(header());
			maskWriteRegisterException_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 1;
			}
			break;
		case 151:
			// Parse "readWriteRegistersException"
			{
			readWriteRegistersException_ = new Exception(header());
			readWriteRegistersException_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 1;
			}
			break;
		case 152:
			// Parse "readFIFOQueueException"
			{
			readFIFOQueueException_ = new Exception(header());
			readFIFOQueueException_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 1;
			}
			break;
		default:
			// Parse "unknown"
			{
			int t_unknown_string_length;
			t_unknown_string_length = (t_end_of_data) - (t_begin_of_data);
			int t_unknown__size;
			t_unknown__size = t_unknown_string_length;
			// check for negative sizes
			if ( t_unknown_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:143", t_unknown_string_length);
			unknown_.init(t_begin_of_data, t_unknown_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_unknown__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

Exception::Exception(ModbusTCP_TransportHeader * header)
	{
	code_ = 0;
	header_ = header;
	deliver_ = 0;
	}

Exception::~Exception()
	{
	}

int Exception::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "Exception"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Exception",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "code"
	code_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_Exception(header(), this);
	BINPAC_ASSERT(t_begin_of_data + (1) <= t_end_of_data);
	return 1;
	}

ReadCoilsRequest::ReadCoilsRequest(ModbusTCP_TransportHeader * header)
	{
	start_address_ = 0;
	quantity_ = 0;
	header_ = header;
	byteorder_ = bigendian;
	deliver_ = 0;
	}

ReadCoilsRequest::~ReadCoilsRequest()
	{
	}

int ReadCoilsRequest::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "ReadCoilsRequest"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ReadCoilsRequest",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start_address"
	start_address_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "quantity"
	quantity_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_ReadCoilsRequest(header(), this);
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

ReadCoilsResponse::ReadCoilsResponse(ModbusTCP_TransportHeader * header)
	{
	byte_count_ = 0;
	header_ = header;
	byteorder_ = bigendian;
	deliver_ = 0;
	}

ReadCoilsResponse::~ReadCoilsResponse()
	{
	bits_.free();
	}

int ReadCoilsResponse::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "ReadCoilsResponse:byte_count"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ReadCoilsResponse:byte_count",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "byte_count"
	byte_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "bits"
	int t_bits__size;
	t_bits__size = byte_count();
	// Checking out-of-bound for "ReadCoilsResponse:bits"
	if ( (t_begin_of_data + 1) + (t_bits__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ReadCoilsResponse:bits",
			(1) + (t_bits__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 1) + t_bits__size;
	int t_bits_string_length;
	t_bits_string_length = byte_count();
	// check for negative sizes
	if ( t_bits_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:163", t_bits_string_length);
	bits_.init((t_begin_of_data + 1), t_bits_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_ReadCoilsResponse__size;
	const_byteptr const t_dataptr_after_bits = (t_begin_of_data + 1) + (t_bits__size);
	BINPAC_ASSERT(t_dataptr_after_bits <= t_end_of_data);
	t_ReadCoilsResponse__size = t_dataptr_after_bits - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_ReadCoilsResponse(header(), this);
	BINPAC_ASSERT(t_begin_of_data + (t_ReadCoilsResponse__size) <= t_end_of_data);
	return t_ReadCoilsResponse__size;
	}

ReadDiscreteInputsRequest::ReadDiscreteInputsRequest(ModbusTCP_TransportHeader * header)
	{
	start_address_ = 0;
	quantity_ = 0;
	header_ = header;
	byteorder_ = bigendian;
	deliver_ = 0;
	}

ReadDiscreteInputsRequest::~ReadDiscreteInputsRequest()
	{
	}

int ReadDiscreteInputsRequest::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "ReadDiscreteInputsRequest"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ReadDiscreteInputsRequest",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start_address"
	start_address_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "quantity"
	quantity_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_ReadDiscreteInputsRequest(header(), this);
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

ReadDiscreteInputsResponse::ReadDiscreteInputsResponse(ModbusTCP_TransportHeader * header)
	{
	byte_count_ = 0;
	header_ = header;
	byteorder_ = bigendian;
	deliver_ = 0;
	}

ReadDiscreteInputsResponse::~ReadDiscreteInputsResponse()
	{
	bits_.free();
	}

int ReadDiscreteInputsResponse::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "ReadDiscreteInputsResponse:byte_count"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ReadDiscreteInputsResponse:byte_count",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "byte_count"
	byte_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "bits"
	int t_bits__size;
	t_bits__size = byte_count();
	// Checking out-of-bound for "ReadDiscreteInputsResponse:bits"
	if ( (t_begin_of_data + 1) + (t_bits__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ReadDiscreteInputsResponse:bits",
			(1) + (t_bits__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 1) + t_bits__size;
	int t_bits_string_length;
	t_bits_string_length = byte_count();
	// check for negative sizes
	if ( t_bits_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:179", t_bits_string_length);
	bits_.init((t_begin_of_data + 1), t_bits_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_ReadDiscreteInputsResponse__size;
	const_byteptr const t_dataptr_after_bits = (t_begin_of_data + 1) + (t_bits__size);
	BINPAC_ASSERT(t_dataptr_after_bits <= t_end_of_data);
	t_ReadDiscreteInputsResponse__size = t_dataptr_after_bits - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_ReadDiscreteInputsResponse(header(), this);
	BINPAC_ASSERT(t_begin_of_data + (t_ReadDiscreteInputsResponse__size) <= t_end_of_data);
	return t_ReadDiscreteInputsResponse__size;
	}

ReadHoldingRegistersRequest::ReadHoldingRegistersRequest(ModbusTCP_TransportHeader * header)
	{
	start_address_ = 0;
	quantity_ = 0;
	header_ = header;
	byteorder_ = bigendian;
	deliver_ = 0;
	}

ReadHoldingRegistersRequest::~ReadHoldingRegistersRequest()
	{
	}

int ReadHoldingRegistersRequest::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "ReadHoldingRegistersRequest"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ReadHoldingRegistersRequest",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start_address"
	start_address_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "quantity"
	quantity_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_ReadHoldingRegistersRequest(header(), this);
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

ReadHoldingRegistersResponse::ReadHoldingRegistersResponse(ModbusTCP_TransportHeader * header)
	{
	byte_count_ = 0;
	registers_ = 0;
	registers__elem_ = 0;
	header_ = header;
	byteorder_ = bigendian;
	deliver_ = 0;
	}

ReadHoldingRegistersResponse::~ReadHoldingRegistersResponse()
	{
	delete registers_;
	}

int ReadHoldingRegistersResponse::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "ReadHoldingRegistersResponse:byte_count"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ReadHoldingRegistersResponse:byte_count",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "byte_count"
	byte_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "registers"
	int t_registers__size;
	t_registers__size = byte_count();
	// Checking out-of-bound for "ReadHoldingRegistersResponse:registers"
	if ( (t_begin_of_data + 1) + (t_registers__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ReadHoldingRegistersResponse:registers",
			(1) + (t_registers__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 1) + t_registers__size;
	int t_registers__arraylength;
	t_registers__arraylength = 0;
	t_registers__arraylength = byte_count() / 2;
	if ( t_begin_of_data + t_registers__arraylength > t_end_of_data + 1 )
		{
		t_registers__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_registers__arraylength < 0 )
		{
		t_registers__arraylength = 0;
		}
	registers__elem_ = 0;
	int t_registers__elem__it;
	t_registers__elem__it = 0;
	registers_ = new vector<uint16>;
	registers_->reserve(t_registers__arraylength);
	const_byteptr t_registers__elem__dataptr = (t_begin_of_data + 1);
	for (; t_registers__elem__it < t_registers__arraylength; ++t_registers__elem__it)
		{
		// Check &until(registers__elem__dataptr >= end_of_data)
		if ( t_registers__elem__dataptr >= t_end_of_data )
			{
			goto end_of_registers;
			}
		registers__elem_ = FixByteOrder(byteorder(), *((uint16 const *) (t_registers__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		registers_->push_back(registers__elem_);
		t_registers__elem__dataptr += 2;
		BINPAC_ASSERT(t_registers__elem__dataptr <= t_end_of_data);
		}
end_of_registers: ;
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_ReadHoldingRegistersResponse__size;
	const_byteptr const t_dataptr_after_registers = (t_begin_of_data + 1) + (t_registers__size);
	BINPAC_ASSERT(t_dataptr_after_registers <= t_end_of_data);
	t_ReadHoldingRegistersResponse__size = t_dataptr_after_registers - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_ReadHoldingRegistersResponse(header(), this);
	BINPAC_ASSERT(t_begin_of_data + (t_ReadHoldingRegistersResponse__size) <= t_end_of_data);
	return t_ReadHoldingRegistersResponse__size;
	}

ReadInputRegistersRequest::ReadInputRegistersRequest(ModbusTCP_TransportHeader * header)
	{
	start_address_ = 0;
	quantity_ = 0;
	header_ = header;
	byteorder_ = bigendian;
	deliver_ = 0;
	}

ReadInputRegistersRequest::~ReadInputRegistersRequest()
	{
	}

int ReadInputRegistersRequest::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "ReadInputRegistersRequest"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ReadInputRegistersRequest",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start_address"
	start_address_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "quantity"
	quantity_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_ReadInputRegistersRequest(header(), this);
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

ReadInputRegistersResponse::ReadInputRegistersResponse(ModbusTCP_TransportHeader * header)
	{
	byte_count_ = 0;
	registers_ = 0;
	registers__elem_ = 0;
	header_ = header;
	byteorder_ = bigendian;
	deliver_ = 0;
	}

ReadInputRegistersResponse::~ReadInputRegistersResponse()
	{
	delete registers_;
	}

int ReadInputRegistersResponse::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "ReadInputRegistersResponse:byte_count"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ReadInputRegistersResponse:byte_count",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "byte_count"
	byte_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "registers"
	int t_registers__size;
	t_registers__size = byte_count();
	// Checking out-of-bound for "ReadInputRegistersResponse:registers"
	if ( (t_begin_of_data + 1) + (t_registers__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ReadInputRegistersResponse:registers",
			(1) + (t_registers__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 1) + t_registers__size;
	int t_registers__arraylength;
	t_registers__arraylength = 0;
	t_registers__arraylength = byte_count() / 2;
	if ( t_begin_of_data + t_registers__arraylength > t_end_of_data + 1 )
		{
		t_registers__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_registers__arraylength < 0 )
		{
		t_registers__arraylength = 0;
		}
	registers__elem_ = 0;
	int t_registers__elem__it;
	t_registers__elem__it = 0;
	registers_ = new vector<uint16>;
	registers_->reserve(t_registers__arraylength);
	const_byteptr t_registers__elem__dataptr = (t_begin_of_data + 1);
	for (; t_registers__elem__it < t_registers__arraylength; ++t_registers__elem__it)
		{
		// Check &until(registers__elem__dataptr >= end_of_data)
		if ( t_registers__elem__dataptr >= t_end_of_data )
			{
			goto end_of_registers;
			}
		registers__elem_ = FixByteOrder(byteorder(), *((uint16 const *) (t_registers__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		registers_->push_back(registers__elem_);
		t_registers__elem__dataptr += 2;
		BINPAC_ASSERT(t_registers__elem__dataptr <= t_end_of_data);
		}
end_of_registers: ;
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_ReadInputRegistersResponse__size;
	const_byteptr const t_dataptr_after_registers = (t_begin_of_data + 1) + (t_registers__size);
	BINPAC_ASSERT(t_dataptr_after_registers <= t_end_of_data);
	t_ReadInputRegistersResponse__size = t_dataptr_after_registers - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_ReadInputRegistersResponse(header(), this);
	BINPAC_ASSERT(t_begin_of_data + (t_ReadInputRegistersResponse__size) <= t_end_of_data);
	return t_ReadInputRegistersResponse__size;
	}

WriteSingleCoilRequest::WriteSingleCoilRequest(ModbusTCP_TransportHeader * header)
	{
	address_ = 0;
	value_ = 0;
	header_ = header;
	byteorder_ = bigendian;
	deliver_ = 0;
	}

WriteSingleCoilRequest::~WriteSingleCoilRequest()
	{
	}

int WriteSingleCoilRequest::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "WriteSingleCoilRequest"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("WriteSingleCoilRequest",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "address"
	address_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	value_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_WriteSingleCoilRequest(header(), this);
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

WriteSingleCoilResponse::WriteSingleCoilResponse(ModbusTCP_TransportHeader * header)
	{
	address_ = 0;
	value_ = 0;
	header_ = header;
	byteorder_ = bigendian;
	deliver_ = 0;
	}

WriteSingleCoilResponse::~WriteSingleCoilResponse()
	{
	}

int WriteSingleCoilResponse::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "WriteSingleCoilResponse"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("WriteSingleCoilResponse",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "address"
	address_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	value_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_WriteSingleCoilResponse(header(), this);
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

WriteSingleRegisterRequest::WriteSingleRegisterRequest(ModbusTCP_TransportHeader * header)
	{
	address_ = 0;
	value_ = 0;
	header_ = header;
	byteorder_ = bigendian;
	deliver_ = 0;
	}

WriteSingleRegisterRequest::~WriteSingleRegisterRequest()
	{
	}

int WriteSingleRegisterRequest::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "WriteSingleRegisterRequest"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("WriteSingleRegisterRequest",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "address"
	address_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	value_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_WriteSingleRegisterRequest(header(), this);
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

WriteSingleRegisterResponse::WriteSingleRegisterResponse(ModbusTCP_TransportHeader * header)
	{
	address_ = 0;
	value_ = 0;
	header_ = header;
	byteorder_ = bigendian;
	deliver_ = 0;
	}

WriteSingleRegisterResponse::~WriteSingleRegisterResponse()
	{
	}

int WriteSingleRegisterResponse::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "WriteSingleRegisterResponse"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("WriteSingleRegisterResponse",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "address"
	address_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	value_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_WriteSingleRegisterResponse(header(), this);
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

WriteMultipleCoilsRequest::WriteMultipleCoilsRequest(ModbusTCP_TransportHeader * header)
	{
	start_address_ = 0;
	quantity_ = 0;
	byte_count_ = 0;
	header_ = header;
	byteorder_ = bigendian;
	deliver_ = 0;
	}

WriteMultipleCoilsRequest::~WriteMultipleCoilsRequest()
	{
	coils_.free();
	}

int WriteMultipleCoilsRequest::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "WriteMultipleCoilsRequest:byte_count"
	if ( (t_begin_of_data + 4) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("WriteMultipleCoilsRequest:byte_count",
			(4) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start_address"
	start_address_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "quantity"
	quantity_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte_count"
	byte_count_ = *((uint8 const *) ((t_begin_of_data + 4)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "coils"
	int t_coils__size;
	t_coils__size = byte_count();
	// Checking out-of-bound for "WriteMultipleCoilsRequest:coils"
	if ( (t_begin_of_data + 5) + (t_coils__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("WriteMultipleCoilsRequest:coils",
			(5) + (t_coils__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 5) + t_coils__size;
	int t_coils_string_length;
	t_coils_string_length = byte_count();
	// check for negative sizes
	if ( t_coils_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:253", t_coils_string_length);
	coils_.init((t_begin_of_data + 5), t_coils_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_WriteMultipleCoilsRequest__size;
	const_byteptr const t_dataptr_after_coils = (t_begin_of_data + 5) + (t_coils__size);
	BINPAC_ASSERT(t_dataptr_after_coils <= t_end_of_data);
	t_WriteMultipleCoilsRequest__size = t_dataptr_after_coils - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_WriteMultipleCoilsRequest(header(), this);
	BINPAC_ASSERT(t_begin_of_data + (t_WriteMultipleCoilsRequest__size) <= t_end_of_data);
	return t_WriteMultipleCoilsRequest__size;
	}

WriteMultipleCoilsResponse::WriteMultipleCoilsResponse(ModbusTCP_TransportHeader * header)
	{
	start_address_ = 0;
	quantity_ = 0;
	header_ = header;
	byteorder_ = bigendian;
	deliver_ = 0;
	}

WriteMultipleCoilsResponse::~WriteMultipleCoilsResponse()
	{
	}

int WriteMultipleCoilsResponse::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "WriteMultipleCoilsResponse"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("WriteMultipleCoilsResponse",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start_address"
	start_address_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "quantity"
	quantity_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_WriteMultipleCoilsResponse(header(), this);
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

WriteMultipleRegistersRequest::WriteMultipleRegistersRequest(ModbusTCP_TransportHeader * header)
	{
	start_address_ = 0;
	quantity_ = 0;
	byte_count_ = 0;
	registers_ = 0;
	registers__elem_ = 0;
	header_ = header;
	byteorder_ = bigendian;
	deliver_ = 0;
	}

WriteMultipleRegistersRequest::~WriteMultipleRegistersRequest()
	{
	delete registers_;
	}

int WriteMultipleRegistersRequest::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "WriteMultipleRegistersRequest:byte_count"
	if ( (t_begin_of_data + 4) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("WriteMultipleRegistersRequest:byte_count",
			(4) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start_address"
	start_address_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "quantity"
	quantity_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte_count"
	byte_count_ = *((uint8 const *) ((t_begin_of_data + 4)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "registers"
	int t_registers__size;
	t_registers__size = byte_count();
	// Checking out-of-bound for "WriteMultipleRegistersRequest:registers"
	if ( (t_begin_of_data + 5) + (t_registers__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("WriteMultipleRegistersRequest:registers",
			(5) + (t_registers__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 5) + t_registers__size;
	int t_registers__arraylength;
	t_registers__arraylength = 0;
	t_registers__arraylength = quantity();
	if ( t_begin_of_data + t_registers__arraylength > t_end_of_data + 1 )
		{
		t_registers__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_registers__arraylength < 0 )
		{
		t_registers__arraylength = 0;
		}
	registers__elem_ = 0;
	int t_registers__elem__it;
	t_registers__elem__it = 0;
	registers_ = new vector<uint16>;
	registers_->reserve(t_registers__arraylength);
	const_byteptr t_registers__elem__dataptr = (t_begin_of_data + 5);
	for (; t_registers__elem__it < t_registers__arraylength; ++t_registers__elem__it)
		{
		// Check &until(registers__elem__dataptr >= end_of_data)
		if ( t_registers__elem__dataptr >= t_end_of_data )
			{
			goto end_of_registers;
			}
		registers__elem_ = FixByteOrder(byteorder(), *((uint16 const *) (t_registers__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		registers_->push_back(registers__elem_);
		t_registers__elem__dataptr += 2;
		BINPAC_ASSERT(t_registers__elem__dataptr <= t_end_of_data);
		}
end_of_registers: ;
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_WriteMultipleRegistersRequest__size;
	const_byteptr const t_dataptr_after_registers = (t_begin_of_data + 5) + (t_registers__size);
	BINPAC_ASSERT(t_dataptr_after_registers <= t_end_of_data);
	t_WriteMultipleRegistersRequest__size = t_dataptr_after_registers - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_WriteMultipleRegistersRequest(header(), this);
	BINPAC_ASSERT(t_begin_of_data + (t_WriteMultipleRegistersRequest__size) <= t_end_of_data);
	return t_WriteMultipleRegistersRequest__size;
	}

WriteMultipleRegistersResponse::WriteMultipleRegistersResponse(ModbusTCP_TransportHeader * header)
	{
	start_address_ = 0;
	quantity_ = 0;
	header_ = header;
	byteorder_ = bigendian;
	deliver_ = 0;
	}

WriteMultipleRegistersResponse::~WriteMultipleRegistersResponse()
	{
	}

int WriteMultipleRegistersResponse::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "WriteMultipleRegistersResponse"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("WriteMultipleRegistersResponse",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start_address"
	start_address_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "quantity"
	quantity_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_WriteMultipleRegistersResponse(header(), this);
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

FileRecordRequest::FileRecordRequest()
	{
	ref_type_ = 0;
	file_num_ = 0;
	record_num_ = 0;
	record_len_ = 0;
	byteorder_ = bigendian;
	}

FileRecordRequest::~FileRecordRequest()
	{
	}

int FileRecordRequest::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "FileRecordRequest"
	if ( t_begin_of_data + (7) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FileRecordRequest",
			(0) + (7), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "ref_type"
	ref_type_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "file_num"
	file_num_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "record_num"
	record_num_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 3))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "record_len"
	record_len_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 5))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (7) <= t_end_of_data);
	return 7;
	}

ReadFileRecordRequest::ReadFileRecordRequest(ModbusTCP_TransportHeader * header)
	{
	byte_count_ = 0;
	references_ = 0;
	references__elem_ = 0;
	header_ = header;
	byteorder_ = bigendian;
	deliver_ = 0;
	}

ReadFileRecordRequest::~ReadFileRecordRequest()
	{
	delete references__elem_;
	references__elem_ = 0;
	if ( references() )
		{
		for ( int i = 0; i < (int) references()->size(); ++i )
			{
			FileRecordRequest * references__elem_ = (*references_)[i];
			delete references__elem_;
			references__elem_ = 0;
			}
		}
	delete references_;
	}

int ReadFileRecordRequest::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "ReadFileRecordRequest:byte_count"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ReadFileRecordRequest:byte_count",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "byte_count"
	byte_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "references"
	int t_references__size;
	t_references__size = byte_count();
	// Checking out-of-bound for "ReadFileRecordRequest:references"
	if ( (t_begin_of_data + 1) + (t_references__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ReadFileRecordRequest:references",
			(1) + (t_references__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 1) + t_references__size;
	int t_references__arraylength;
	t_references__arraylength = 0;
	references__elem_ = 0;
	int t_references__elem__it;
	t_references__elem__it = 0;
	references_ = new vector<FileRecordRequest *>;
	const_byteptr t_references__elem__dataptr = (t_begin_of_data + 1);
	for (; /* forever */; ++t_references__elem__it)
		{
		// Check &until(references__elem__dataptr >= end_of_data)
		if ( t_references__elem__dataptr >= t_end_of_data )
			{
			references__elem_ = 0;
			goto end_of_references;
			}
		references__elem_ = new FileRecordRequest();
		references__elem_->Parse(t_references__elem__dataptr, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		references_->push_back(references__elem_);
		t_references__elem__dataptr += 7;
		BINPAC_ASSERT(t_references__elem__dataptr <= t_end_of_data);
		references__elem_ = 0;
		}
end_of_references: ;
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_ReadFileRecordRequest__size;
	const_byteptr const t_dataptr_after_references = (t_begin_of_data + 1) + (t_references__size);
	BINPAC_ASSERT(t_dataptr_after_references <= t_end_of_data);
	t_ReadFileRecordRequest__size = t_dataptr_after_references - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_ReadFileRecordRequest(header(), this);
	BINPAC_ASSERT(t_begin_of_data + (t_ReadFileRecordRequest__size) <= t_end_of_data);
	return t_ReadFileRecordRequest__size;
	}

FileRecordResponse::FileRecordResponse()
	{
	file_len_ = 0;
	ref_type_ = 0;
	record_data_ = 0;
	record_data__elem_ = 0;
	byteorder_ = bigendian;
	}

FileRecordResponse::~FileRecordResponse()
	{
	delete record_data_;
	}

int FileRecordResponse::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "FileRecordResponse:ref_type"
	if ( (t_begin_of_data + 1) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FileRecordResponse:ref_type",
			(1) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "file_len"
	file_len_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "ref_type"
	ref_type_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "record_data"
	int t_record_data__size;
	t_record_data__size = file_len();
	// Checking out-of-bound for "FileRecordResponse:record_data"
	if ( (t_begin_of_data + 2) + (t_record_data__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("FileRecordResponse:record_data",
			(2) + (t_record_data__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 2) + t_record_data__size;
	int t_record_data__arraylength;
	t_record_data__arraylength = 0;
	t_record_data__arraylength = file_len() / 2;
	if ( t_begin_of_data + t_record_data__arraylength > t_end_of_data + 1 )
		{
		t_record_data__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_record_data__arraylength < 0 )
		{
		t_record_data__arraylength = 0;
		}
	record_data__elem_ = 0;
	int t_record_data__elem__it;
	t_record_data__elem__it = 0;
	record_data_ = new vector<uint16>;
	record_data_->reserve(t_record_data__arraylength);
	const_byteptr t_record_data__elem__dataptr = (t_begin_of_data + 2);
	for (; t_record_data__elem__it < t_record_data__arraylength; ++t_record_data__elem__it)
		{
		// Check &until(record_data__elem__dataptr >= end_of_data)
		if ( t_record_data__elem__dataptr >= t_end_of_data )
			{
			goto end_of_record_data;
			}
		record_data__elem_ = FixByteOrder(byteorder(), *((uint16 const *) (t_record_data__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		record_data_->push_back(record_data__elem_);
		t_record_data__elem__dataptr += 2;
		BINPAC_ASSERT(t_record_data__elem__dataptr <= t_end_of_data);
		}
end_of_record_data: ;
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_FileRecordResponse__size;
	const_byteptr const t_dataptr_after_record_data = (t_begin_of_data + 2) + (t_record_data__size);
	BINPAC_ASSERT(t_dataptr_after_record_data <= t_end_of_data);
	t_FileRecordResponse__size = t_dataptr_after_record_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_FileRecordResponse__size) <= t_end_of_data);
	return t_FileRecordResponse__size;
	}

ReadFileRecordResponse::ReadFileRecordResponse(ModbusTCP_TransportHeader * header)
	{
	byte_count_ = 0;
	references_ = 0;
	references__elem_ = 0;
	header_ = header;
	byteorder_ = bigendian;
	deliver_ = 0;
	}

ReadFileRecordResponse::~ReadFileRecordResponse()
	{
	delete references__elem_;
	references__elem_ = 0;
	if ( references() )
		{
		for ( int i = 0; i < (int) references()->size(); ++i )
			{
			FileRecordResponse * references__elem_ = (*references_)[i];
			delete references__elem_;
			references__elem_ = 0;
			}
		}
	delete references_;
	}

int ReadFileRecordResponse::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "ReadFileRecordResponse:byte_count"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ReadFileRecordResponse:byte_count",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "byte_count"
	byte_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "references"
	int t_references__size;
	t_references__size = byte_count();
	// Checking out-of-bound for "ReadFileRecordResponse:references"
	if ( (t_begin_of_data + 1) + (t_references__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ReadFileRecordResponse:references",
			(1) + (t_references__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 1) + t_references__size;
	int t_references__arraylength;
	t_references__arraylength = 0;
	references__elem_ = 0;
	int t_references__elem__it;
	t_references__elem__it = 0;
	references_ = new vector<FileRecordResponse *>;
	const_byteptr t_references__elem__dataptr = (t_begin_of_data + 1);
	for (; /* forever */; ++t_references__elem__it)
		{
		// Check &until(references__elem__dataptr >= end_of_data)
		if ( t_references__elem__dataptr >= t_end_of_data )
			{
			references__elem_ = 0;
			goto end_of_references;
			}
		references__elem_ = new FileRecordResponse();
		int t_references__elem__size;
		t_references__elem__size = references__elem_->Parse(t_references__elem__dataptr, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		references_->push_back(references__elem_);
		t_references__elem__dataptr += t_references__elem__size;
		BINPAC_ASSERT(t_references__elem__dataptr <= t_end_of_data);
		references__elem_ = 0;
		}
end_of_references: ;
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_ReadFileRecordResponse__size;
	const_byteptr const t_dataptr_after_references = (t_begin_of_data + 1) + (t_references__size);
	BINPAC_ASSERT(t_dataptr_after_references <= t_end_of_data);
	t_ReadFileRecordResponse__size = t_dataptr_after_references - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_ReadFileRecordResponse(header(), this);
	BINPAC_ASSERT(t_begin_of_data + (t_ReadFileRecordResponse__size) <= t_end_of_data);
	return t_ReadFileRecordResponse__size;
	}

ReferenceWithData::ReferenceWithData()
	{
	ref_type_ = 0;
	file_num_ = 0;
	record_num_ = 0;
	word_count_ = 0;
	register_value_ = 0;
	register_value__elem_ = 0;
	byteorder_ = bigendian;
	}

ReferenceWithData::~ReferenceWithData()
	{
	delete register_value_;
	}

int ReferenceWithData::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "ReferenceWithData:word_count"
	if ( (t_begin_of_data + 5) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ReferenceWithData:word_count",
			(5) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "ref_type"
	ref_type_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "file_num"
	file_num_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "record_num"
	record_num_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 3))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "word_count"
	word_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 5))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "register_value"
	int t_register_value__arraylength;
	t_register_value__arraylength = 0;
	t_register_value__arraylength = word_count();
	if ( t_begin_of_data + t_register_value__arraylength > t_end_of_data + 1 )
		{
		t_register_value__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_register_value__arraylength < 0 )
		{
		t_register_value__arraylength = 0;
		}
	register_value__elem_ = 0;
	int t_register_value__elem__it;
	t_register_value__elem__it = 0;
	int t_register_value__size;
	register_value_ = new vector<uint16>;
	register_value_->reserve(t_register_value__arraylength);
	const_byteptr t_register_value__elem__dataptr = (t_begin_of_data + 7);
	for (; t_register_value__elem__it < t_register_value__arraylength; ++t_register_value__elem__it)
		{
		// Check &until(register_value__elem__dataptr >= end_of_data)
		if ( t_register_value__elem__dataptr >= t_end_of_data )
			{
			goto end_of_register_value;
			}
		// Checking out-of-bound for "ReferenceWithData:register_value__elem"
		if ( t_register_value__elem__dataptr + (2) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("ReferenceWithData:register_value__elem",
				((t_register_value__elem__dataptr - t_begin_of_data)) + (2), 
				(t_end_of_data) - (t_begin_of_data));
			}
		register_value__elem_ = FixByteOrder(byteorder(), *((uint16 const *) (t_register_value__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		register_value_->push_back(register_value__elem_);
		t_register_value__elem__dataptr += 2;
		BINPAC_ASSERT(t_register_value__elem__dataptr <= t_end_of_data);
		}
end_of_register_value: ;
	t_register_value__size = t_register_value__elem__dataptr - ((t_begin_of_data + 7));
	// Evaluate 'let' and 'withinput' fields
	
	int t_ReferenceWithData__size;
	const_byteptr const t_dataptr_after_register_value = (t_begin_of_data + 7) + (t_register_value__size);
	BINPAC_ASSERT(t_dataptr_after_register_value <= t_end_of_data);
	t_ReferenceWithData__size = t_dataptr_after_register_value - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ReferenceWithData__size) <= t_end_of_data);
	return t_ReferenceWithData__size;
	}

WriteFileRecordRequest::WriteFileRecordRequest(ModbusTCP_TransportHeader * header)
	{
	byte_count_ = 0;
	references_ = 0;
	references__elem_ = 0;
	header_ = header;
	byteorder_ = bigendian;
	deliver_ = 0;
	}

WriteFileRecordRequest::~WriteFileRecordRequest()
	{
	delete references__elem_;
	references__elem_ = 0;
	if ( references() )
		{
		for ( int i = 0; i < (int) references()->size(); ++i )
			{
			ReferenceWithData * references__elem_ = (*references_)[i];
			delete references__elem_;
			references__elem_ = 0;
			}
		}
	delete references_;
	}

int WriteFileRecordRequest::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "WriteFileRecordRequest:byte_count"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("WriteFileRecordRequest:byte_count",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "byte_count"
	byte_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "references"
	int t_references__size;
	t_references__size = byte_count();
	// Checking out-of-bound for "WriteFileRecordRequest:references"
	if ( (t_begin_of_data + 1) + (t_references__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("WriteFileRecordRequest:references",
			(1) + (t_references__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 1) + t_references__size;
	int t_references__arraylength;
	t_references__arraylength = 0;
	references__elem_ = 0;
	int t_references__elem__it;
	t_references__elem__it = 0;
	references_ = new vector<ReferenceWithData *>;
	const_byteptr t_references__elem__dataptr = (t_begin_of_data + 1);
	for (; /* forever */; ++t_references__elem__it)
		{
		// Check &until(references__elem__dataptr >= end_of_data)
		if ( t_references__elem__dataptr >= t_end_of_data )
			{
			references__elem_ = 0;
			goto end_of_references;
			}
		references__elem_ = new ReferenceWithData();
		int t_references__elem__size;
		t_references__elem__size = references__elem_->Parse(t_references__elem__dataptr, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		references_->push_back(references__elem_);
		t_references__elem__dataptr += t_references__elem__size;
		BINPAC_ASSERT(t_references__elem__dataptr <= t_end_of_data);
		references__elem_ = 0;
		}
end_of_references: ;
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_WriteFileRecordRequest__size;
	const_byteptr const t_dataptr_after_references = (t_begin_of_data + 1) + (t_references__size);
	BINPAC_ASSERT(t_dataptr_after_references <= t_end_of_data);
	t_WriteFileRecordRequest__size = t_dataptr_after_references - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_WriteFileRecordRequest(header(), this);
	BINPAC_ASSERT(t_begin_of_data + (t_WriteFileRecordRequest__size) <= t_end_of_data);
	return t_WriteFileRecordRequest__size;
	}

WriteFileRecordResponse::WriteFileRecordResponse(ModbusTCP_TransportHeader * header)
	{
	byte_count_ = 0;
	references_ = 0;
	references__elem_ = 0;
	header_ = header;
	byteorder_ = bigendian;
	deliver_ = 0;
	}

WriteFileRecordResponse::~WriteFileRecordResponse()
	{
	delete references__elem_;
	references__elem_ = 0;
	if ( references() )
		{
		for ( int i = 0; i < (int) references()->size(); ++i )
			{
			ReferenceWithData * references__elem_ = (*references_)[i];
			delete references__elem_;
			references__elem_ = 0;
			}
		}
	delete references_;
	}

int WriteFileRecordResponse::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "WriteFileRecordResponse:byte_count"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("WriteFileRecordResponse:byte_count",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "byte_count"
	byte_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "references"
	int t_references__size;
	t_references__size = byte_count();
	// Checking out-of-bound for "WriteFileRecordResponse:references"
	if ( (t_begin_of_data + 1) + (t_references__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("WriteFileRecordResponse:references",
			(1) + (t_references__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 1) + t_references__size;
	int t_references__arraylength;
	t_references__arraylength = 0;
	references__elem_ = 0;
	int t_references__elem__it;
	t_references__elem__it = 0;
	references_ = new vector<ReferenceWithData *>;
	const_byteptr t_references__elem__dataptr = (t_begin_of_data + 1);
	for (; /* forever */; ++t_references__elem__it)
		{
		// Check &until(references__elem__dataptr >= end_of_data)
		if ( t_references__elem__dataptr >= t_end_of_data )
			{
			references__elem_ = 0;
			goto end_of_references;
			}
		references__elem_ = new ReferenceWithData();
		int t_references__elem__size;
		t_references__elem__size = references__elem_->Parse(t_references__elem__dataptr, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		references_->push_back(references__elem_);
		t_references__elem__dataptr += t_references__elem__size;
		BINPAC_ASSERT(t_references__elem__dataptr <= t_end_of_data);
		references__elem_ = 0;
		}
end_of_references: ;
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_WriteFileRecordResponse__size;
	const_byteptr const t_dataptr_after_references = (t_begin_of_data + 1) + (t_references__size);
	BINPAC_ASSERT(t_dataptr_after_references <= t_end_of_data);
	t_WriteFileRecordResponse__size = t_dataptr_after_references - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_WriteFileRecordResponse(header(), this);
	BINPAC_ASSERT(t_begin_of_data + (t_WriteFileRecordResponse__size) <= t_end_of_data);
	return t_WriteFileRecordResponse__size;
	}

MaskWriteRegisterRequest::MaskWriteRegisterRequest(ModbusTCP_TransportHeader * header)
	{
	address_ = 0;
	and_mask_ = 0;
	or_mask_ = 0;
	header_ = header;
	byteorder_ = bigendian;
	deliver_ = 0;
	}

MaskWriteRegisterRequest::~MaskWriteRegisterRequest()
	{
	}

int MaskWriteRegisterRequest::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "MaskWriteRegisterRequest"
	if ( t_begin_of_data + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("MaskWriteRegisterRequest",
			(0) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "address"
	address_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "and_mask"
	and_mask_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "or_mask"
	or_mask_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_MaskWriteRegisterRequest(header(), this);
	BINPAC_ASSERT(t_begin_of_data + (6) <= t_end_of_data);
	return 6;
	}

MaskWriteRegisterResponse::MaskWriteRegisterResponse(ModbusTCP_TransportHeader * header)
	{
	address_ = 0;
	and_mask_ = 0;
	or_mask_ = 0;
	header_ = header;
	byteorder_ = bigendian;
	deliver_ = 0;
	}

MaskWriteRegisterResponse::~MaskWriteRegisterResponse()
	{
	}

int MaskWriteRegisterResponse::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "MaskWriteRegisterResponse"
	if ( t_begin_of_data + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("MaskWriteRegisterResponse",
			(0) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "address"
	address_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "and_mask"
	and_mask_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "or_mask"
	or_mask_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_MaskWriteRegisterResponse(header(), this);
	BINPAC_ASSERT(t_begin_of_data + (6) <= t_end_of_data);
	return 6;
	}

ReadWriteMultipleRegistersRequest::ReadWriteMultipleRegistersRequest(ModbusTCP_TransportHeader * header)
	{
	read_start_address_ = 0;
	read_quantity_ = 0;
	write_start_address_ = 0;
	write_quantity_ = 0;
	write_byte_count_ = 0;
	write_register_values_ = 0;
	write_register_values__elem_ = 0;
	header_ = header;
	byteorder_ = bigendian;
	deliver_ = 0;
	}

ReadWriteMultipleRegistersRequest::~ReadWriteMultipleRegistersRequest()
	{
	delete write_register_values_;
	}

int ReadWriteMultipleRegistersRequest::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "ReadWriteMultipleRegistersRequest:write_byte_count"
	if ( (t_begin_of_data + 8) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ReadWriteMultipleRegistersRequest:write_byte_count",
			(8) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "read_start_address"
	read_start_address_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "read_quantity"
	read_quantity_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "write_start_address"
	write_start_address_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "write_quantity"
	write_quantity_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 6))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "write_byte_count"
	write_byte_count_ = *((uint8 const *) ((t_begin_of_data + 8)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "write_register_values"
	int t_write_register_values__size;
	t_write_register_values__size = write_byte_count();
	// Checking out-of-bound for "ReadWriteMultipleRegistersRequest:write_register_values"
	if ( (t_begin_of_data + 9) + (t_write_register_values__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ReadWriteMultipleRegistersRequest:write_register_values",
			(9) + (t_write_register_values__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 9) + t_write_register_values__size;
	int t_write_register_values__arraylength;
	t_write_register_values__arraylength = 0;
	t_write_register_values__arraylength = write_quantity();
	if ( t_begin_of_data + t_write_register_values__arraylength > t_end_of_data + 1 )
		{
		t_write_register_values__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_write_register_values__arraylength < 0 )
		{
		t_write_register_values__arraylength = 0;
		}
	write_register_values__elem_ = 0;
	int t_write_register_values__elem__it;
	t_write_register_values__elem__it = 0;
	write_register_values_ = new vector<uint16>;
	write_register_values_->reserve(t_write_register_values__arraylength);
	const_byteptr t_write_register_values__elem__dataptr = (t_begin_of_data + 9);
	for (; t_write_register_values__elem__it < t_write_register_values__arraylength; ++t_write_register_values__elem__it)
		{
		// Check &until(write_register_values__elem__dataptr >= end_of_data)
		if ( t_write_register_values__elem__dataptr >= t_end_of_data )
			{
			goto end_of_write_register_values;
			}
		write_register_values__elem_ = FixByteOrder(byteorder(), *((uint16 const *) (t_write_register_values__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		write_register_values_->push_back(write_register_values__elem_);
		t_write_register_values__elem__dataptr += 2;
		BINPAC_ASSERT(t_write_register_values__elem__dataptr <= t_end_of_data);
		}
end_of_write_register_values: ;
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_ReadWriteMultipleRegistersRequest__size;
	const_byteptr const t_dataptr_after_write_register_values = (t_begin_of_data + 9) + (t_write_register_values__size);
	BINPAC_ASSERT(t_dataptr_after_write_register_values <= t_end_of_data);
	t_ReadWriteMultipleRegistersRequest__size = t_dataptr_after_write_register_values - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_ReadWriteMultipleRegistersRequest(header(), this);
	BINPAC_ASSERT(t_begin_of_data + (t_ReadWriteMultipleRegistersRequest__size) <= t_end_of_data);
	return t_ReadWriteMultipleRegistersRequest__size;
	}

ReadWriteMultipleRegistersResponse::ReadWriteMultipleRegistersResponse(ModbusTCP_TransportHeader * header)
	{
	byte_count_ = 0;
	registers_ = 0;
	registers__elem_ = 0;
	header_ = header;
	byteorder_ = bigendian;
	deliver_ = 0;
	}

ReadWriteMultipleRegistersResponse::~ReadWriteMultipleRegistersResponse()
	{
	delete registers_;
	}

int ReadWriteMultipleRegistersResponse::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "ReadWriteMultipleRegistersResponse:byte_count"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ReadWriteMultipleRegistersResponse:byte_count",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "byte_count"
	byte_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "registers"
	int t_registers__size;
	t_registers__size = byte_count();
	// Checking out-of-bound for "ReadWriteMultipleRegistersResponse:registers"
	if ( (t_begin_of_data + 1) + (t_registers__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ReadWriteMultipleRegistersResponse:registers",
			(1) + (t_registers__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 1) + t_registers__size;
	int t_registers__arraylength;
	t_registers__arraylength = 0;
	t_registers__arraylength = byte_count() / 2;
	if ( t_begin_of_data + t_registers__arraylength > t_end_of_data + 1 )
		{
		t_registers__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_registers__arraylength < 0 )
		{
		t_registers__arraylength = 0;
		}
	registers__elem_ = 0;
	int t_registers__elem__it;
	t_registers__elem__it = 0;
	registers_ = new vector<uint16>;
	registers_->reserve(t_registers__arraylength);
	const_byteptr t_registers__elem__dataptr = (t_begin_of_data + 1);
	for (; t_registers__elem__it < t_registers__arraylength; ++t_registers__elem__it)
		{
		// Check &until(registers__elem__dataptr >= end_of_data)
		if ( t_registers__elem__dataptr >= t_end_of_data )
			{
			goto end_of_registers;
			}
		registers__elem_ = FixByteOrder(byteorder(), *((uint16 const *) (t_registers__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		registers_->push_back(registers__elem_);
		t_registers__elem__dataptr += 2;
		BINPAC_ASSERT(t_registers__elem__dataptr <= t_end_of_data);
		}
end_of_registers: ;
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_ReadWriteMultipleRegistersResponse__size;
	const_byteptr const t_dataptr_after_registers = (t_begin_of_data + 1) + (t_registers__size);
	BINPAC_ASSERT(t_dataptr_after_registers <= t_end_of_data);
	t_ReadWriteMultipleRegistersResponse__size = t_dataptr_after_registers - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_ReadWriteMultipleRegistersResponse(header(), this);
	BINPAC_ASSERT(t_begin_of_data + (t_ReadWriteMultipleRegistersResponse__size) <= t_end_of_data);
	return t_ReadWriteMultipleRegistersResponse__size;
	}

ReadFIFOQueueRequest::ReadFIFOQueueRequest(ModbusTCP_TransportHeader * header)
	{
	start_address_ = 0;
	header_ = header;
	byteorder_ = bigendian;
	deliver_ = 0;
	}

ReadFIFOQueueRequest::~ReadFIFOQueueRequest()
	{
	}

int ReadFIFOQueueRequest::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "ReadFIFOQueueRequest"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ReadFIFOQueueRequest",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start_address"
	start_address_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_ReadFIFOQueueRequest(header(), this);
	BINPAC_ASSERT(t_begin_of_data + (2) <= t_end_of_data);
	return 2;
	}

ReadFIFOQueueResponse::ReadFIFOQueueResponse(ModbusTCP_TransportHeader * header)
	{
	byte_count_ = 0;
	fifo_count_ = 0;
	register_data_ = 0;
	register_data__elem_ = 0;
	header_ = header;
	byteorder_ = bigendian;
	deliver_ = 0;
	}

ReadFIFOQueueResponse::~ReadFIFOQueueResponse()
	{
	delete register_data_;
	}

int ReadFIFOQueueResponse::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context)
	{
	// Checking out-of-bound for "ReadFIFOQueueResponse:fifo_count"
	if ( (t_begin_of_data + 2) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ReadFIFOQueueResponse:fifo_count",
			(2) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "byte_count"
	byte_count_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "fifo_count"
	fifo_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "register_data"
	int t_register_data__size;
	t_register_data__size = fifo_count() * 2;
	// Checking out-of-bound for "ReadFIFOQueueResponse:register_data"
	if ( (t_begin_of_data + 4) + (t_register_data__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ReadFIFOQueueResponse:register_data",
			(4) + (t_register_data__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 4) + t_register_data__size;
	int t_register_data__arraylength;
	t_register_data__arraylength = 0;
	t_register_data__arraylength = fifo_count();
	if ( t_begin_of_data + t_register_data__arraylength > t_end_of_data + 1 )
		{
		t_register_data__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_register_data__arraylength < 0 )
		{
		t_register_data__arraylength = 0;
		}
	register_data__elem_ = 0;
	int t_register_data__elem__it;
	t_register_data__elem__it = 0;
	register_data_ = new vector<uint16>;
	register_data_->reserve(t_register_data__arraylength);
	const_byteptr t_register_data__elem__dataptr = (t_begin_of_data + 4);
	for (; t_register_data__elem__it < t_register_data__arraylength; ++t_register_data__elem__it)
		{
		// Check &until(register_data__elem__dataptr >= end_of_data)
		if ( t_register_data__elem__dataptr >= t_end_of_data )
			{
			goto end_of_register_data;
			}
		register_data__elem_ = FixByteOrder(byteorder(), *((uint16 const *) (t_register_data__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		register_data_->push_back(register_data__elem_);
		t_register_data__elem__dataptr += 2;
		BINPAC_ASSERT(t_register_data__elem__dataptr <= t_end_of_data);
		}
end_of_register_data: ;
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_ReadFIFOQueueResponse__size;
	const_byteptr const t_dataptr_after_register_data = (t_begin_of_data + 4) + (t_register_data__size);
	BINPAC_ASSERT(t_dataptr_after_register_data <= t_end_of_data);
	t_ReadFIFOQueueResponse__size = t_dataptr_after_register_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	deliver_ = t_context->flow()->deliver_ReadFIFOQueueResponse(header(), this);
	BINPAC_ASSERT(t_begin_of_data + (t_ReadFIFOQueueResponse__size) <= t_end_of_data);
	return t_ReadFIFOQueueResponse__size;
	}

ModbusTCP_Flow::ModbusTCP_Flow(ModbusTCP_Conn * connection, bool is_orig)
	{
	flow_buffer_ = 0;
	connection_ = connection;
	is_orig_ = is_orig;
	dataunit_ = 0;
	context_ = 0;
	flow_buffer_ = new FlowBuffer();
	}

ModbusTCP_Flow::~ModbusTCP_Flow()
	{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;
	delete flow_buffer_;
	flow_buffer_ = 0;
	}

void ModbusTCP_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		flow_buffer_->NewData(t_begin_of_data, t_end_of_data);
		while ( flow_buffer_->data_available() && 
			( !flow_buffer_->have_pending_request() || flow_buffer_->ready() ) )
			{
			if ( ! dataunit_ )
				{
				BINPAC_ASSERT(!context_);
				dataunit_ = new ModbusTCP_PDU(is_orig());
				flow_buffer_->NewFrame(0, false);
				context_ = new ContextModbusTCP(connection(), this, flow_buffer());
				}
			bool t_dataunit_parsing_complete;
			t_dataunit_parsing_complete = false;
			while ( ! t_dataunit_parsing_complete && flow_buffer_->ready() )
				{
				const_byteptr t_begin_of_data = flow_buffer()->begin();
				const_byteptr t_end_of_data = flow_buffer()->end();
				t_dataunit_parsing_complete = dataunit_->ParseBuffer(flow_buffer(), context_);
				if ( t_dataunit_parsing_complete )
					{
					// Evaluate 'let' and 'withinput' fields
					}
				}
			if ( t_dataunit_parsing_complete )
				{
				// Clean up the flow unit after parsing
				delete dataunit_;
				dataunit_ = 0;
				delete context_;
				context_ = 0;
				}
			else
				{
				// Resume upon next input segment
				BINPAC_ASSERT(!flow_buffer()->ready());
				break;
				}
			}
		}
	catch ( binpac::Exception const &e )
		{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		flow_buffer_->DiscardData();
		throw;
		}
	}

void ModbusTCP_Flow::NewGap(int gap_length)
	{
	flow_buffer_->NewGap(gap_length);
	}
void ModbusTCP_Flow::FlowEOF()
	{
	flow_buffer_->set_eof();
	NewData(0, 0);
	}
bool ModbusTCP_Flow::deliver_message(ModbusTCP_TransportHeader * header)
	{

		if ( ::modbus_message )
			{
			BifEvent::generate_modbus_message(connection()->bro_analyzer(),
			                                  connection()->bro_analyzer()->Conn(),
			                                  HeaderToBro(header),
			                                  is_orig());
			}

		return true;
		
	}

bool ModbusTCP_Flow::deliver_Exception(ModbusTCP_TransportHeader * header, Exception * message)
	{

		if ( ::modbus_exception )
			{
			BifEvent::generate_modbus_exception(connection()->bro_analyzer(),
			                                    connection()->bro_analyzer()->Conn(),
			                                    HeaderToBro(header),
			                                    message->code());
			}

		return true;
		
	}

bool ModbusTCP_Flow::deliver_ReadCoilsRequest(ModbusTCP_TransportHeader * header, ReadCoilsRequest * message)
	{

		if ( ::modbus_read_coils_request )
			{
			BifEvent::generate_modbus_read_coils_request(connection()->bro_analyzer(),
			                                             connection()->bro_analyzer()->Conn(),
			                                             HeaderToBro(header),
			                                             message->start_address(),
			                                             message->quantity());
			}

		return true;
		
	}

bool ModbusTCP_Flow::deliver_ReadCoilsResponse(ModbusTCP_TransportHeader * header, ReadCoilsResponse * message)
	{

		if ( ::modbus_read_coils_response )
			{
			BifEvent::generate_modbus_read_coils_response(connection()->bro_analyzer(),
			                                              connection()->bro_analyzer()->Conn(),
			                                              HeaderToBro(header),
			                                              bytestring_to_coils(message->bits(), message->bits().length()*8));
			}
		return true;
		
	}

bool ModbusTCP_Flow::deliver_ReadDiscreteInputsRequest(ModbusTCP_TransportHeader * header, ReadDiscreteInputsRequest * message)
	{

		if ( ::modbus_read_discrete_inputs_request )
			{
			BifEvent::generate_modbus_read_discrete_inputs_request(connection()->bro_analyzer(),
			                                                       connection()->bro_analyzer()->Conn(),
			                                                       HeaderToBro(header),
			                                                       message->start_address(), message->quantity());
			}

		return true;
		
	}

bool ModbusTCP_Flow::deliver_ReadDiscreteInputsResponse(ModbusTCP_TransportHeader * header, ReadDiscreteInputsResponse * message)
	{

		if ( ::modbus_read_discrete_inputs_response )
			{
			BifEvent::generate_modbus_read_discrete_inputs_response(connection()->bro_analyzer(),
			                                                        connection()->bro_analyzer()->Conn(),
			                                                        HeaderToBro(header),
			                                                        bytestring_to_coils(message->bits(), message->bits().length()*8));
			}

		return true;
		
	}

bool ModbusTCP_Flow::deliver_ReadHoldingRegistersRequest(ModbusTCP_TransportHeader * header, ReadHoldingRegistersRequest * message)
	{

		if ( ::modbus_read_holding_registers_request )
			{
			BifEvent::generate_modbus_read_holding_registers_request(connection()->bro_analyzer(),
			                                                         connection()->bro_analyzer()->Conn(),
			                                                         HeaderToBro(header),
			                                                         message->start_address(), message->quantity());
			}

		return true;
		
	}

bool ModbusTCP_Flow::deliver_ReadHoldingRegistersResponse(ModbusTCP_TransportHeader * header, ReadHoldingRegistersResponse * message)
	{

		if ( message->byte_count() % 2 != 0 )
			{
			connection()->bro_analyzer()->ProtocolViolation(
			    fmt("invalid value for modbus read holding register response byte count %d", message->byte_count()));
			return false;
			}

		if ( ::modbus_read_holding_registers_response )
			{

			VectorVal* t = new VectorVal(BifType::Vector::ModbusRegisters);
			for ( unsigned int i=0; i < message->registers()->size(); ++i )
				{
				Val* r = new Val((*(message->registers()))[i], TYPE_COUNT);
				t->Assign(i, r);
				}

			BifEvent::generate_modbus_read_holding_registers_response(connection()->bro_analyzer(),
			                                                          connection()->bro_analyzer()->Conn(),
			                                                          HeaderToBro(header),
			                                                          t);
			}

		return true;
		
	}

bool ModbusTCP_Flow::deliver_ReadInputRegistersRequest(ModbusTCP_TransportHeader * header, ReadInputRegistersRequest * message)
	{

		if ( ::modbus_read_input_registers_request )
			{
			BifEvent::generate_modbus_read_input_registers_request(connection()->bro_analyzer(),
			                                                       connection()->bro_analyzer()->Conn(),
			                                                       HeaderToBro(header),
			                                                       message->start_address(), message->quantity());
			}

		return true;
		
	}

bool ModbusTCP_Flow::deliver_ReadInputRegistersResponse(ModbusTCP_TransportHeader * header, ReadInputRegistersResponse * message)
	{

		if ( message->byte_count() % 2 != 0 )
			{
			connection()->bro_analyzer()->ProtocolViolation(
			    fmt("invalid value for modbus read input register response byte count %d", message->byte_count()));
			return false;
			}

		if ( ::modbus_read_input_registers_response )
			{
			VectorVal* t = new VectorVal(BifType::Vector::ModbusRegisters);
			for ( unsigned int i=0; i < (message->registers())->size(); ++i )
				{
				Val* r = new Val((*(message->registers()))[i], TYPE_COUNT);
				t->Assign(i, r);
				}

			BifEvent::generate_modbus_read_input_registers_response(connection()->bro_analyzer(),
			                                                        connection()->bro_analyzer()->Conn(),
			                                                        HeaderToBro(header),
			                                                        t);
			}

		return true;
		
	}

bool ModbusTCP_Flow::deliver_WriteSingleCoilRequest(ModbusTCP_TransportHeader * header, WriteSingleCoilRequest * message)
	{

		if ( ::modbus_write_single_coil_request )
			{
			int val;
			if ( message->value() == 0x0000 )
				val = 0;
			else if ( message->value() == 0xFF00 )
				val = 1;
			else
				{
				connection()->bro_analyzer()->ProtocolViolation(fmt("invalid value for modbus write single coil request %d",
				                                                    message->value()));
				return false;
				}

			BifEvent::generate_modbus_write_single_coil_request(connection()->bro_analyzer(),
			                                                    connection()->bro_analyzer()->Conn(),
			                                                    HeaderToBro(header),
			                                                    message->address(),
			                                                    val);
			}

		return true;
		
	}

bool ModbusTCP_Flow::deliver_WriteSingleCoilResponse(ModbusTCP_TransportHeader * header, WriteSingleCoilResponse * message)
	{

		if ( ::modbus_write_single_coil_response )
			{
			int val;
			if ( message->value() == 0x0000 )
				val = 0;
			else if ( message->value() == 0xFF00 )
				val = 1;
			else
				{
				connection()->bro_analyzer()->ProtocolViolation(fmt("invalid value for modbus write single coil response %d",
				                                                    message->value()));
				return false;
				}

			BifEvent::generate_modbus_write_single_coil_response(connection()->bro_analyzer(),
			                                                     connection()->bro_analyzer()->Conn(),
			                                                     HeaderToBro(header),
			                                                     message->address(),
			                                                     val);
			}

		return true;
		
	}

bool ModbusTCP_Flow::deliver_WriteSingleRegisterRequest(ModbusTCP_TransportHeader * header, WriteSingleRegisterRequest * message)
	{

		if ( ::modbus_write_single_register_request )
			{
			BifEvent::generate_modbus_write_single_register_request(connection()->bro_analyzer(),
			                                                        connection()->bro_analyzer()->Conn(),
			                                                        HeaderToBro(header),
			                                                        message->address(), message->value());
			}

		return true;
		
	}

bool ModbusTCP_Flow::deliver_WriteSingleRegisterResponse(ModbusTCP_TransportHeader * header, WriteSingleRegisterResponse * message)
	{

		if ( ::modbus_write_single_register_response )
			{
			BifEvent::generate_modbus_write_single_register_response(connection()->bro_analyzer(),
			                                                         connection()->bro_analyzer()->Conn(),
			                                                         HeaderToBro(header),
			                                                         message->address(), message->value());
			}

		return true;
		
	}

bool ModbusTCP_Flow::deliver_WriteMultipleCoilsRequest(ModbusTCP_TransportHeader * header, WriteMultipleCoilsRequest * message)
	{

		if ( ::modbus_write_multiple_coils_request )
			{
			BifEvent::generate_modbus_write_multiple_coils_request(connection()->bro_analyzer(),
			                                                       connection()->bro_analyzer()->Conn(),
			                                                       HeaderToBro(header),
			                                                       message->start_address(),
			                                                       bytestring_to_coils(message->coils(), message->quantity()));
			}

		return true;
		
	}

bool ModbusTCP_Flow::deliver_WriteMultipleCoilsResponse(ModbusTCP_TransportHeader * header, WriteMultipleCoilsResponse * message)
	{

		if ( ::modbus_write_multiple_coils_response )
			{
			BifEvent::generate_modbus_write_multiple_coils_response(connection()->bro_analyzer(),
			                                                        connection()->bro_analyzer()->Conn(),
			                                                        HeaderToBro(header),
			                                                        message->start_address(), message->quantity());
			}

		return true;
		
	}

bool ModbusTCP_Flow::deliver_WriteMultipleRegistersRequest(ModbusTCP_TransportHeader * header, WriteMultipleRegistersRequest * message)
	{

		if ( message->byte_count() % 2 != 0 )
			{
			connection()->bro_analyzer()->ProtocolViolation(
			    fmt("invalid value for modbus write multiple registers request byte count %d", message->byte_count()));
			return false;
			}

		if ( ::modbus_write_multiple_registers_request )
			{
			VectorVal * t = new VectorVal(BifType::Vector::ModbusRegisters);
			for ( unsigned int i = 0; i < (message->registers()->size()); ++i )
				{
				Val* r = new Val((*(message->registers()))[i], TYPE_COUNT);
				t->Assign(i, r);
				}

				BifEvent::generate_modbus_write_multiple_registers_request(connection()->bro_analyzer(),
				                                                           connection()->bro_analyzer()->Conn(),
				                                                           HeaderToBro(header),
				                                                           message->start_address(), t);
			}

		return true;
		
	}

bool ModbusTCP_Flow::deliver_WriteMultipleRegistersResponse(ModbusTCP_TransportHeader * header, WriteMultipleRegistersResponse * message)
	{

		if ( ::modbus_write_multiple_registers_response )
			{
			BifEvent::generate_modbus_write_multiple_registers_response(connection()->bro_analyzer(),
			                                                            connection()->bro_analyzer()->Conn(),
			                                                            HeaderToBro(header),
			                                                            message->start_address(), message->quantity());
			}

		return true;
		
	}

bool ModbusTCP_Flow::deliver_ReadFileRecordRequest(ModbusTCP_TransportHeader * header, ReadFileRecordRequest * message)
	{

		if ( ::modbus_read_file_record_request )
			{
			//TODO: this need to be a vector of some Reference Request record type
			//VectorVal *t = create_vector_of_count();
			//for ( unsigned int i = 0; i < (${message.references}->size()); ++i )
			//	{
			//	Val* r = new Val((${message.references[i].ref_type}), TYPE_COUNT);
			//	t->Assign(i, r);
			//
			//	Val* k = new Val((${message.references[i].file_num}), TYPE_COUNT);
			//	t->Assign(i, k);
			//
			//	Val* l = new Val((${message.references[i].record_num}), TYPE_COUNT);
			//	t->Assign(i, l);
			//	}

			BifEvent::generate_modbus_read_file_record_request(connection()->bro_analyzer(),
			                                                   connection()->bro_analyzer()->Conn(),
			                                                   HeaderToBro(header));
			}

		return true;
		
	}

bool ModbusTCP_Flow::deliver_ReadFileRecordResponse(ModbusTCP_TransportHeader * header, ReadFileRecordResponse * message)
	{

		if ( ::modbus_read_file_record_response )
			{
			//VectorVal *t = create_vector_of_count();
			//for ( unsigned int i = 0; i < ${message.references}->size(); ++i )
			//	{
			//	//TODO: work the reference type in here somewhere
			//	Val* r = new Val(${message.references[i].record_data}), TYPE_COUNT);
			//	t->Assign(i, r);
			//	}

			BifEvent::generate_modbus_read_file_record_response(connection()->bro_analyzer(),
			                                                    connection()->bro_analyzer()->Conn(),
			                                                    HeaderToBro(header));
			}

		return true;
		
	}

bool ModbusTCP_Flow::deliver_WriteFileRecordRequest(ModbusTCP_TransportHeader * header, WriteFileRecordRequest * message)
	{

		if ( ::modbus_write_file_record_request )
			{
			//VectorVal* t = create_vector_of_count();
			//for ( unsigned int i = 0; i < (${message.references}->size()); ++i )
			//	{
			//	Val* r = new Val((${message.references[i].ref_type}), TYPE_COUNT);
			//	t->Assign(i, r);
			//
			//	Val* k = new Val((${message.references[i].file_num}), TYPE_COUNT);
			//	t->Assign(i, k);
			//
			//	Val* n = new Val((${message.references[i].record_num}), TYPE_COUNT);
			//	t->Assign(i, n);
			//
			//	for ( unsigned int j = 0; j < (${message.references[i].register_value}->size()); ++j )
			//		{
			//		k = new Val((${message.references[i].register_value[j]}), TYPE_COUNT);
			//		t->Assign(i, k);
			//		}
			//	}

			BifEvent::generate_modbus_write_file_record_request(connection()->bro_analyzer(),
			                                                    connection()->bro_analyzer()->Conn(),
			                                                    HeaderToBro(header));
			}

		return true;
		
	}

bool ModbusTCP_Flow::deliver_WriteFileRecordResponse(ModbusTCP_TransportHeader * header, WriteFileRecordResponse * message)
	{

		if ( ::modbus_write_file_record_response )
			{
			//VectorVal* t = create_vector_of_count();
			//for ( unsigned int i = 0; i < (${messages.references}->size()); ++i )
			//	{
			//	Val* r = new Val((${message.references[i].ref_type}), TYPE_COUNT);
			//	t->Assign(i, r);
			//
			//	Val* f = new Val((${message.references[i].file_num}), TYPE_COUNT);
			//	t->Assign(i, f);
			//
			//	Val* rn = new Val((${message.references[i].record_num}), TYPE_COUNT);
			//	t->Assign(i, rn);
			//
			//	for ( unsigned int j = 0; j<(${message.references[i].register_value}->size()); ++j )
			//		{
			//		Val* k = new Val((${message.references[i].register_value[j]}), TYPE_COUNT);
			//		t->Assign(i, k);
			//		}

			BifEvent::generate_modbus_write_file_record_response(connection()->bro_analyzer(),
			                                                     connection()->bro_analyzer()->Conn(),
			                                                     HeaderToBro(header));
			}

		return true;
		
	}

bool ModbusTCP_Flow::deliver_MaskWriteRegisterRequest(ModbusTCP_TransportHeader * header, MaskWriteRegisterRequest * message)
	{

		if ( ::modbus_mask_write_register_request )
			{
			BifEvent::generate_modbus_mask_write_register_request(connection()->bro_analyzer(),
			                                                      connection()->bro_analyzer()->Conn(),
			                                                      HeaderToBro(header),
			                                                      message->address(),
			                                                      message->and_mask(), message->or_mask());
			}

		return true;
		
	}

bool ModbusTCP_Flow::deliver_MaskWriteRegisterResponse(ModbusTCP_TransportHeader * header, MaskWriteRegisterResponse * message)
	{

		if ( ::modbus_mask_write_register_response )
			{
			BifEvent::generate_modbus_mask_write_register_response(connection()->bro_analyzer(),
			                                                       connection()->bro_analyzer()->Conn(),
			                                                       HeaderToBro(header),
			                                                       message->address(),
			                                                       message->and_mask(), message->or_mask());
			}

		return true;
		
	}

bool ModbusTCP_Flow::deliver_ReadWriteMultipleRegistersRequest(ModbusTCP_TransportHeader * header, ReadWriteMultipleRegistersRequest * message)
	{

		if ( message->write_byte_count() % 2 != 0 )
			{
			connection()->bro_analyzer()->ProtocolViolation(
			    fmt("invalid value for modbus read write multiple registers request write byte count %d", message->write_byte_count()));
			return false;
			}

		if ( ::modbus_read_write_multiple_registers_request )
			{
			VectorVal* t = new VectorVal(BifType::Vector::ModbusRegisters);
			for ( unsigned int i = 0; i < message->write_register_values()->size(); ++i )
				{
				Val* r = new Val((*(message->write_register_values()))[i], TYPE_COUNT);
				t->Assign(i, r);
				}

			BifEvent::generate_modbus_read_write_multiple_registers_request(connection()->bro_analyzer(),
			                                                                connection()->bro_analyzer()->Conn(),
			                                                                HeaderToBro(header),
			                                                                message->read_start_address(),
			                                                                message->read_quantity(),
			                                                                message->write_start_address(),
			                                                                t);
			}

		return true;
		
	}

bool ModbusTCP_Flow::deliver_ReadWriteMultipleRegistersResponse(ModbusTCP_TransportHeader * header, ReadWriteMultipleRegistersResponse * message)
	{

		if ( message->byte_count() % 2 != 0 )
			{
			connection()->bro_analyzer()->ProtocolViolation(
			    fmt("invalid value for modbus read write multiple registers response byte count %d", message->byte_count()));
			return false;
			}

		if ( ::modbus_read_write_multiple_registers_response )
			{
			VectorVal* t = new VectorVal(BifType::Vector::ModbusRegisters);
			for ( unsigned int i = 0; i < message->registers()->size(); ++i )
				{
				Val* r = new Val((*(message->registers()))[i], TYPE_COUNT);
				t->Assign(i, r);
				}

			BifEvent::generate_modbus_read_write_multiple_registers_response(connection()->bro_analyzer(),
			                                                                 connection()->bro_analyzer()->Conn(),
			                                                                 HeaderToBro(header),
			                                                                 t);
			}

		return true;
		
	}

bool ModbusTCP_Flow::deliver_ReadFIFOQueueRequest(ModbusTCP_TransportHeader * header, ReadFIFOQueueRequest * message)
	{

		if ( ::modbus_read_fifo_queue_request )
			{
			BifEvent::generate_modbus_read_fifo_queue_request(connection()->bro_analyzer(),
			                                                  connection()->bro_analyzer()->Conn(),
			                                                  HeaderToBro(header),
			                                                  message->start_address());
			}

		return true;
		
	}

bool ModbusTCP_Flow::deliver_ReadFIFOQueueResponse(ModbusTCP_TransportHeader * header, ReadFIFOQueueResponse * message)
	{

		if ( message->byte_count() % 2 != 0 )
			{
			connection()->bro_analyzer()->ProtocolViolation(
			    fmt("invalid value for modbus read FIFO queue response byte count %d", message->byte_count()));
			return false;
			}

		if ( ::modbus_read_fifo_queue_response )
			{
			VectorVal* t = create_vector_of_count();
			for ( unsigned int i = 0; i < (message->register_data())->size(); ++i )
				{
				Val* r = new Val((*(message->register_data()))[i], TYPE_COUNT);
				t->Assign(i, r);
				}

			BifEvent::generate_modbus_read_fifo_queue_response(connection()->bro_analyzer(),
			                                                   connection()->bro_analyzer()->Conn(),
			                                                   HeaderToBro(header),
			                                                   t);
			}

		return true;
		
	}


	VectorVal* bytestring_to_coils(bytestring coils, uint quantity)
		{
		VectorVal* modbus_coils = new VectorVal(BifType::Vector::ModbusCoils);

		return modbus_coils;
		}

	RecordVal* HeaderToBro(ModbusTCP_TransportHeader *header)
		{
		RecordVal* modbus_header = new RecordVal(BifType::Record::ModbusHeaders);
		modbus_header->Assign(0, new Val(header->tid(), TYPE_COUNT));
		modbus_header->Assign(1, new Val(header->pid(), TYPE_COUNT));
		modbus_header->Assign(2, new Val(header->uid(), TYPE_COUNT));
		modbus_header->Assign(3, new Val(header->fc(), TYPE_COUNT));
		return modbus_header;
		}

	VectorVal* create_vector_of_count()
		{
		VectorType* vt = new VectorType(base_type(TYPE_COUNT));
		VectorVal* vv = new VectorVal(vt);
		Unref(vt);
		return vv;
		}

	
} // namespace ModbusTCP
}  // namespace binpac

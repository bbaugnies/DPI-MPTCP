
\chapter{Section Recap} \label{chap:recap}

The three previous chapters describe how we have implemented and tested a first method of MPTCP traffic analysis. To do so, we have acted upon Bro's TCP analyzer to have it produce MPTCP-related events. These events correspond to the different kinds of option sub-types used by MPTCP. We then wrote scripts that used our new events in order to detect and log MPTCP behavior over the network. These scripts include connection logging and the detection of certain anomalies that might occur in the protocol's operation. \\ However, this solution presents certain issues which we will address.\\

A first problem is that MPTCP hosts exchange and compute information through cryptographic functions. The session tokens, for example, are obtained by hashing the exchanged keys while the authentication of Joins is done via a keyed-hash. As we were unable to find any cryptographic libraries implemented for Bro's scripting language, performing these computations would be difficult in the current situation. Since \texttt{mp\_capable} events only transmit the keys to the script layer, it is hard to find the associated token. This hints at the fact that the cryptographic operations that we need to re-perform in Bro should be done within the Engine.\\

More importantly, however, the current solution does not allow the Bro Engine to observe any links between different sub-flows. This causes a number of problems that render the solution incapable of performing certain important tasks, chiefly, reassembly. As mentioned in chapter \ref{chap:bro}, Bro passes the packets of a given connection through a hierarchy of protocol analyzers in order to understand all the behavior taking place in it. While the TCP analyzer can essentially make do with the packet header, certain protocol analyzers need to observe the data stream that is exchanged. In order to do this, Bro is capable of reassembling an out-of-order TCP stream in order to pass it along the the child-analyzers so that they can work on a coherent stream. Since Bro's Engine still considers sub-flows as independent streams, the child analyzers will only receive part of the data and will, in most cases, be unable to perform their tasks.\\

Therefore, simply adding MPTCP-related events to the engine is not sufficient. This solution only allows us to detect the behavior of MPTCP, but gives us no information on the data that it is being used to send. Though we could potentially perform this reassembly in script, it is simply too late; the reassembled stream cannot be passed back to the Engine to have the child analyzers work on it. \\

To cope with this issue, the following chapters will describe the requirements that must be met in order to allow Bro to perform the reassembly of MPTCP traffic within its Engine, in order to pass the reassembled stream to the subsequent analyzers.
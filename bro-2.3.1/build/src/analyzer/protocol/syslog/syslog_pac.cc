// This file is automatically generated from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/syslog/syslog.pac.


#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include "/home/benjamin/Bro/bro-2.3.1/build/src/analyzer/protocol/syslog/syslog_pac.h"

namespace binpac {






namespace Syslog {
ContextSyslog::ContextSyslog(Syslog_Conn * connection, Syslog_Flow * flow)
	{
	connection_ = connection;
	flow_ = flow;
	}

ContextSyslog::~ContextSyslog()
	{
	}

Syslog_Message::Syslog_Message()
	{
	PRI_ = 0;
	byteorder_ = littleendian;
	proc_syslog_message_ = 0;
	}

Syslog_Message::~Syslog_Message()
	{
	delete PRI_;
	PRI_ = 0;
	msg_.free();
	}

int Syslog_Message::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSyslog * t_context)
	{
	// Parse "PRI"
	PRI_ = new Syslog_Priority();
	int t_PRI__size;
	t_PRI__size = PRI_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_PRI = t_begin_of_data + (t_PRI__size);
	BINPAC_ASSERT(t_dataptr_after_PRI <= t_end_of_data);
	// Parse "msg"
	int t_msg_string_length;
	t_msg_string_length = (t_end_of_data) - (t_dataptr_after_PRI);
	int t_msg__size;
	t_msg__size = t_msg_string_length;
	// check for negative sizes
	if ( t_msg_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/syslog/syslog-protocol.pac:3", t_msg_string_length);
	msg_.init(t_dataptr_after_PRI, t_msg_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_Syslog_Message__size;
	const_byteptr const t_dataptr_after_msg = t_dataptr_after_PRI + (t_msg__size);
	BINPAC_ASSERT(t_dataptr_after_msg <= t_end_of_data);
	t_Syslog_Message__size = t_dataptr_after_msg - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_syslog_message_ = t_context->flow()->process_syslog_message(this);
	BINPAC_ASSERT(t_begin_of_data + (t_Syslog_Message__size) <= t_end_of_data);
	return t_Syslog_Message__size;
	}

RegExMatcher Syslog_Priority_re_001("[[:digit:]]+");

Syslog_Priority::Syslog_Priority()
	{
	lt_ = 0;
	gt_ = 0;
	val_length_ = 0;
	int_val_ = 0;
	severity_ = 0;
	facility_ = 0;
	}

Syslog_Priority::~Syslog_Priority()
	{
	val_.free();
	}

int Syslog_Priority::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Syslog_Priority:lt"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Syslog_Priority:lt",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "lt"
	lt_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "val"
	int t_val_string_length;
	t_val_string_length = 
		Syslog_Priority_re_001.MatchPrefix(
			(t_begin_of_data + 1),
			t_end_of_data - (t_begin_of_data + 1));
	if ( t_val_string_length < 0 )
		{
		throw binpac::ExceptionStringMismatch("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/syslog/syslog-protocol.pac:8", "[[:digit:]]+", string((const char *) ((t_begin_of_data + 1)), (const char *) t_end_of_data).c_str());
		}
	int t_val__size;
	t_val__size = t_val_string_length;
	// check for negative sizes
	if ( t_val_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/syslog/syslog-protocol.pac:8", t_val_string_length);
	val_.init((t_begin_of_data + 1), t_val_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_val = (t_begin_of_data + 1) + (t_val__size);
	BINPAC_ASSERT(t_dataptr_after_val <= t_end_of_data);
	// Checking out-of-bound for "Syslog_Priority:gt"
	if ( t_dataptr_after_val + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Syslog_Priority:gt",
			((t_dataptr_after_val - t_begin_of_data)) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "gt"
	gt_ = *((uint8 const *) (t_dataptr_after_val));
	// Evaluate 'let' and 'withinput' fields
	
	int t_Syslog_Priority__size;
	t_Syslog_Priority__size = (t_dataptr_after_val + 1) - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	val_length_ = (t_dataptr_after_val - (t_begin_of_data + 1)) - 1;
	int_val_ = bytestring_to_int(val(), 10);
	severity_ =  ( int_val() & 0x07 ) ;
	facility_ =  ( int_val() & 0x03f8 )  >> 3;
	BINPAC_ASSERT(t_begin_of_data + (t_Syslog_Priority__size) <= t_end_of_data);
	return t_Syslog_Priority__size;
	}

Syslog_Conn::Syslog_Conn(BroAnalyzer const & bro_analyzer)
	{
	upflow_ = new Syslog_Flow(this);
	downflow_ = new Syslog_Flow(this);
	bro_analyzer_ = bro_analyzer;
	}

Syslog_Conn::~Syslog_Conn()
	{
	delete upflow_;
	upflow_ = 0;
	delete downflow_;
	downflow_ = 0;
	}

void Syslog_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void Syslog_Conn::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void Syslog_Conn::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

Syslog_Flow::Syslog_Flow(Syslog_Conn * connection)
	{
	connection_ = connection;
	dataunit_ = 0;
	context_ = 0;
	}

Syslog_Flow::~Syslog_Flow()
	{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;
	}

void Syslog_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		dataunit_ = new Syslog_Message();
		context_ = new ContextSyslog(connection(), this);
		int t_dataunit__size;
		t_dataunit__size = dataunit_->Parse(t_begin_of_data, t_end_of_data, context_);
		// Evaluate 'let' and 'withinput' fields
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		}
	catch ( binpac::Exception const &e )
		{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		throw;
		}
	}

void Syslog_Flow::NewGap(int gap_length)
	{
	}
void Syslog_Flow::FlowEOF()
	{
	}
bool Syslog_Flow::process_syslog_message(Syslog_Message * m)
	{

		BifEvent::generate_syslog_message(connection()->bro_analyzer(),
		                                  connection()->bro_analyzer()->Conn(),
		                                  m->PRI()->facility(),
		                                  m->PRI()->severity(),
		                                  new StringVal(m->msg().length(), (const char*) m->msg().begin())
		                                  );
		return true;
		
	}

} // namespace Syslog
}  // namespace binpac




\chapter{Further Considerations} \label{chap:further}
We have now concluded the discussion of what has been implemented, as well as what would be required for MPTCP stream reassembly. This chapter will discuss what can still be done on the subject in the future. These may include improvements upon existing mechanisms, additional detection schemes, or even entirely new features.

\section{Implementation of the Reassembly Mechanisms}
With a good grasp of how internal reassembly should be implemented, it still remains to be done in practice. The source code pertaining to this thesis available on Github makes some attempts at implementing the first mechanisms. Namely, we have modified the \texttt{Sessions.cc} manager in order to perform subflow matching in the Engine, and redirect multiple subflows to the same Conn. However, the computation of the tokens was imperfect leading to a failure to match Join attempts to the correct MPTCP connection. \\ 

Examination of the MPTCP source code indicates that the computation of the tokens is done using the Linux Kernel cryptohash implementation of SHA-1 which only includes low-level hashing functions (no automatic padding, only 512 bit blocks). Since Bro already makes use of the OpenSSL library, we attempted to use it as well for the tokens, but we were unable to obtain the same results. Since SHA-1 is a standardized algorithm, we have no doubt this is simply due to an issue of getting the right message to hash. Nonetheless, the implementation was tested with a modified packet trace in which the Join tokens were replaced by those we did obtain.

\section{Re-Implementing/Adding Higher-level Events and Redesigning Scripts}
The last section of this thesis concentrated exclusively on reassembly in order to analyze the application layer protocols. The analysis of MPTCP behavior itself has therefore been neglected, and as we mentioned in section \ref{sec:interf}, some scripts from the first implementation were even rendered unusable. While reassembly is definitely crucial to performing true deep packet inspection (actually understanding the MPTCP payload), it still remains useful to gather data about the protocol's operation itself. \\

Since a number of events will no longer behave as intended given the lack of Conn distinction, it will be necessary to re-implement a number of events to bring them back to their specification. In addition, we can capitalize on the fact that a large portion of the work which was previously done in script (subflow matching and maintenance of the MPTCP connection list)is no done in the Engine. This enables us to provide events of a much higher-level. These new events would enable us to, for example, perform a more precise MPTCP connection logging with drastically simplified scripts.\\

Of course, once the final event set is decided upon and implemented, existing scripts may be reworked to take advantage of them. New scripts may also be implemented to detect additional odd behavior

\section{Increased Discrimination Between MPTCP Connections}
As we have stated in chapter \ref{chap:reassembly}, we consider the use of tokens to be sufficient to uniquely identify MPTCP connections. We know that a given host may not select keys that hash to the same token for multiple simultaneous connections. However, this guarantee does not hold when we are observing traffic to and from multiple hosts. This could potentially lead to token collisions. Given that we use tokens as keys to look up the MPTCP connection, two Joins from different hosts using the same token would end up being processed together. The tokens are 32 bits long. Obviously, over the global internet, this is not sufficient to avoid collisions. An instance of Bro is unlikely to cover the entire internet, however, so the probability of finding colliding tokens is directly dependent on how large the monitored network is. The Birthday Paradox tells us that the probability of collision remains under 1\% with over 9000 hosts each picking one token. Whether this is sufficient will depend both on the security needs and the deployment scale. \\

In order to further reduce the probability of collision, it would be possible to combine the token-based subflow matching with an analysis of address advertisement (both explicit and implicit) similar to what was done in the connection logging script. In this case, we would only experience a collision if two pairs of hosts managed to pick the same tokens while at the same time using the same addresses and port numbers. \\

This solution is not without its own issues, however. By using the address advertisements as a criteria for the matching of a subflow, we expose ourselves to the risk of missing one such  advertisement. This would result in correct subflows being unable to match to their parent connection. Ultimately, we may find a use for a compromise. We could, for example, store the address advertisement information, but only use it if a potential token collision is detected.


\section{Partial View Reassembly}
For regular TCP, the reassemblers will not deliver any data that would start with a gap. If the connection continues to exchange data until the maximum sending window is exceeded, Bro will raise an error. This indicates that either Bro missed a packet that still made it through to its destination, or that one of the hosts is not respecting the established parameters. In either case, this is not supposed to happen. \\

If we add MPTCP, however, then there are legitimate situations where this may occur. The simplest case is if Bro has an incomplete view of the network. In this event, two MPTCP hosts might have established a subflow visible to Bro, and another one who's path does not go through the IDS. Bro's reassemblers will be stuck waiting for data that it will never see, while both hosts carry on with the connection without any problems.\\

From a security point of view, installing an IDS with an incomplete view of the network is a sign of poor design. It should be placed at a choke-point without any traffic being able to go around it. If, for whatever reason, this is not possible or not desirable, we may still want Bro to be able to run as much analysis as possible on the datastream. For this reason, it may be interesting to include mechanisms for delivering reassembled datastreams with missing byte. This could be done when the maximum sending window has been reached but more traffic is still arriving. It is entirely possible that the subsequent analyzers' task will be compromised, but some may yet provide interesting insight.
// This file was automatically generated by bifcl from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/netbios/functions.bif (plugin mode).


#include "functions.bif.h"


#line 9 "functions.bif"
Val* BifFunc::bro_decode_netbios_name(Frame* frame, val_list* BiF_ARGS)
	
#line 10 "functions.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("decode_netbios_name() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* name = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 10 "functions.bif"

	char buf[16];
	char result[16];
	const u_char* s = name->Bytes();
	int i, j;

	for ( i = 0, j = 0; i < 16; ++i )
		{
		char c0 = (j < name->Len()) ? toupper(s[j++]) : 'A';
		char c1 = (j < name->Len()) ? toupper(s[j++]) : 'A';
		buf[i] = ((c0 - 'A') << 4) + (c1 - 'A');
		}

	for ( i = 0; i < 15; ++i )
		{
		if ( isalnum(buf[i]) || ispunct(buf[i]) ||
		     // \x01\x02 is seen in at least one case as the first two bytes.
		     // I think that any \x01 and \x02 should always be passed through.
		     buf[i] < 3 )
			result[i] = buf[i];
		else
			break;
		}

	return new StringVal(i, result);
	} // end of BifFunc::bro_decode_netbios_name

#line 35 "functions.bif"

#line 45 "functions.bif"
Val* BifFunc::bro_decode_netbios_name_type(Frame* frame, val_list* BiF_ARGS)
	
#line 46 "functions.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("decode_netbios_name_type() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* name = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 46 "functions.bif"

	const u_char* s = name->Bytes();
	char return_val = ((toupper(s[30]) - 'A') << 4) + (toupper(s[31]) - 'A');
	return new Val(return_val, TYPE_COUNT);
	} // end of BifFunc::bro_decode_netbios_name_type

#line 50 "functions.bif"

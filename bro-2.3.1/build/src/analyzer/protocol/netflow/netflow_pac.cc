// This file is automatically generated from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/netflow/netflow.pac.


#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include "/home/benjamin/Bro/bro-2.3.1/build/src/analyzer/protocol/netflow/netflow_pac.h"

namespace binpac {


namespace NetFlow {
ContextNetFlow::ContextNetFlow(NetFlow_Analyzer * analyzer, NetFlow_Flow * flow)
	{
	analyzer_ = analyzer;
	flow_ = flow;
	}

ContextNetFlow::~ContextNetFlow()
	{
	}

NetFlow_Analyzer::NetFlow_Analyzer()
	{
	downflow_ = new NetFlow_Flow(this);
	upflow_ = new NetFlow_Flow(this);
	}

NetFlow_Analyzer::~NetFlow_Analyzer()
	{
	delete downflow_;
	downflow_ = 0;
	delete upflow_;
	upflow_ = 0;
	}

void NetFlow_Analyzer::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void NetFlow_Analyzer::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void NetFlow_Analyzer::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

NetFlow_Flow::NetFlow_Flow(NetFlow_Analyzer * connection)
	{
	connection_ = connection;

		nf_v5_header_type =
			internal_type("nf_v5_header")->AsRecordType();
		nf_v5_record_type =
			internal_type("nf_v5_record")->AsRecordType();
		nfheader_id_type =
			internal_type("nfheader_id")->AsRecordType();
		identifier = NULL;
		exporter_ip = 0;
		uptime = 0;
		export_time = 0;
		pdu_id = 0;
	
	dataunit_ = 0;
	context_ = 0;
	}

NetFlow_Flow::~NetFlow_Flow()
	{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;
	}

void NetFlow_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		dataunit_ = new NetFlowPacket();
		context_ = new ContextNetFlow(connection(), this);
		int t_dataunit__size;
		t_dataunit__size = dataunit_->Parse(t_begin_of_data, t_end_of_data, context_);
		// Evaluate 'let' and 'withinput' fields
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		}
	catch ( binpac::Exception const &e )
		{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		throw;
		}
	}

void NetFlow_Flow::NewGap(int gap_length)
	{
	}
void NetFlow_Flow::FlowEOF()
	{
	}
bool NetFlow_Flow::set_exporter_ip(uint32 exporter_ip)
	{

		this->exporter_ip = exporter_ip;
		return true;
		
	}

bool NetFlow_Flow::set_identifier(const_charptr const & idf)
	{

		if ( identifier )
			delete[] identifier;
		identifier = new char[strlen(idf) + 1];
		strcpy(identifier, idf);
		return true;
		
	}

bool NetFlow_Flow::deliver_v5_header(uint16 count, uint32 sysuptime, uint32 unix_secs, uint32 unix_nsecs, uint32 flow_seq, uint8 eng_type, uint8 eng_id, uint16 sample_int)
	{

		uptime = sysuptime;
		export_time = unix_secs + unix_nsecs / 1e9;
		++pdu_id;

		if ( ! ::netflow_v5_header )
			return false;

		RecordVal* nfheader = new RecordVal(nfheader_id_type);
		nfheader->Assign(0, new StringVal(identifier));
		nfheader->Assign(1, new Val(pdu_id, TYPE_COUNT));

		RecordVal* v5header = new RecordVal(nf_v5_header_type);
		v5header->Assign(0, nfheader);
		v5header->Assign(1, new Val(count, TYPE_COUNT));
		v5header->Assign(2, new IntervalVal(sysuptime, Milliseconds));
		v5header->Assign(3, new Val(export_time, TYPE_TIME));
		v5header->Assign(4, new Val(flow_seq, TYPE_COUNT));
		v5header->Assign(5, new Val(eng_type, TYPE_COUNT));
		v5header->Assign(6, new Val(eng_id, TYPE_COUNT));
		v5header->Assign(7, new Val(sample_int, TYPE_COUNT));
		v5header->Assign(8, new AddrVal(exporter_ip));

		val_list* vl = new val_list;
		vl->append(v5header);
		mgr.QueueEvent(netflow_v5_header, vl);

		return true;
		
	}

bool NetFlow_Flow::deliver_v5_record(uint32 srcaddr, uint32 dstaddr, uint32 nexthop, uint16 input, uint16 output, uint32 dPkts, uint32 dOctets, uint32 first, uint32 last, uint16 srcport, uint16 dstport, uint8 tcp_flags, uint8 prot, uint8 tos, uint16 src_as, uint16 dst_as, uint8 src_mask, uint8 dst_mask)
	{

		if ( ! ::netflow_v5_record )
			return false;

		TransportProto proto = TRANSPORT_UNKNOWN;
		switch ( prot ) {
		case 1: proto = TRANSPORT_ICMP; break;
		case 6: proto = TRANSPORT_TCP; break;
		case 17: proto = TRANSPORT_UDP; break;
		}

		RecordVal* connid = new RecordVal(conn_id);
		connid->Assign(0, new AddrVal(htonl(srcaddr)));
		connid->Assign(1, new PortVal(srcport, proto));
		connid->Assign(2, new AddrVal(htonl(dstaddr)));
		connid->Assign(3, new PortVal(dstport, proto));

		RecordVal* nfheader = new RecordVal(nfheader_id_type);
		nfheader->Assign(0, new StringVal(identifier));
		nfheader->Assign(1, new Val(pdu_id, TYPE_COUNT));

		RecordVal* v5record = new RecordVal(nf_v5_record_type);
		v5record->Assign(0, nfheader);
		v5record->Assign(1, connid);
		v5record->Assign(2, new AddrVal(htonl(nexthop)));
		v5record->Assign(3, new Val(input, TYPE_COUNT));
		v5record->Assign(4, new Val(output, TYPE_COUNT));
		v5record->Assign(5, new Val(dPkts, TYPE_COUNT));
		v5record->Assign(6, new Val(dOctets, TYPE_COUNT));

		// Overflows are handled correctly by using 32 bit
		// unsigned integer arithmetic.
		double c_first = export_time - (uptime - first) * Milliseconds;
		double c_last = export_time - (uptime - last) * Milliseconds;
		v5record->Assign(7, new Val(c_first, TYPE_TIME));
		v5record->Assign(8, new Val(c_last, TYPE_TIME));

		v5record->Assign(9,
			new Val((tcp_flags & TH_FIN) != 0, TYPE_BOOL));
		v5record->Assign(10,
			new Val((tcp_flags & TH_SYN) != 0, TYPE_BOOL));
		v5record->Assign(11,
			new Val((tcp_flags & TH_RST) != 0, TYPE_BOOL));
		v5record->Assign(12,
			new Val((tcp_flags & TH_PUSH) != 0, TYPE_BOOL));
		v5record->Assign(13,
			new Val((tcp_flags & TH_ACK) != 0, TYPE_BOOL));
		v5record->Assign(14,
			new Val((tcp_flags & TH_URG) != 0, TYPE_BOOL));

		v5record->Assign(15, new Val(prot, TYPE_COUNT));
		v5record->Assign(16, new Val(tos, TYPE_COUNT));
		v5record->Assign(17, new Val(src_as, TYPE_COUNT));
		v5record->Assign(18, new Val(dst_as, TYPE_COUNT));
		v5record->Assign(19, new Val(src_mask, TYPE_COUNT));
		v5record->Assign(20, new Val(dst_mask, TYPE_COUNT));

		val_list* vl = new val_list;
		vl->append(v5record);
		mgr.QueueEvent(netflow_v5_record, vl);

		return true;
		
	}

NetFlowPacket::NetFlowPacket()
	{
	version_ = 0;
	count_ = 0;
	header_ = 0;
	records_ = 0;
	records__elem_ = 0;
	byteorder_ = bigendian;
	}

NetFlowPacket::~NetFlowPacket()
	{
	delete header_;
	header_ = 0;
	delete records__elem_;
	records__elem_ = 0;
	if ( records() )
		{
		for ( int i = 0; i < (int) records()->size(); ++i )
			{
			NFRecord * records__elem_ = (*records_)[i];
			delete records__elem_;
			records__elem_ = 0;
			}
		}
	delete records_;
	}

int NetFlowPacket::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextNetFlow * t_context)
	{
	// Checking out-of-bound for "NetFlowPacket:count"
	if ( (t_begin_of_data + 2) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NetFlowPacket:count",
			(2) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "version"
	version_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "count"
	count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "header"
	header_ = new NFHeader(version(), count());
	int t_header__size;
	t_header__size = header_->Parse((t_begin_of_data + 4), t_end_of_data, t_context, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_header = (t_begin_of_data + 4) + (t_header__size);
	BINPAC_ASSERT(t_dataptr_after_header <= t_end_of_data);
	// Parse "records"
	int t_records__arraylength;
	t_records__arraylength = 0;
	t_records__arraylength = count();
	if ( t_begin_of_data + t_records__arraylength > t_end_of_data + 1 )
		{
		t_records__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_records__arraylength < 0 )
		{
		t_records__arraylength = 0;
		}
	records__elem_ = 0;
	int t_records__elem__it;
	t_records__elem__it = 0;
	int t_records__size;
	records_ = new vector<NFRecord *>;
	records_->reserve(t_records__arraylength);
	const_byteptr t_records__elem__dataptr = t_dataptr_after_header;
	for (; t_records__elem__it < t_records__arraylength; ++t_records__elem__it)
		{
		// Check &until(records__elem__dataptr >= end_of_data)
		if ( t_records__elem__dataptr >= t_end_of_data )
			{
			records__elem_ = 0;
			goto end_of_records;
			}
		records__elem_ = new NFRecord(version());
		int t_records__elem__size;
		t_records__elem__size = records__elem_->Parse(t_records__elem__dataptr, t_end_of_data, t_context, byteorder());
		// Evaluate 'let' and 'withinput' fields
		records_->push_back(records__elem_);
		t_records__elem__dataptr += t_records__elem__size;
		BINPAC_ASSERT(t_records__elem__dataptr <= t_end_of_data);
		records__elem_ = 0;
		}
end_of_records: ;
	t_records__size = t_records__elem__dataptr - (t_dataptr_after_header);
	// Evaluate 'let' and 'withinput' fields
	
	int t_NetFlowPacket__size;
	const_byteptr const t_dataptr_after_records = t_dataptr_after_header + (t_records__size);
	BINPAC_ASSERT(t_dataptr_after_records <= t_end_of_data);
	t_NetFlowPacket__size = t_dataptr_after_records - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_NetFlowPacket__size) <= t_end_of_data);
	return t_NetFlowPacket__size;
	}

NFHeader::NFHeader(uint16 version, uint16 count)
	{
	val_case_index_ = -1;
	v5header_ = 0;
	v9header_ = 0;
	version_ = version;
	count_ = count;
	}

NFHeader::~NFHeader()
	{
	switch ( val_case_index() )
		{
		case 5:
			// Clean up "v5header"
			{
			delete v5header_;
			v5header_ = 0;
			}
			break;
		case 9:
			// Clean up "v9header"
			{
			delete v9header_;
			v9header_ = 0;
			}
			break;
		}
	}

int NFHeader::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextNetFlow * t_context, int t_byteorder)
	{
	int t_val__size;
	val_case_index_ = version();
	switch ( val_case_index() )
		{
		case 5:
			// Parse "v5header"
			{
			v5header_ = new NFv5HeaderRest(count());
			v5header_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 20;
			}
			break;
		case 9:
			// Parse "v9header"
			{
			v9header_ = new NFv9HeaderRest(count());
			v9header_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 16;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("NFHeader", val_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

NFv5HeaderRest::NFv5HeaderRest(uint16 count)
	{
	sysuptime_ = 0;
	unix_secs_ = 0;
	unix_nsecs_ = 0;
	flow_seq_ = 0;
	eng_type_ = 0;
	eng_id_ = 0;
	sample_int_ = 0;
	count_ = count;
	delivered_ = 0;
	}

NFv5HeaderRest::~NFv5HeaderRest()
	{
	}

int NFv5HeaderRest::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextNetFlow * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "NFv5HeaderRest"
	if ( t_begin_of_data + (20) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NFv5HeaderRest",
			(0) + (20), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "sysuptime"
	sysuptime_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "unix_secs"
	unix_secs_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "unix_nsecs"
	unix_nsecs_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 8))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "flow_seq"
	flow_seq_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 12))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "eng_type"
	eng_type_ = *((uint8 const *) ((t_begin_of_data + 16)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "eng_id"
	eng_id_ = *((uint8 const *) ((t_begin_of_data + 17)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "sample_int"
	sample_int_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 18))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	delivered_ = t_context->flow()->deliver_v5_header(count(), sysuptime(), unix_secs(), unix_nsecs(), flow_seq(), eng_type(), eng_id(), sample_int());
	BINPAC_ASSERT(t_begin_of_data + (20) <= t_end_of_data);
	return 20;
	}

NFv9HeaderRest::NFv9HeaderRest(uint16 count)
	{
	sysuptime_ = 0;
	unix_secs_ = 0;
	pack_seq_ = 0;
	src_id_ = 0;
	count_ = count;
	}

NFv9HeaderRest::~NFv9HeaderRest()
	{
	}

int NFv9HeaderRest::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "NFv9HeaderRest"
	if ( t_begin_of_data + (16) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NFv9HeaderRest",
			(0) + (16), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "sysuptime"
	sysuptime_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "unix_secs"
	unix_secs_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "pack_seq"
	pack_seq_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 8))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "src_id"
	src_id_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 12))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (16) <= t_end_of_data);
	return 16;
	}

NFRecord::NFRecord(uint32 nf_version)
	{
	val_case_index_ = -1;
	v5_ = 0;
	v9_ = 0;
	nf_version_ = nf_version;
	}

NFRecord::~NFRecord()
	{
	switch ( val_case_index() )
		{
		case 5:
			// Clean up "v5"
			{
			delete v5_;
			v5_ = 0;
			}
			break;
		case 9:
			// Clean up "v9"
			{
			delete v9_;
			v9_ = 0;
			}
			break;
		}
	}

int NFRecord::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextNetFlow * t_context, int t_byteorder)
	{
	int t_val__size;
	val_case_index_ = nf_version();
	switch ( val_case_index() )
		{
		case 5:
			// Parse "v5"
			{
			v5_ = new NFv5Record();
			v5_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 48;
			}
			break;
		case 9:
			// Parse "v9"
			{
			v9_ = new NFv9Record();
			int t_v9__size;
			t_v9__size = v9_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_v9__size;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("NFRecord", val_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

NFv5Record::NFv5Record()
	{
	srcaddr_ = 0;
	dstaddr_ = 0;
	nexthop_ = 0;
	input_ = 0;
	output_ = 0;
	dPkts_ = 0;
	dOctets_ = 0;
	first_ = 0;
	last_ = 0;
	srcport_ = 0;
	dstport_ = 0;
	tcp_flags_ = 0;
	prot_ = 0;
	tos_ = 0;
	src_as_ = 0;
	dst_as_ = 0;
	src_mask_ = 0;
	dst_mask_ = 0;
	delivered_ = 0;
	}

NFv5Record::~NFv5Record()
	{
	}

int NFv5Record::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextNetFlow * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "NFv5Record"
	if ( t_begin_of_data + (48) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NFv5Record",
			(0) + (48), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "srcaddr"
	srcaddr_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "dstaddr"
	dstaddr_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "nexthop"
	nexthop_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 8))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "input"
	input_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 12))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "output"
	output_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 14))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "dPkts"
	dPkts_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 16))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "dOctets"
	dOctets_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 20))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "first"
	first_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 24))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "last"
	last_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 28))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "srcport"
	srcport_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 32))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "dstport"
	dstport_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 34))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "anonymous_field_001"
	uint8 anonymous_field_001_;
	anonymous_field_001_ = 0;
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "tcp_flags"
	tcp_flags_ = *((uint8 const *) ((t_begin_of_data + 37)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "prot"
	prot_ = *((uint8 const *) ((t_begin_of_data + 38)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "tos"
	tos_ = *((uint8 const *) ((t_begin_of_data + 39)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "src_as"
	src_as_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 40))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "dst_as"
	dst_as_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 42))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "src_mask"
	src_mask_ = *((uint8 const *) ((t_begin_of_data + 44)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "dst_mask"
	dst_mask_ = *((uint8 const *) ((t_begin_of_data + 45)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "anonymous_field_002"
	uint16 anonymous_field_002_;
	anonymous_field_002_ = 0;
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	delivered_ = t_context->flow()->deliver_v5_record(srcaddr(), dstaddr(), nexthop(), input(), output(), dPkts(), dOctets(), first(), last(), srcport(), dstport(), tcp_flags(), prot(), tos(), src_as(), dst_as(), src_mask(), dst_mask());
	BINPAC_ASSERT(t_begin_of_data + (48) <= t_end_of_data);
	return 48;
	}

NFv9Record::NFv9Record()
	{
	flowset_id_ = 0;
	length_ = 0;
	}

NFv9Record::~NFv9Record()
	{
	data_.free();
	}

int NFv9Record::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "NFv9Record:length"
	if ( (t_begin_of_data + 4) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NFv9Record:length",
			(4) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flowset_id"
	flowset_id_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "length"
	length_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data"
	int t_data__size;
	t_data__size = length() - 8;
	// Checking out-of-bound for "NFv9Record:data"
	if ( (t_begin_of_data + 8) + (t_data__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NFv9Record:data",
			(8) + (t_data__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 8) + t_data__size;
	int t_data_string_length;
	t_data_string_length = length() - 8;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/netflow/netflow-protocol.pac:88", t_data_string_length);
	data_.init((t_begin_of_data + 8), t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_NFv9Record__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 8) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_NFv9Record__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_NFv9Record__size) <= t_end_of_data);
	return t_NFv9Record__size;
	}

} // namespace NetFlow
}  // namespace binpac

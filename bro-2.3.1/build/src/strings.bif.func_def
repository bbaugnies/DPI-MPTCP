// This file was automatically generated by bifcl from strings.bif.


#line 5 "strings.bif"
 // C segment
#include <vector>
#include <algorithm>
using namespace std;

#include "SmithWaterman.h"

#line 22 "strings.bif"
Val* BifFunc::bro_levenshtein_distance(Frame* frame, val_list* BiF_ARGS)
	
#line 23 "strings.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("levenshtein_distance() takes exactly 2 argument(s)");
		return 0;
		}
	StringVal* s1 = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	StringVal* s2 = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());

#line 23 "strings.bif"

	unsigned int n = s1->Len();
	unsigned int m = s2->Len();

	if ( ! n )
		return new Val(m, TYPE_COUNT);

	if ( ! m )
		return new Val(n, TYPE_COUNT);

	vector<vector<unsigned int> > d(n + 1, vector<unsigned int>(m + 1));

	d[0][0] = 0;

	for ( unsigned int i = 1; i <= n; ++i )
		d[i][0] = i;

	for ( unsigned int i = 1; i <= m; ++i )
		d[0][i] = i;

	for ( unsigned int i = 1; i <= n; ++i )
		{
		for ( unsigned int j = 1; j <= m; ++j )
			d[i][j] = min(min(d[i-1][j] + 1, d[i][j-1] + 1),
				      d[i-1][j-1] + (s1->Bytes()[i-1] == s2->Bytes()[j-1] ? 0 : 1));
		}

	return new Val(d[n][m], TYPE_COUNT);
	} // end of BifFunc::bro_levenshtein_distance

#line 51 "strings.bif"

#line 61 "strings.bif"
Val* BifFunc::bro_string_cat(Frame* frame, val_list* BiF_ARGS)
	
#line 62 "strings.bif"
{
#line 62 "strings.bif"

	int n = 0;
	loop_over_list((*BiF_ARGS), i)
		n += (*BiF_ARGS)[i]->AsString()->Len();

	u_char* b = new u_char[n+1];
	BroString* s = new BroString(1, b, n);

	loop_over_list((*BiF_ARGS), j)
		{
		const BroString* s = (*BiF_ARGS)[j]->AsString();
		memcpy(b, s->Bytes(), s->Len());
		b += s->Len();
		}
	*b = 0;

	return new StringVal(s);
	} // end of BifFunc::bro_string_cat

#line 79 "strings.bif"

#line 81 "strings.bif"

int string_array_to_vs(TableVal* tbl, int start, int end,
			vector<const BroString*>& vs)
	{
	vs.clear();
	for ( int i = start; i <= end; ++i )
		{
		Val* ind = new Val(i, TYPE_COUNT);
		Val* v = tbl->Lookup(ind);
		if ( ! v )
			return 0;
		vs.push_back(v->AsString());
#if 0
		char* str = v->AsString()->Render();
		DEBUG_MSG("string_array[%d] = \"%s\"\n", i, str);
		delete [] str;
#endif
		delete ind;
		}
	return 1;
	}

int vs_to_string_array(vector<const BroString*>& vs, TableVal* tbl,
			int start, int end)
	{
	for ( int i = start, j = 0; i <= end; ++i, ++j )
		{
		Val* ind = new Val(i, TYPE_COUNT);
		tbl->Assign(ind, new StringVal(vs[j]->Len(),
						(const char *)vs[j]->Bytes()));
		Unref(ind);
		}
	return 1;
	}

BroString* cat_string_array_n(TableVal* tbl, int start, int end)
	{
	vector<const BroString*> vs;
	string_array_to_vs(tbl, start, end, vs);
	return concatenate(vs);
	}

#line 133 "strings.bif"
Val* BifFunc::bro_cat_string_array(Frame* frame, val_list* BiF_ARGS)
	
#line 134 "strings.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("cat_string_array() takes exactly 1 argument(s)");
		return 0;
		}
	Val* a = (Val*) ((*BiF_ARGS)[0]);

#line 134 "strings.bif"

	TableVal* tbl = a->AsTableVal();
	return new StringVal(cat_string_array_n(tbl, 1, a->AsTable()->Length()));
	} // end of BifFunc::bro_cat_string_array

#line 137 "strings.bif"

#line 152 "strings.bif"
Val* BifFunc::bro_cat_string_array_n(Frame* frame, val_list* BiF_ARGS)
	
#line 153 "strings.bif"
{
	if ( BiF_ARGS->length() != 3 )
		{
		reporter->Error("cat_string_array_n() takes exactly 3 argument(s)");
		return 0;
		}
	Val* a = (Val*) ((*BiF_ARGS)[0]);
	bro_uint_t start = (bro_uint_t) ((*BiF_ARGS)[1]->AsCount());
	bro_uint_t end = (bro_uint_t) ((*BiF_ARGS)[2]->AsCount());

#line 153 "strings.bif"

	TableVal* tbl = a->AsTableVal();
	return new StringVal(cat_string_array_n(tbl, start, end));
	} // end of BifFunc::bro_cat_string_array_n

#line 156 "strings.bif"

#line 171 "strings.bif"
Val* BifFunc::bro_join_string_array(Frame* frame, val_list* BiF_ARGS)
	
#line 172 "strings.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("join_string_array() takes exactly 2 argument(s)");
		return 0;
		}
	StringVal* sep = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	Val* a = (Val*) ((*BiF_ARGS)[1]);

#line 172 "strings.bif"

	vector<const BroString*> vs;
	TableVal* tbl = a->AsTableVal();
	int n = a->AsTable()->Length();

	for ( int i = 1; i <= n; ++i )
		{
		Val* ind = new Val(i, TYPE_COUNT);
		Val* v = tbl->Lookup(ind);
		if ( ! v )
			return 0;

		vs.push_back(v->AsString());
		Unref(ind);

		if ( i < n )
			vs.push_back(sep->AsString());
		}

	return new StringVal(concatenate(vs));
	} // end of BifFunc::bro_join_string_array

#line 192 "strings.bif"

#line 207 "strings.bif"
Val* BifFunc::bro_join_string_vec(Frame* frame, val_list* BiF_ARGS)
	
#line 208 "strings.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("join_string_vec() takes exactly 2 argument(s)");
		return 0;
		}
	Val* vec = (Val*) ((*BiF_ARGS)[0]);
	StringVal* sep = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());

#line 208 "strings.bif"

	ODesc d;
	VectorVal *v = vec->AsVectorVal();

	for ( unsigned i = 0; i < v->Size(); ++i )
		{
		if ( i > 0 )
			d.Add(sep->CheckString(), 0);

		v->Lookup(i)->Describe(&d);
		}

	BroString* s = new BroString(1, d.TakeBytes(), d.Len());
	s->SetUseFreeToDelete(true);

	return new StringVal(s);
	} // end of BifFunc::bro_join_string_vec

#line 224 "strings.bif"

#line 233 "strings.bif"
Val* BifFunc::bro_sort_string_array(Frame* frame, val_list* BiF_ARGS)
	
#line 234 "strings.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("sort_string_array() takes exactly 1 argument(s)");
		return 0;
		}
	Val* a = (Val*) ((*BiF_ARGS)[0]);

#line 234 "strings.bif"

	TableVal* tbl = a->AsTableVal();
	int n = a->AsTable()->Length();

	vector<const BroString*> vs;
	string_array_to_vs(tbl, 1, n, vs);

	unsigned int i, j;
	for ( i = 0; i < vs.size(); ++i )
		{
		const BroString* x = vs[i];
		for ( j = i; j > 0; --j )
			if ( Bstr_cmp(vs[j-1], x) <= 0 )
				break;
			else
				vs[j] = vs[j-1];
		vs[j] = x;
		}
	// sort(vs.begin(), vs.end(), Bstr_cmp);

	TableVal* b = new TableVal(string_array);
	vs_to_string_array(vs, b, 1, n);
	return b;
	} // end of BifFunc::bro_sort_string_array

#line 257 "strings.bif"

#line 277 "strings.bif"
Val* BifFunc::bro_edit(Frame* frame, val_list* BiF_ARGS)
	
#line 278 "strings.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("edit() takes exactly 2 argument(s)");
		return 0;
		}
	StringVal* arg_s = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	StringVal* arg_edit_char = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());

#line 278 "strings.bif"

	if ( arg_edit_char->Len() != 1 )
		builtin_error("not exactly one edit character", (*BiF_ARGS)[1]);

	const u_char* s = arg_s->Bytes();
	const u_char* edit_s = arg_edit_char->Bytes();

	u_char edit_c = *edit_s;

	int n = arg_s->Len();
	u_char* new_s = new u_char[n+1];
	int ind = 0;

	for ( int i = 0; i < n; ++i )
		{
		if ( s[i] == edit_c )
			{ // Delete last character
			if ( --ind < 0 )
				ind = 0;
			}
		else
			new_s[ind++] = s[i];
		}

	new_s[ind] = '\0';

	return new StringVal(new BroString(1, byte_vec(new_s), ind));
	} // end of BifFunc::bro_edit

#line 305 "strings.bif"

#line 316 "strings.bif"
Val* BifFunc::bro_sub_bytes(Frame* frame, val_list* BiF_ARGS)
	
#line 317 "strings.bif"
{
	if ( BiF_ARGS->length() != 3 )
		{
		reporter->Error("sub_bytes() takes exactly 3 argument(s)");
		return 0;
		}
	StringVal* s = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	bro_uint_t start = (bro_uint_t) ((*BiF_ARGS)[1]->AsCount());
	bro_int_t n = (bro_int_t) ((*BiF_ARGS)[2]->AsInt());

#line 317 "strings.bif"

	if ( start > 0 )
		--start;	// make it 0-based

	BroString* ss = s->AsString()->GetSubstring(start, n);

	if ( ! ss )
		ss = new BroString("");

	return new StringVal(ss);
	} // end of BifFunc::bro_sub_bytes

#line 327 "strings.bif"

#line 329 "strings.bif"

static int match_prefix(int s_len, const char* s, int t_len, const char* t)
	{
	for ( int i = 0; i < t_len; ++i )
		{
		if ( i >= s_len || s[i] != t[i] )
			return 0;
		}
	return 1;
	}

Val* do_split(StringVal* str_val, RE_Matcher* re, int incl_sep, int max_num_sep)
	{
	TableVal* a = new TableVal(string_array);
	const u_char* s = str_val->Bytes();
	int n = str_val->Len();
	const u_char* end_of_s = s + n;
	int num = 0;
	int num_sep = 0;

	int offset = 0;
	while ( n >= 0 )
		{
		offset = 0;
		// Find next match offset.
		int end_of_match = 0;
		while ( n > 0 &&
		        (end_of_match = re->MatchPrefix(s + offset, n)) <= 0 )
			{
			// Move on to next byte.
			++offset;
			--n;
			}

		if ( max_num_sep && num_sep >= max_num_sep )
			{
			offset = end_of_s - s;
			n=0;
			}

		Val* ind = new Val(++num, TYPE_COUNT);
		a->Assign(ind, new StringVal(offset, (const char*) s));
		Unref(ind);

		// No more separators will be needed if this is the end of string.
		if ( n <= 0 )
			break;

		if ( incl_sep )
			{ // including the part that matches the pattern
			ind = new Val(++num, TYPE_COUNT);
			a->Assign(ind, new StringVal(end_of_match, (const char*) s+offset));
			Unref(ind);
			}

		if ( max_num_sep && num_sep >= max_num_sep )
			break;

		++num_sep;

		n -= end_of_match;
		s += offset + end_of_match;;

		if ( s > end_of_s )
			reporter->InternalError("RegMatch in split goes beyond the string");
		}

	return a;
	}

Val* do_sub(StringVal* str_val, RE_Matcher* re, StringVal* repl, int do_all)
	{
	const u_char* s = str_val->Bytes();
	int offset = 0;
	int n = str_val->Len();

	// cut_points is a set of pairs of indices in str that should
	// be removed/replaced.  A pair <x,y> means "delete starting
	// at offset x, up to but not including offset y".
	List(ptr_compat_int) cut_points;	// where RE matches pieces of str

	int size = 0;	// size of result

	while ( n > 0 )
		{
		// Find next match offset.
		int end_of_match;
		while ( n > 0 &&
			(end_of_match = re->MatchPrefix(&s[offset], n)) <= 0 )
			{
			// This character is going to be copied to the result.
			++size;

			// Move on to next character.
			++offset;
			--n;
			}

		if ( n <= 0 )
			break;

		// s[offset .. offset+end_of_match-1] matches re.
		cut_points.append(offset);
		cut_points.append(offset + end_of_match);

		offset += end_of_match;
		n -= end_of_match;

		if ( ! do_all )
			{
			// We've now done the first substitution - finished.
			// Include the remainder of the string in the result.
			size += n;
			break;
			}
		}

	// size now reflects amount of space copied.  Factor in amount
	// of space for replacement text.
	int num_cut_points = cut_points.length() / 2;
	size += num_cut_points * repl->Len();

	// And a final NUL for good health.
	++size;

	byte_vec result = new u_char[size];
	byte_vec r = result;

	// Copy it all over.
	int start_offset = 0;
	for ( int i = 0; i < cut_points.length(); i += 2 /* loop over pairs */ )
		{
		int num_to_copy = cut_points[i] - start_offset;
		memcpy(r, s + start_offset, num_to_copy);

		r += num_to_copy;
		start_offset = cut_points[i+1];

		// Now add in replacement text.
		memcpy(r, repl->Bytes(), repl->Len());
		r += repl->Len();
		}

	// Copy final trailing characters.
	int num_to_copy = str_val->Len() - start_offset;
	memcpy(r, s + start_offset, num_to_copy);
	r += num_to_copy;

	// Final NUL.  No need to increment r, since the length
	// computed from it in the next statement does not include
	// the NUL.
	r[0] = '\0';

	return new StringVal(new BroString(1, result, r - result));
	}

#line 501 "strings.bif"
Val* BifFunc::bro_split(Frame* frame, val_list* BiF_ARGS)
	
#line 502 "strings.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("split() takes exactly 2 argument(s)");
		return 0;
		}
	StringVal* str = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	RE_Matcher* re = (RE_Matcher*) ((*BiF_ARGS)[1]->AsPattern());

#line 502 "strings.bif"

	return do_split(str, re, 0, 0);
	} // end of BifFunc::bro_split

#line 504 "strings.bif"

#line 521 "strings.bif"
Val* BifFunc::bro_split1(Frame* frame, val_list* BiF_ARGS)
	
#line 522 "strings.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("split1() takes exactly 2 argument(s)");
		return 0;
		}
	StringVal* str = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	RE_Matcher* re = (RE_Matcher*) ((*BiF_ARGS)[1]->AsPattern());

#line 522 "strings.bif"

	return do_split(str, re, 0, 1);
	} // end of BifFunc::bro_split1

#line 524 "strings.bif"

#line 541 "strings.bif"
Val* BifFunc::bro_split_all(Frame* frame, val_list* BiF_ARGS)
	
#line 542 "strings.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("split_all() takes exactly 2 argument(s)");
		return 0;
		}
	StringVal* str = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	RE_Matcher* re = (RE_Matcher*) ((*BiF_ARGS)[1]->AsPattern());

#line 542 "strings.bif"

	return do_split(str, re, 1, 0);
	} // end of BifFunc::bro_split_all

#line 544 "strings.bif"

#line 566 "strings.bif"
Val* BifFunc::bro_split_n(Frame* frame, val_list* BiF_ARGS)
	
#line 568 "strings.bif"
{
	if ( BiF_ARGS->length() != 4 )
		{
		reporter->Error("split_n() takes exactly 4 argument(s)");
		return 0;
		}
	StringVal* str = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	RE_Matcher* re = (RE_Matcher*) ((*BiF_ARGS)[1]->AsPattern());
	int incl_sep = (int) ((*BiF_ARGS)[2]->AsBool());
	bro_uint_t max_num_sep = (bro_uint_t) ((*BiF_ARGS)[3]->AsCount());

#line 568 "strings.bif"

	return do_split(str, re, incl_sep, max_num_sep);
	} // end of BifFunc::bro_split_n

#line 570 "strings.bif"

#line 585 "strings.bif"
Val* BifFunc::bro_sub(Frame* frame, val_list* BiF_ARGS)
	
#line 586 "strings.bif"
{
	if ( BiF_ARGS->length() != 3 )
		{
		reporter->Error("sub() takes exactly 3 argument(s)");
		return 0;
		}
	StringVal* str = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	RE_Matcher* re = (RE_Matcher*) ((*BiF_ARGS)[1]->AsPattern());
	StringVal* repl = (StringVal*) ((*BiF_ARGS)[2]->AsStringVal());

#line 586 "strings.bif"

	return do_sub(str, re, repl, 0);
	} // end of BifFunc::bro_sub

#line 588 "strings.bif"

#line 602 "strings.bif"
Val* BifFunc::bro_gsub(Frame* frame, val_list* BiF_ARGS)
	
#line 603 "strings.bif"
{
	if ( BiF_ARGS->length() != 3 )
		{
		reporter->Error("gsub() takes exactly 3 argument(s)");
		return 0;
		}
	StringVal* str = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	RE_Matcher* re = (RE_Matcher*) ((*BiF_ARGS)[1]->AsPattern());
	StringVal* repl = (StringVal*) ((*BiF_ARGS)[2]->AsStringVal());

#line 603 "strings.bif"

	return do_sub(str, re, repl, 1);
	} // end of BifFunc::bro_gsub

#line 605 "strings.bif"

#line 616 "strings.bif"
Val* BifFunc::bro_strcmp(Frame* frame, val_list* BiF_ARGS)
	
#line 617 "strings.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("strcmp() takes exactly 2 argument(s)");
		return 0;
		}
	StringVal* s1 = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	StringVal* s2 = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());

#line 617 "strings.bif"

	return new Val(Bstr_cmp(s1->AsString(), s2->AsString()), TYPE_INT);
	} // end of BifFunc::bro_strcmp

#line 619 "strings.bif"

#line 631 "strings.bif"
Val* BifFunc::bro_strstr(Frame* frame, val_list* BiF_ARGS)
	
#line 632 "strings.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("strstr() takes exactly 2 argument(s)");
		return 0;
		}
	StringVal* big = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	StringVal* little = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());

#line 632 "strings.bif"

	return new Val(
		1 + big->AsString()->FindSubstring(little->AsString()),
		TYPE_COUNT);
	} // end of BifFunc::bro_strstr

#line 636 "strings.bif"

#line 649 "strings.bif"
Val* BifFunc::bro_subst_string(Frame* frame, val_list* BiF_ARGS)
	
#line 650 "strings.bif"
{
	if ( BiF_ARGS->length() != 3 )
		{
		reporter->Error("subst_string() takes exactly 3 argument(s)");
		return 0;
		}
	StringVal* s = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	StringVal* from = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());
	StringVal* to = (StringVal*) ((*BiF_ARGS)[2]->AsStringVal());

#line 650 "strings.bif"

	const int little_len = from->Len();
	if ( little_len == 0 )
		return s->Ref();

	int big_len = s->Len();
	const u_char* big = s->Bytes();
	data_chunk_t dc;
	vector<data_chunk_t> vs;

	while ( big_len >= little_len )
		{
		int j = strstr_n(big_len, big, little_len, from->Bytes());

		if ( j < 0 )
			break;

		if ( j > 0 )
			{
			dc.length = j; dc.data = (const char*) big;
			vs.push_back(dc);
			}

		dc.length = to->Len();
		dc.data = (const char*) (to->Bytes());
		vs.push_back(dc);

		j += little_len;
		big += j;
		big_len -= j;
		}

	if ( big_len > 0 )
		{
		dc.length = big_len; dc.data = (const char*) big;
		vs.push_back(dc);
		}

	return new StringVal(concatenate(vs));
	} // end of BifFunc::bro_subst_string

#line 689 "strings.bif"

#line 700 "strings.bif"
Val* BifFunc::bro_to_lower(Frame* frame, val_list* BiF_ARGS)
	
#line 701 "strings.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("to_lower() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* str = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 701 "strings.bif"

	const u_char* s = str->Bytes();
	int n = str->Len();
	u_char* lower_s = new u_char[n + 1];
	u_char* ls = lower_s;

	for ( int i = 0; i < n; ++i)
		{
		if ( isascii(s[i]) && isupper(s[i]) )
			*ls++ = tolower(s[i]);
		else
			*ls++ = s[i];
		}

    *ls++ = '\0';

	return new StringVal(new BroString(1, lower_s, n));
	} // end of BifFunc::bro_to_lower

#line 718 "strings.bif"

#line 729 "strings.bif"
Val* BifFunc::bro_to_upper(Frame* frame, val_list* BiF_ARGS)
	
#line 730 "strings.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("to_upper() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* str = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 730 "strings.bif"

	const u_char* s = str->Bytes();
	int n = str->Len();
	u_char* upper_s = new u_char[n + 1];
	u_char* us = upper_s;

	for ( int i = 0; i < n; ++i)
		{
		if ( isascii(s[i]) && islower(s[i]) )
			*us++ = toupper(s[i]);
		else
			*us++ = s[i];
		}

    *us++ = '\0';

	return new StringVal(new BroString(1, upper_s, n));
	} // end of BifFunc::bro_to_upper

#line 747 "strings.bif"

#line 764 "strings.bif"
Val* BifFunc::bro_clean(Frame* frame, val_list* BiF_ARGS)
	
#line 765 "strings.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("clean() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* str = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 765 "strings.bif"

	char* s = str->AsString()->Render();
	return new StringVal(new BroString(1, byte_vec(s), strlen(s)));
	} // end of BifFunc::bro_clean

#line 768 "strings.bif"

#line 783 "strings.bif"
Val* BifFunc::bro_to_string_literal(Frame* frame, val_list* BiF_ARGS)
	
#line 784 "strings.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("to_string_literal() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* str = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 784 "strings.bif"

	char* s = str->AsString()->Render(BroString::BRO_STRING_LITERAL);
	return new StringVal(new BroString(1, byte_vec(s), strlen(s)));
	} // end of BifFunc::bro_to_string_literal

#line 787 "strings.bif"

#line 797 "strings.bif"
Val* BifFunc::bro_is_ascii(Frame* frame, val_list* BiF_ARGS)
	
#line 798 "strings.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("is_ascii() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* str = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 798 "strings.bif"

	int n = str->Len();
	const u_char* s = str->Bytes();

	for ( int i = 0; i < n; ++i )
		if ( s[i] > 127 )
			return new Val(0, TYPE_BOOL);

	return new Val(1, TYPE_BOOL);
	} // end of BifFunc::bro_is_ascii

#line 807 "strings.bif"

#line 817 "strings.bif"
Val* BifFunc::bro_escape_string(Frame* frame, val_list* BiF_ARGS)
	
#line 818 "strings.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("escape_string() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* s = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 818 "strings.bif"

	char* escstr = s->AsString()->Render();
	Val* val = new StringVal(escstr);
	delete [] escstr;
	return val;
	} // end of BifFunc::bro_escape_string

#line 823 "strings.bif"

#line 831 "strings.bif"
Val* BifFunc::bro_string_to_ascii_hex(Frame* frame, val_list* BiF_ARGS)
	
#line 832 "strings.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("string_to_ascii_hex() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* s = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 832 "strings.bif"

	char* x = new char[s->Len() * 2 + 1];
	const u_char* sp = s->Bytes();

	for ( int i = 0; i < s->Len(); ++i )
		sprintf(x + i * 2, "%02x", sp[i]);

	return new StringVal(new BroString(1, (u_char*) x, s->Len() * 2));
	} // end of BifFunc::bro_string_to_ascii_hex

#line 840 "strings.bif"

#line 852 "strings.bif"
Val* BifFunc::bro_str_smith_waterman(Frame* frame, val_list* BiF_ARGS) 
	
#line 853 "strings.bif"
{
	if ( BiF_ARGS->length() != 3 )
		{
		reporter->Error("str_smith_waterman() takes exactly 3 argument(s)");
		return 0;
		}
	StringVal* s1 = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	StringVal* s2 = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());
	Val* params = (Val*) ((*BiF_ARGS)[2]);

#line 853 "strings.bif"

	SWParams sw_params(params->AsRecordVal()->Lookup(0)->AsCount(),
			   SWVariant(params->AsRecordVal()->Lookup(1)->AsCount()));

	BroSubstring::Vec* subseq =
		smith_waterman(s1->AsString(), s2->AsString(), sw_params);
	VectorVal* result = BroSubstring::VecToPolicy(subseq);
	delete_each(subseq);
	delete subseq;

	return result;
	} // end of BifFunc::bro_str_smith_waterman

#line 864 "strings.bif"

#line 876 "strings.bif"
Val* BifFunc::bro_str_split(Frame* frame, val_list* BiF_ARGS)
	
#line 877 "strings.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("str_split() takes exactly 2 argument(s)");
		return 0;
		}
	StringVal* s = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	Val* idx = (Val*) ((*BiF_ARGS)[1]);

#line 877 "strings.bif"

	vector<Val*>* idx_v = idx->AsVector();
	BroString::IdxVec indices(idx_v->size());
	unsigned int i;

	for ( i = 0; i < idx_v->size(); i++ )
		indices[i] = (*idx_v)[i]->AsCount();

	BroString::Vec* result = s->AsString()->Split(indices);
	VectorVal* result_v = new VectorVal(
	    internal_type("string_vec")->AsVectorType());

	if ( result )
		{
		i = 1;

		for ( BroString::VecIt it = result->begin();
		      it != result->end(); ++it, ++i )
			result_v->Assign(i, new StringVal(*it));
			// StringVal now possesses string.

		delete result;
		}

	return result_v;
	} // end of BifFunc::bro_str_split

#line 902 "strings.bif"

#line 911 "strings.bif"
Val* BifFunc::bro_strip(Frame* frame, val_list* BiF_ARGS)
	
#line 912 "strings.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("strip() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* str = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 912 "strings.bif"

	const u_char* s = str->Bytes();
	int n = str->Len();

	if ( n == 0 )
		// Empty string.
		return new StringVal(new BroString(s, n, 1));

	const u_char* sp = s;

	// Move a pointer from the end of the string.
	const u_char* e = sp + n - 1;
	while ( e > sp && isspace(*e) )
		--e;

	// Move the pointer for the beginning of the string.
	while ( isspace(*sp) && sp <= e )
		++sp;

	return new StringVal(new BroString(sp, (e - sp + 1), 1));
	} // end of BifFunc::bro_strip

#line 932 "strings.bif"

#line 942 "strings.bif"
Val* BifFunc::bro_string_fill(Frame* frame, val_list* BiF_ARGS)
	
#line 943 "strings.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("string_fill() takes exactly 2 argument(s)");
		return 0;
		}
	bro_int_t len = (bro_int_t) ((*BiF_ARGS)[0]->AsInt());
	StringVal* source = (StringVal*) ((*BiF_ARGS)[1]->AsStringVal());

#line 943 "strings.bif"

	const u_char* src = source->Bytes();
	int64_t n = source->Len();
	char* dst = new char[len];

	for ( int i = 0; i < len; i += n )
		::memcpy((dst + i), src, min(n, len - i));

	dst[len - 1] = 0;

	return new StringVal(new BroString(1, byte_vec(dst), len));
	} // end of BifFunc::bro_string_fill

#line 954 "strings.bif"

#line 965 "strings.bif"
Val* BifFunc::bro_str_shell_escape(Frame* frame, val_list* BiF_ARGS)
	
#line 966 "strings.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("str_shell_escape() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* source = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 966 "strings.bif"

	unsigned j = 0;
	const u_char* src = source->Bytes();
	unsigned n = source->Len();
	byte_vec dst = new u_char[n * 2 + 1];

	for ( unsigned i = 0; i < n; ++i )
		{
		switch ( src[i] ) {
		case '`': case '"': case '\\': case '$':

		// case '|': case '&': case ';': case '(': case ')': case '<':
		// case '>': case '\'': case '*': case '?': case '[': case ']':
		// case '!': case '#': case '{': case '}':
			dst[j++] = '\\';
			break;
		default:
			break;
		}

		dst[j++] = src[i];
		}

	dst[j] = '\0';
	return new StringVal(new BroString(1, dst, j));
	} // end of BifFunc::bro_str_shell_escape

#line 991 "strings.bif"

#line 1002 "strings.bif"
Val* BifFunc::bro_find_all(Frame* frame, val_list* BiF_ARGS) 
	
#line 1003 "strings.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("find_all() takes exactly 2 argument(s)");
		return 0;
		}
	StringVal* str = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	RE_Matcher* re = (RE_Matcher*) ((*BiF_ARGS)[1]->AsPattern());

#line 1003 "strings.bif"

	TableVal* a = new TableVal(string_set);

	const u_char* s = str->Bytes();
	const u_char* e = s + str->Len();

	for ( const u_char* t = s; t < e; ++t )
		{
		int n = re->MatchPrefix(t, e - t);
		if ( n >= 0 )
			{
			a->Assign(new StringVal(n, (const char*) t), 0);
			t += n - 1;
			}
		}

	return a;
	} // end of BifFunc::bro_find_all

#line 1020 "strings.bif"

#line 1034 "strings.bif"
Val* BifFunc::bro_find_last(Frame* frame, val_list* BiF_ARGS) 
	
#line 1035 "strings.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("find_last() takes exactly 2 argument(s)");
		return 0;
		}
	StringVal* str = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());
	RE_Matcher* re = (RE_Matcher*) ((*BiF_ARGS)[1]->AsPattern());

#line 1035 "strings.bif"

	const u_char* s = str->Bytes();
	const u_char* e = s + str->Len();

	for ( const u_char* t = e - 1; t >= s; --t )
		{
		int n = re->MatchPrefix(t, e - t);
		if ( n >= 0 )
			return new StringVal(n, (const char*) t);
		}

	return new StringVal("");
	} // end of BifFunc::bro_find_last

#line 1047 "strings.bif"

#line 1061 "strings.bif"
Val* BifFunc::bro_hexdump(Frame* frame, val_list* BiF_ARGS) 
	
#line 1062 "strings.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("hexdump() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* data_str = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 1062 "strings.bif"


// The width of a line of text in the hex-mode view, consisting
// of offset, hex view and ASCII view:
//
// 32 +     16 characters per 8 bytes, twice
// (2*7) +  Single space between bytes, twice
// 4 +      Two spaces between 8-byte sets and ASCII
// 1 +      For newline
// 17 +     For ASCII display, with spacer column
// 6        For 5-digit offset counter, including spacer
//
#define HEX_LINE_WIDTH               74

#define HEX_LINE_START                6
#define HEX_LINE_END                 53
#define HEX_LINE_START_ASCII         56
#define HEX_LINE_START_RIGHT_ASCII   65
#define HEX_LINE_LEFT_MIDDLE         28
#define HEX_LINE_RIGHT_MIDDLE        31
#define HEX_BLOCK_LEN                23
#define HEX_LINE_BYTES               16
#define NULL_CHAR                    '.'
#define NONPRINT_CHAR                '.'

	const u_char* data = data_str->Bytes();
	unsigned data_size = data_str->Len();

	if ( ! data )
		return new StringVal("");

	int num_lines = (data_size / 16) + 1;
	int len = num_lines * HEX_LINE_WIDTH;
	u_char* hex_data = new u_char[len + 1];
	if ( ! hex_data )
		return new StringVal("");

	memset(hex_data, ' ', len);

	u_char* hex_data_ptr = hex_data;
	u_char* ascii_ptr = hex_data_ptr + 50;
	int x = 0, y = 0;

	for ( const u_char* data_ptr = data; data_ptr < data + data_size;
	      ++data_ptr )
		{
		if ( x == 0 )
			{
			char offset[5];
			safe_snprintf(offset, sizeof(offset),
					"%.4x", data_ptr - data);
			memcpy(hex_data_ptr, offset, 4);
			hex_data_ptr += 6;
			ascii_ptr = hex_data_ptr + 50;
			}

		char hex_byte[3];
		safe_snprintf(hex_byte, sizeof(hex_byte),
				"%.2x", (u_char) *data_ptr);

		int val = (u_char) *data_ptr;

		u_char ascii_byte = val;

		// If unprintable, use special characters:
		if ( val < 0x20 || val >= 0x7f )
			{
			if ( val == 0 )
				ascii_byte = NULL_CHAR;
			else
				ascii_byte = NONPRINT_CHAR;
			}

		*hex_data_ptr++ = hex_byte[0];
		*hex_data_ptr++ = hex_byte[1];
		*hex_data_ptr++ = ' ';
		*ascii_ptr++ = ascii_byte;

		if ( x == 7 )
			{
			*hex_data_ptr++ = ' ';
			*ascii_ptr++ = ' ';
			}

		++x;

		if ( x == 16 )
			{
			x = 0;
			*ascii_ptr++ = '\n';
			hex_data_ptr = ascii_ptr;
			}
		}

	// Terminate the string, but ensure it ends with a newline.
	if ( ascii_ptr[-1] != '\n' )
		*ascii_ptr++ = '\n';
	*ascii_ptr = 0;

	StringVal* result = new StringVal((const char*) hex_data);
	delete [] hex_data;

	return result;
	} // end of BifFunc::bro_hexdump

#line 1165 "strings.bif"

#line 1173 "strings.bif"
Val* BifFunc::bro_reverse(Frame* frame, val_list* BiF_ARGS) 
	
#line 1174 "strings.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("reverse() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* str = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 1174 "strings.bif"

	string s = string((const char*)str->Bytes(), str->Len());
	reverse(s.begin(), s.end());
	return new StringVal(s.length(), (const char*)s.c_str());
	} // end of BifFunc::bro_reverse

#line 1178 "strings.bif"

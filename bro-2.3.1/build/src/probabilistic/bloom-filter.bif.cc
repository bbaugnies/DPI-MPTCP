// This file was automatically generated by bifcl from /home/benjamin/Bro/bro-2.3.1/src/probabilistic/bloom-filter.bif (alternative mode).


#include "bloom-filter.bif.h"


#line 3 "bloom-filter.bif"


// TODO: This is currently included from the top-level src directory, hence
// paths are relative to there. We need a better mechanisms to pull in
// BiFs defined in sub directories.
#include "probabilistic/BloomFilter.h"
#include "OpaqueVal.h"

using namespace probabilistic;


#line 34 "bloom-filter.bif"
Val* BifFunc::bro_bloomfilter_basic_init(Frame* frame, val_list* BiF_ARGS)
	
#line 36 "bloom-filter.bif"
{
	if ( BiF_ARGS->length() != 3 )
		{
		reporter->Error("bloomfilter_basic_init() takes exactly 3 argument(s)");
		return 0;
		}
	double fp = (double) ((*BiF_ARGS)[0]->AsDouble());
	bro_uint_t capacity = (bro_uint_t) ((*BiF_ARGS)[1]->AsCount());
	StringVal* name = (StringVal*) ((*BiF_ARGS)[2]->AsStringVal());

#line 36 "bloom-filter.bif"

	if ( fp < 0.0 || fp > 1.0 )
		{
		reporter->Error("false-positive rate must take value between 0 and 1");
		return 0;
		}

	size_t cells = BasicBloomFilter::M(fp, capacity);
	size_t optimal_k = BasicBloomFilter::K(cells, capacity);
	size_t seed = Hasher::MakeSeed(name->Len() > 0 ? name->Bytes() : 0,
                                 name->Len());
	const Hasher* h = new DoubleHasher(optimal_k, seed);

	return new BloomFilterVal(new BasicBloomFilter(h, cells));
	} // end of BifFunc::bro_bloomfilter_basic_init

#line 50 "bloom-filter.bif"

#line 71 "bloom-filter.bif"
Val* BifFunc::bro_bloomfilter_basic_init2(Frame* frame, val_list* BiF_ARGS)
	
#line 73 "bloom-filter.bif"
{
	if ( BiF_ARGS->length() != 3 )
		{
		reporter->Error("bloomfilter_basic_init2() takes exactly 3 argument(s)");
		return 0;
		}
	bro_uint_t k = (bro_uint_t) ((*BiF_ARGS)[0]->AsCount());
	bro_uint_t cells = (bro_uint_t) ((*BiF_ARGS)[1]->AsCount());
	StringVal* name = (StringVal*) ((*BiF_ARGS)[2]->AsStringVal());

#line 73 "bloom-filter.bif"

	if ( k == 0 )
		{
		reporter->Error("number of hash functions must be non-negative");
		return 0;
		}
	if ( cells == 0 )
		{
		reporter->Error("number of cells must be non-negative");
		return 0;
		}

	size_t seed = Hasher::MakeSeed(name->Len() > 0 ? name->Bytes() : 0,
				       name->Len());
	const Hasher* h = new DoubleHasher(k, seed);

	return new BloomFilterVal(new BasicBloomFilter(h, cells));
	} // end of BifFunc::bro_bloomfilter_basic_init2

#line 90 "bloom-filter.bif"

#line 115 "bloom-filter.bif"
Val* BifFunc::bro_bloomfilter_counting_init(Frame* frame, val_list* BiF_ARGS)
	
#line 117 "bloom-filter.bif"
{
	if ( BiF_ARGS->length() != 4 )
		{
		reporter->Error("bloomfilter_counting_init() takes exactly 4 argument(s)");
		return 0;
		}
	bro_uint_t k = (bro_uint_t) ((*BiF_ARGS)[0]->AsCount());
	bro_uint_t cells = (bro_uint_t) ((*BiF_ARGS)[1]->AsCount());
	bro_uint_t max = (bro_uint_t) ((*BiF_ARGS)[2]->AsCount());
	StringVal* name = (StringVal*) ((*BiF_ARGS)[3]->AsStringVal());

#line 117 "bloom-filter.bif"

	if ( max == 0 )
		{
		reporter->Error("max counter value must be greater than 0");
		return 0;
		}

	size_t seed = Hasher::MakeSeed(name->Len() > 0 ? name->Bytes() : 0,
				       name->Len());

	const Hasher* h = new DefaultHasher(k, seed);

	uint16 width = 1;
	while ( max >>= 1 )
		++width;

	return new BloomFilterVal(new CountingBloomFilter(h, cells, width));
	} // end of BifFunc::bro_bloomfilter_counting_init

#line 134 "bloom-filter.bif"

#line 145 "bloom-filter.bif"
Val* BifFunc::bro_bloomfilter_add(Frame* frame, val_list* BiF_ARGS)
	
#line 146 "bloom-filter.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("bloomfilter_add() takes exactly 2 argument(s)");
		return 0;
		}
	Val* bf = (Val*) ((*BiF_ARGS)[0]);
	Val* x = (Val*) ((*BiF_ARGS)[1]);

#line 146 "bloom-filter.bif"

	BloomFilterVal* bfv = static_cast<BloomFilterVal*>(bf);

	if ( ! bfv->Type() && ! bfv->Typify(x->Type()) )
		reporter->Error("failed to set Bloom filter type");

	else if ( ! same_type(bfv->Type(), x->Type()) )
		reporter->Error("incompatible Bloom filter types");

	else
		bfv->Add(x);

	return 0;
	} // end of BifFunc::bro_bloomfilter_add

#line 159 "bloom-filter.bif"

#line 172 "bloom-filter.bif"
Val* BifFunc::bro_bloomfilter_lookup(Frame* frame, val_list* BiF_ARGS)
	
#line 173 "bloom-filter.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("bloomfilter_lookup() takes exactly 2 argument(s)");
		return 0;
		}
	Val* bf = (Val*) ((*BiF_ARGS)[0]);
	Val* x = (Val*) ((*BiF_ARGS)[1]);

#line 173 "bloom-filter.bif"

	const BloomFilterVal* bfv = static_cast<const BloomFilterVal*>(bf);

	if ( bfv->Empty() )
		return new Val(0, TYPE_COUNT);

	if ( ! bfv->Type() )
		reporter->Error("cannot perform lookup on untyped Bloom filter");

	else if ( ! same_type(bfv->Type(), x->Type()) )
		reporter->Error("incompatible Bloom filter types");

	else
		return new Val(static_cast<uint64>(bfv->Count(x)), TYPE_COUNT);

	return new Val(0, TYPE_COUNT);
	} // end of BifFunc::bro_bloomfilter_lookup

#line 189 "bloom-filter.bif"

#line 200 "bloom-filter.bif"
Val* BifFunc::bro_bloomfilter_clear(Frame* frame, val_list* BiF_ARGS)
	
#line 201 "bloom-filter.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("bloomfilter_clear() takes exactly 1 argument(s)");
		return 0;
		}
	Val* bf = (Val*) ((*BiF_ARGS)[0]);

#line 201 "bloom-filter.bif"

	BloomFilterVal* bfv = static_cast<BloomFilterVal*>(bf);

	if ( bfv->Type() ) // Untyped Bloom filters are already empty.
		bfv->Clear();

	return 0;
	} // end of BifFunc::bro_bloomfilter_clear

#line 208 "bloom-filter.bif"

#line 225 "bloom-filter.bif"
Val* BifFunc::bro_bloomfilter_merge(Frame* frame, val_list* BiF_ARGS)
	
#line 227 "bloom-filter.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("bloomfilter_merge() takes exactly 2 argument(s)");
		return 0;
		}
	Val* bf1 = (Val*) ((*BiF_ARGS)[0]);
	Val* bf2 = (Val*) ((*BiF_ARGS)[1]);

#line 227 "bloom-filter.bif"

	const BloomFilterVal* bfv1 = static_cast<const BloomFilterVal*>(bf1);
	const BloomFilterVal* bfv2 = static_cast<const BloomFilterVal*>(bf2);

	if ( bfv1->Type() && // any one 0 is ok here
	     bfv2->Type() &&
	     ! same_type(bfv1->Type(), bfv2->Type()) )
		{
		reporter->Error("incompatible Bloom filter types");
		return 0;
		}

	return BloomFilterVal::Merge(bfv1, bfv2);
	} // end of BifFunc::bro_bloomfilter_merge

#line 240 "bloom-filter.bif"

#line 248 "bloom-filter.bif"
Val* BifFunc::bro_bloomfilter_internal_state(Frame* frame, val_list* BiF_ARGS)
	
#line 249 "bloom-filter.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("bloomfilter_internal_state() takes exactly 1 argument(s)");
		return 0;
		}
	Val* bf = (Val*) ((*BiF_ARGS)[0]);

#line 249 "bloom-filter.bif"

	BloomFilterVal* bfv = static_cast<BloomFilterVal*>(bf);
	return new StringVal(bfv->InternalState());
	} // end of BifFunc::bro_bloomfilter_internal_state

#line 252 "bloom-filter.bif"

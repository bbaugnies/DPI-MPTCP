// This file was automatically generated by bifcl from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ftp/functions.bif (plugin mode).


#include "functions.bif.h"

namespace BifType { namespace Record{  RecordType * ftp_port;  } }

#line 4 "functions.bif"


static Val* parse_port(const char* line)
	{
	RecordVal* r = new RecordVal(BifType::Record::ftp_port);

	int bytes[6];
	if ( line && sscanf(line, "%d,%d,%d,%d,%d,%d",
			&bytes[0], &bytes[1], &bytes[2],
			&bytes[3], &bytes[4], &bytes[5]) == 6 )
		{
		int good = 1;

		for ( int i = 0; i < 6; ++i )
			if ( bytes[i] < 0 || bytes[i] > 255 )
				{
				good = 0;
				break;
				}

		uint32 addr = (bytes[0] << 24) | (bytes[1] << 16) |
				(bytes[2] << 8) | bytes[3];
		uint32 port = (bytes[4] << 8) | bytes[5];

		// Since port is unsigned, no need to check for < 0.
		if ( port > 65535 )
			{
			port = 0;
			good = 0;
			}

		r->Assign(0, new AddrVal(htonl(addr)));
		r->Assign(1, new PortVal(port, TRANSPORT_TCP));
		r->Assign(2, new Val(good, TYPE_BOOL));
		}
	else
		{
		r->Assign(0, new AddrVal(uint32(0)));
		r->Assign(1, new PortVal(0, TRANSPORT_TCP));
		r->Assign(2, new Val(0, TYPE_BOOL));
		}

	return r;
	}

static Val* parse_eftp(const char* line)
	{
	RecordVal* r = new RecordVal(BifType::Record::ftp_port);

	int net_proto = 0;	// currently not used
	IPAddr addr;	// unspecified IPv6 address (all 128 bits zero)
	int port = 0;
	int good = 0;

	if ( line )
		{
		while ( isspace(*line) )	// skip whitespace
			++line;

		char delimiter = *line;
		char* next_delim;

		if ( *line )
			{
			good = 1;
			++line;	// skip delimiter

			net_proto = strtol(line, &next_delim, 10);
			if ( *next_delim != delimiter )
				good = 0;

			line = next_delim;
			if ( *line )
				++line;

			if ( *line && *line != delimiter )
				{
				const char* nptr = strchr(line, delimiter);
				if ( nptr == NULL )
					{
					nptr = line + strlen(line);
					good = 0;
					}

				string s(line, nptr-line); // extract IP address
				IPAddr tmp(s);
				// on error, "tmp" will have all 128 bits zero
				if ( tmp == addr )
					good = 0;

				addr = tmp;
				}

			line = strchr(line, delimiter);

			if ( line != NULL )
				{
				++line;	// now the port
				port = strtol(line, &next_delim, 10);
				if ( *next_delim != delimiter )
					good = 0;
				}

			}

		}

	r->Assign(0, new AddrVal(addr));
	r->Assign(1, new PortVal(port, TRANSPORT_TCP));
	r->Assign(2, new Val(good, TYPE_BOOL));

	return r;
	}

#line 127 "functions.bif"
Val* BifFunc::bro_parse_ftp_port(Frame* frame, val_list* BiF_ARGS)
	
#line 128 "functions.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("parse_ftp_port() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* s = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 128 "functions.bif"

	return parse_port(s->CheckString());
	} // end of BifFunc::bro_parse_ftp_port

#line 130 "functions.bif"

#line 142 "functions.bif"
Val* BifFunc::bro_parse_eftp_port(Frame* frame, val_list* BiF_ARGS)
	
#line 143 "functions.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("parse_eftp_port() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* s = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 143 "functions.bif"

	return parse_eftp(s->CheckString());
	} // end of BifFunc::bro_parse_eftp_port

#line 145 "functions.bif"

#line 154 "functions.bif"
Val* BifFunc::bro_parse_ftp_pasv(Frame* frame, val_list* BiF_ARGS)
	
#line 155 "functions.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("parse_ftp_pasv() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* str = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 155 "functions.bif"

	const char* s = str->CheckString();
	const char* line = strchr(s, '(');
	if ( line )
		++line;	// move past '('
	else if ( (line = strstr(s, "PORT")) )
		line += 5;	// Skip over
	else if ( (line = strchr(s, ',')) )
		{ // Look for comma-separated list.
		while ( --line >= s && isdigit(*line) )
			;	// Back up over preceding digits.
		++line;	// now points to first digit, or beginning of s
		}

	return parse_port(line);
	} // end of BifFunc::bro_parse_ftp_pasv

#line 170 "functions.bif"

#line 181 "functions.bif"
Val* BifFunc::bro_parse_ftp_epsv(Frame* frame, val_list* BiF_ARGS)
	
#line 182 "functions.bif"
{
	if ( BiF_ARGS->length() != 1 )
		{
		reporter->Error("parse_ftp_epsv() takes exactly 1 argument(s)");
		return 0;
		}
	StringVal* str = (StringVal*) ((*BiF_ARGS)[0]->AsStringVal());

#line 182 "functions.bif"

	const char* s = str->CheckString();
	const char* line = strchr(s, '(');
	if ( line )
		++line; // move past '('
	return parse_eftp(line);
	} // end of BifFunc::bro_parse_ftp_epsv

#line 188 "functions.bif"

#line 200 "functions.bif"
Val* BifFunc::bro_fmt_ftp_port(Frame* frame, val_list* BiF_ARGS)
	
#line 201 "functions.bif"
{
	if ( BiF_ARGS->length() != 2 )
		{
		reporter->Error("fmt_ftp_port() takes exactly 2 argument(s)");
		return 0;
		}
	AddrVal* a = (AddrVal*) ((*BiF_ARGS)[0]->AsAddrVal());
	PortVal* p = (PortVal*) ((*BiF_ARGS)[1]->AsPortVal());

#line 201 "functions.bif"

	const uint32* addr;
	int len = a->AsAddr().GetBytes(&addr);
	if ( len == 1 )
		{
		uint32 a = ntohl(addr[0]);
		uint32 pn = p->Port();
		return new StringVal(fmt("%d,%d,%d,%d,%d,%d",
						a >> 24, (a >> 16) & 0xff,
						(a >> 8) & 0xff, a & 0xff,
						pn >> 8, pn & 0xff));
		}
	else
		{
		builtin_error("conversion of non-IPv4 address in fmt_ftp_port",
		              (*BiF_ARGS)[0]);
		return new StringVal("");
		}
	} // end of BifFunc::bro_fmt_ftp_port

#line 219 "functions.bif"

// This file is automatically generated from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ayiya/ayiya.pac.


#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include "/home/benjamin/Bro/bro-2.3.1/build/src/analyzer/protocol/ayiya/ayiya_pac.h"

namespace binpac {






namespace AYIYA {
ContextAYIYA::ContextAYIYA(AYIYA_Conn * connection, AYIYA_Flow * flow)
	{
	connection_ = connection;
	flow_ = flow;
	}

ContextAYIYA::~ContextAYIYA()
	{
	}

PDU::PDU()
	{
	identity_byte_ = 0;
	signature_byte_ = 0;
	auth_and_op_ = 0;
	next_header_ = 0;
	epoch_ = 0;
	byteorder_ = littleendian;
	identity_len_ = 0;
	signature_len_ = 0;
	auth_ = 0;
	op_ = 0;
	proc_ayiya_ = 0;
	}

PDU::~PDU()
	{
	identity_.free();
	signature_.free();
	packet_.free();
	}

int PDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextAYIYA * t_context)
	{
	// Checking out-of-bound for "PDU:epoch"
	if ( (t_begin_of_data + 4) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("PDU:epoch",
			(4) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "identity_byte"
	identity_byte_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "signature_byte"
	signature_byte_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "auth_and_op"
	auth_and_op_ = *((uint8 const *) ((t_begin_of_data + 2)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "next_header"
	next_header_ = *((uint8 const *) ((t_begin_of_data + 3)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "epoch"
	epoch_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "identity"
	int t_identity__size;
	identity_len_ =  ( 1 <<  ( identity_byte() >> 4 )  ) ;
	t_identity__size = identity_len();
	// Checking out-of-bound for "PDU:identity"
	if ( (t_begin_of_data + 8) + (t_identity__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("PDU:identity",
			(8) + (t_identity__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 8) + t_identity__size;
	int t_identity_string_length;
	t_identity_string_length = identity_len();
	// check for negative sizes
	if ( t_identity_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ayiya/ayiya-protocol.pac:8", t_identity_string_length);
	identity_.init((t_begin_of_data + 8), t_identity_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_identity = (t_begin_of_data + 8) + (t_identity__size);
	BINPAC_ASSERT(t_dataptr_after_identity <= t_end_of_data);
	// Parse "signature"
	int t_signature__size;
	signature_len_ =  ( signature_byte() >> 4 )  * 4;
	t_signature__size = signature_len();
	// Checking out-of-bound for "PDU:signature"
	if ( t_dataptr_after_identity + (t_signature__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("PDU:signature",
			((t_dataptr_after_identity - t_begin_of_data)) + (t_signature__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_identity + t_signature__size;
	int t_signature_string_length;
	t_signature_string_length = signature_len();
	// check for negative sizes
	if ( t_signature_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ayiya/ayiya-protocol.pac:9", t_signature_string_length);
	signature_.init(t_dataptr_after_identity, t_signature_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_signature = t_dataptr_after_identity + (t_signature__size);
	BINPAC_ASSERT(t_dataptr_after_signature <= t_end_of_data);
	// Parse "packet"
	int t_packet_string_length;
	t_packet_string_length = (t_end_of_data) - (t_dataptr_after_signature);
	int t_packet__size;
	t_packet__size = t_packet_string_length;
	// check for negative sizes
	if ( t_packet_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ayiya/ayiya-protocol.pac:10", t_packet_string_length);
	packet_.init(t_dataptr_after_signature, t_packet_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_PDU__size;
	const_byteptr const t_dataptr_after_packet = t_dataptr_after_signature + (t_packet__size);
	BINPAC_ASSERT(t_dataptr_after_packet <= t_end_of_data);
	t_PDU__size = t_dataptr_after_packet - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	auth_ = auth_and_op() >> 4;
	op_ = auth_and_op() & 0xF;
	proc_ayiya_ = t_context->flow()->process_ayiya(this);
	BINPAC_ASSERT(t_begin_of_data + (t_PDU__size) <= t_end_of_data);
	return t_PDU__size;
	}

AYIYA_Conn::AYIYA_Conn(BroAnalyzer const & bro_analyzer)
	{
	upflow_ = new AYIYA_Flow(this);
	downflow_ = new AYIYA_Flow(this);
	bro_analyzer_ = bro_analyzer;
	}

AYIYA_Conn::~AYIYA_Conn()
	{
	delete upflow_;
	upflow_ = 0;
	delete downflow_;
	downflow_ = 0;
	}

void AYIYA_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void AYIYA_Conn::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void AYIYA_Conn::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

AYIYA_Flow::AYIYA_Flow(AYIYA_Conn * connection)
	{
	connection_ = connection;
	dataunit_ = 0;
	context_ = 0;
	}

AYIYA_Flow::~AYIYA_Flow()
	{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;
	}

void AYIYA_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		dataunit_ = new PDU();
		context_ = new ContextAYIYA(connection(), this);
		int t_dataunit__size;
		t_dataunit__size = dataunit_->Parse(t_begin_of_data, t_end_of_data, context_);
		// Evaluate 'let' and 'withinput' fields
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		}
	catch ( binpac::Exception const &e )
		{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		throw;
		}
	}

void AYIYA_Flow::NewGap(int gap_length)
	{
	}
void AYIYA_Flow::FlowEOF()
	{
	}
bool AYIYA_Flow::process_ayiya(PDU * pdu)
	{

		Connection *c = connection()->bro_analyzer()->Conn();
		const EncapsulationStack* e = c->GetEncapsulation();

		if ( e && e->Depth() >= BifConst::Tunnel::max_depth )
			{
			reporter->Weird(c, "tunnel_depth");
			return false;
			}

		if ( pdu->op() != 1 )
			{
			// 1 is the "forward" command.
			return false;
			}

		if ( pdu->next_header() != IPPROTO_IPV6 &&
		     pdu->next_header() != IPPROTO_IPV4 )
			{
			reporter->Weird(c, "ayiya_tunnel_non_ip");
			return false;
			}

		if ( pdu->packet().length() < (int)sizeof(struct ip) )
			{
			connection()->bro_analyzer()->ProtocolViolation(
			    "Truncated AYIYA", (const char*) pdu->packet().data(),
			    pdu->packet().length());
			return false;
			}

		const struct ip* ip = (const struct ip*) pdu->packet().data();

		if ( ( pdu->next_header() == IPPROTO_IPV6 && ip->ip_v != 6 ) ||
		     ( pdu->next_header() == IPPROTO_IPV4 && ip->ip_v != 4) )
			{
			connection()->bro_analyzer()->ProtocolViolation(
			    "AYIYA next header mismatch", (const char*)pdu->packet().data(),
			     pdu->packet().length());
			return false;
			}

		IP_Hdr* inner = 0;
		int result = sessions->ParseIPPacket(pdu->packet().length(),
		     pdu->packet().data(), pdu->next_header(), inner);

		if ( result == 0 )
			connection()->bro_analyzer()->ProtocolConfirmation();

		else if ( result < 0 )
			connection()->bro_analyzer()->ProtocolViolation(
			    "Truncated AYIYA", (const char*) pdu->packet().data(),
			    pdu->packet().length());

		else
			connection()->bro_analyzer()->ProtocolViolation(
			    "AYIYA payload length", (const char*) pdu->packet().data(),
			    pdu->packet().length());

		if ( result != 0 )
			{
			delete inner;
			return false;
			}

		EncapsulatingConn ec(c, BifEnum::Tunnel::AYIYA);

		sessions->DoNextInnerPacket(network_time(), 0, inner, e, ec);

		return true;
		
	}

} // namespace AYIYA
}  // namespace binpac

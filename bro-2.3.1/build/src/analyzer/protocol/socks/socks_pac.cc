// This file is automatically generated from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/socks/socks.pac.


#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include "/home/benjamin/Bro/bro-2.3.1/build/src/analyzer/protocol/socks/socks_pac.h"

namespace binpac {






namespace SOCKS {
ContextSOCKS::ContextSOCKS(SOCKS_Conn * connection, SOCKS_Flow * flow)
	{
	connection_ = connection;
	flow_ = flow;
	}

ContextSOCKS::~ContextSOCKS()
	{
	}

SOCKS_Conn::SOCKS_Conn(BroAnalyzer const & bro_analyzer)
	{
	upflow_ = new SOCKS_Flow(this, true);
	downflow_ = new SOCKS_Flow(this, false);
	bro_analyzer_ = bro_analyzer;

		v5_authenticated_ = false;
	
	}

SOCKS_Conn::~SOCKS_Conn()
	{
	delete upflow_;
	upflow_ = 0;
	delete downflow_;
	downflow_ = 0;
	}

void SOCKS_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void SOCKS_Conn::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void SOCKS_Conn::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

bool SOCKS_Conn::v5_past_authentication()
	{

		return v5_authenticated_;
		
	}

bool SOCKS_Conn::set_v5_past_authentication()
	{

		v5_authenticated_ = true;
		return true;
		
	}

bool SOCKS_Conn::socks4_request(SOCKS4_Request * request)
	{

		RecordVal* sa = new RecordVal(socks_address);
		sa->Assign(0, new AddrVal(htonl(request->addr())));
		if ( request->v4a() )
			sa->Assign(1, array_to_string(request->name()));

		BifEvent::generate_socks_request(bro_analyzer(),
		                                 bro_analyzer()->Conn(),
		                                 4,
		                                 request->command(),
		                                 sa,
		                                 new PortVal(request->port() | TCP_PORT_MASK),
		                                 array_to_string(request->user()));

		static_cast<analyzer::socks::SOCKS_Analyzer*>(bro_analyzer())->EndpointDone(true);

		return true;
		
	}

bool SOCKS_Conn::socks4_reply(SOCKS4_Reply * reply)
	{

		RecordVal* sa = new RecordVal(socks_address);
		sa->Assign(0, new AddrVal(htonl(reply->addr())));

		BifEvent::generate_socks_reply(bro_analyzer(),
		                               bro_analyzer()->Conn(),
		                               4,
		                               reply->status(),
		                               sa,
		                               new PortVal(reply->port() | TCP_PORT_MASK));

		bro_analyzer()->ProtocolConfirmation();
		static_cast<analyzer::socks::SOCKS_Analyzer*>(bro_analyzer())->EndpointDone(false);
		return true;
		
	}

bool SOCKS_Conn::socks5_request(SOCKS5_Request * request)
	{

		if ( request->reserved() != 0 )
			{
			bro_analyzer()->ProtocolViolation(fmt("invalid value in reserved field: %d", request->reserved()));
			bro_analyzer()->SetSkip(true);
			return false;
			}

		if ( (request->command() == 0) || (request->command() > 3) )
			{
			bro_analyzer()->ProtocolViolation(fmt("undefined value in command field: %d", request->command()));
			bro_analyzer()->SetSkip(true);
			return false;
			}

		RecordVal* sa = new RecordVal(socks_address);

		// This is dumb and there must be a better way (checking for presence of a field)...
		switch ( request->remote_name()->addr_type() )
			{
			case 1:
				sa->Assign(0, new AddrVal(htonl(request->remote_name()->ipv4())));
				break;

			case 3:
				sa->Assign(1, new StringVal(request->remote_name()->domain_name()->name().length(),
				                         (const char*) request->remote_name()->domain_name()->name().data()));
				break;

			case 4:
				sa->Assign(0, new AddrVal(IPAddr(IPv6, (const uint32_t*) request->remote_name()->ipv6(), IPAddr::Network)));
				break;

			default:
				bro_analyzer()->ProtocolViolation(fmt("invalid SOCKSv5 addr type: %d", request->remote_name()->addr_type()));
				Unref(sa);
				return false;
			}

		BifEvent::generate_socks_request(bro_analyzer(),
		                                 bro_analyzer()->Conn(),
		                                 5,
		                                 request->command(),
		                                 sa,
		                                 new PortVal(request->port() | TCP_PORT_MASK),
		                                 new StringVal(""));

		static_cast<analyzer::socks::SOCKS_Analyzer*>(bro_analyzer())->EndpointDone(true);

		return true;
		
	}

bool SOCKS_Conn::socks5_reply(SOCKS5_Reply * reply)
	{

		RecordVal* sa = new RecordVal(socks_address);
		
		// This is dumb and there must be a better way (checking for presence of a field)...
		switch ( reply->bound()->addr_type() )
			{
			case 1:
				sa->Assign(0, new AddrVal(htonl(reply->bound()->ipv4())));
				break;

			case 3:
				sa->Assign(1, new StringVal(reply->bound()->domain_name()->name().length(),
				                         (const char*) reply->bound()->domain_name()->name().data()));
				break;

			case 4:
				sa->Assign(0, new AddrVal(IPAddr(IPv6, (const uint32_t*) reply->bound()->ipv6(), IPAddr::Network)));
				break;

			default:
				bro_analyzer()->ProtocolViolation(fmt("invalid SOCKSv5 addr type: %d", reply->bound()->addr_type()));
				Unref(sa);
				return false;
			}

		BifEvent::generate_socks_reply(bro_analyzer(),
		                               bro_analyzer()->Conn(),
		                               5,
		                               reply->reply(),
		                               sa,
		                               new PortVal(reply->port() | TCP_PORT_MASK));

		bro_analyzer()->ProtocolConfirmation();
		static_cast<analyzer::socks::SOCKS_Analyzer*>(bro_analyzer())->EndpointDone(false);
		return true;
		
	}

bool SOCKS_Conn::version_error(uint8 version)
	{

		bro_analyzer()->ProtocolViolation(fmt("unsupported/unknown SOCKS version %d", version));
		return true;
		
	}

SOCKS_Version::SOCKS_Version(bool is_orig)
	{
	version_ = 0;
	msg_case_index_ = -1;
	socks4_msg_ = 0;
	socks5_msg_ = 0;
	socks_msg_fail_ = 0;
	is_orig_ = is_orig;
	}

SOCKS_Version::~SOCKS_Version()
	{
	switch ( msg_case_index() )
		{
		case 4:
			// Clean up "socks4_msg"
			{
			delete socks4_msg_;
			socks4_msg_ = 0;
			}
			break;
		case 5:
			// Clean up "socks5_msg"
			{
			delete socks5_msg_;
			socks5_msg_ = 0;
			}
			break;
		default:
			// Clean up "socks_msg_fail"
			{
			delete socks_msg_fail_;
			socks_msg_fail_ = 0;
			}
			break;
		}
	}

int SOCKS_Version::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSOCKS * t_context)
	{
	// Checking out-of-bound for "SOCKS_Version:version"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SOCKS_Version:version",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "version"
	version_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "msg"
	int t_msg__size;
	msg_case_index_ = version();
	switch ( msg_case_index() )
		{
		case 4:
			// Parse "socks4_msg"
			{
			socks4_msg_ = new SOCKS4_Message(is_orig());
			int t_socks4_msg__size;
			t_socks4_msg__size = socks4_msg_->Parse((t_begin_of_data + 1), t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_msg__size = t_socks4_msg__size;
			}
			break;
		case 5:
			// Parse "socks5_msg"
			{
			socks5_msg_ = new SOCKS5_Message(is_orig());
			int t_socks5_msg__size;
			t_socks5_msg__size = socks5_msg_->Parse((t_begin_of_data + 1), t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_msg__size = t_socks5_msg__size;
			}
			break;
		default:
			// Parse "socks_msg_fail"
			{
			socks_msg_fail_ = new SOCKS_Version_Error(version());
			socks_msg_fail_->Parse(0, 0, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_msg__size = 0;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_SOCKS_Version__size;
	const_byteptr const t_dataptr_after_msg = (t_begin_of_data + 1) + (t_msg__size);
	BINPAC_ASSERT(t_dataptr_after_msg <= t_end_of_data);
	t_SOCKS_Version__size = t_dataptr_after_msg - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SOCKS_Version__size) <= t_end_of_data);
	return t_SOCKS_Version__size;
	}

SOCKS_Version_Error::SOCKS_Version_Error(uint8 version)
	{
	version_ = version;
	proc_ = 0;
	}

SOCKS_Version_Error::~SOCKS_Version_Error()
	{
	}

int SOCKS_Version_Error::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSOCKS * t_context)
	{
	// Checking out-of-bound for "SOCKS_Version_Error"
	if ( t_begin_of_data + (0) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SOCKS_Version_Error",
			(0) + (0), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "nothing"
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->version_error(version());
	BINPAC_ASSERT(t_begin_of_data + (0) <= t_end_of_data);
	return 0;
	}

SOCKS5_Message::SOCKS5_Message(bool is_orig)
	{
	val_case_index_ = -1;
	msg_ = 0;
	auth_ = 0;
	is_orig_ = is_orig;
	}

SOCKS5_Message::~SOCKS5_Message()
	{
	switch ( val_case_index() )
		{
		case 1:
			// Clean up "msg"
			{
			delete msg_;
			msg_ = 0;
			}
			break;
		case 0:
			// Clean up "auth"
			{
			delete auth_;
			auth_ = 0;
			}
			break;
		}
	}

int SOCKS5_Message::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSOCKS * t_context)
	{
	int t_val__size;
	val_case_index_ = t_context->connection()->v5_past_authentication();
	switch ( val_case_index() )
		{
		case 1:
			// Parse "msg"
			{
			msg_ = new SOCKS5_Real_Message(is_orig());
			int t_msg__size;
			t_msg__size = msg_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_msg__size;
			}
			break;
		case 0:
			// Parse "auth"
			{
			auth_ = new SOCKS5_Auth_Negotiation(is_orig());
			int t_auth__size;
			t_auth__size = auth_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_auth__size;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("SOCKS5_Message", val_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

SOCKS5_Auth_Negotiation::SOCKS5_Auth_Negotiation(bool is_orig)
	{
	val_case_index_ = -1;
	req_ = 0;
	rep_ = 0;
	is_orig_ = is_orig;
	}

SOCKS5_Auth_Negotiation::~SOCKS5_Auth_Negotiation()
	{
	switch ( val_case_index() )
		{
		case 1:
			// Clean up "req"
			{
			delete req_;
			req_ = 0;
			}
			break;
		case 0:
			// Clean up "rep"
			{
			delete rep_;
			rep_ = 0;
			}
			break;
		}
	}

int SOCKS5_Auth_Negotiation::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSOCKS * t_context)
	{
	int t_val__size;
	val_case_index_ = is_orig();
	switch ( val_case_index() )
		{
		case 1:
			// Parse "req"
			{
			req_ = new SOCKS5_Auth_Negotiation_Request();
			int t_req__size;
			t_req__size = req_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_req__size;
			}
			break;
		case 0:
			// Parse "rep"
			{
			rep_ = new SOCKS5_Auth_Negotiation_Reply();
			rep_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 1;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("SOCKS5_Auth_Negotiation", val_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

SOCKS5_Auth_Negotiation_Request::SOCKS5_Auth_Negotiation_Request()
	{
	method_count_ = 0;
	methods_ = 0;
	methods__elem_ = 0;
	}

SOCKS5_Auth_Negotiation_Request::~SOCKS5_Auth_Negotiation_Request()
	{
	delete methods_;
	}

int SOCKS5_Auth_Negotiation_Request::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SOCKS5_Auth_Negotiation_Request:method_count"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SOCKS5_Auth_Negotiation_Request:method_count",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "method_count"
	method_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "methods"
	int t_methods__arraylength;
	t_methods__arraylength = 0;
	t_methods__arraylength = method_count();
	if ( t_begin_of_data + t_methods__arraylength > t_end_of_data + 1 )
		{
		t_methods__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_methods__arraylength < 0 )
		{
		t_methods__arraylength = 0;
		}
	methods__elem_ = 0;
	int t_methods__elem__it;
	t_methods__elem__it = 0;
	int t_methods__size;
	methods_ = new vector<uint8>;
	methods_->reserve(t_methods__arraylength);
	const_byteptr t_methods__elem__dataptr = (t_begin_of_data + 1);
	for (; t_methods__elem__it < t_methods__arraylength; ++t_methods__elem__it)
		{
		// Check &until(methods__elem__dataptr >= end_of_data)
		if ( t_methods__elem__dataptr >= t_end_of_data )
			{
			goto end_of_methods;
			}
		// Checking out-of-bound for "SOCKS5_Auth_Negotiation_Request:methods__elem"
		if ( t_methods__elem__dataptr + (1) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("SOCKS5_Auth_Negotiation_Request:methods__elem",
				((t_methods__elem__dataptr - t_begin_of_data)) + (1), 
				(t_end_of_data) - (t_begin_of_data));
			}
		methods__elem_ = *((uint8 const *) (t_methods__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		methods_->push_back(methods__elem_);
		t_methods__elem__dataptr += 1;
		BINPAC_ASSERT(t_methods__elem__dataptr <= t_end_of_data);
		}
end_of_methods: ;
	t_methods__size = t_methods__elem__dataptr - ((t_begin_of_data + 1));
	// Evaluate 'let' and 'withinput' fields
	
	int t_SOCKS5_Auth_Negotiation_Request__size;
	const_byteptr const t_dataptr_after_methods = (t_begin_of_data + 1) + (t_methods__size);
	BINPAC_ASSERT(t_dataptr_after_methods <= t_end_of_data);
	t_SOCKS5_Auth_Negotiation_Request__size = t_dataptr_after_methods - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SOCKS5_Auth_Negotiation_Request__size) <= t_end_of_data);
	return t_SOCKS5_Auth_Negotiation_Request__size;
	}

SOCKS5_Auth_Negotiation_Reply::SOCKS5_Auth_Negotiation_Reply()
	{
	selected_auth_method_ = 0;
	past_auth_ = 0;
	}

SOCKS5_Auth_Negotiation_Reply::~SOCKS5_Auth_Negotiation_Reply()
	{
	}

int SOCKS5_Auth_Negotiation_Reply::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSOCKS * t_context)
	{
	// Checking out-of-bound for "SOCKS5_Auth_Negotiation_Reply"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SOCKS5_Auth_Negotiation_Reply",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "selected_auth_method"
	selected_auth_method_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	past_auth_ = t_context->connection()->set_v5_past_authentication();
	BINPAC_ASSERT(t_begin_of_data + (1) <= t_end_of_data);
	return 1;
	}

SOCKS5_Real_Message::SOCKS5_Real_Message(bool is_orig)
	{
	val_case_index_ = -1;
	request_ = 0;
	reply_ = 0;
	is_orig_ = is_orig;
	}

SOCKS5_Real_Message::~SOCKS5_Real_Message()
	{
	switch ( val_case_index() )
		{
		case 1:
			// Clean up "request"
			{
			delete request_;
			request_ = 0;
			}
			break;
		case 0:
			// Clean up "reply"
			{
			delete reply_;
			reply_ = 0;
			}
			break;
		}
	}

int SOCKS5_Real_Message::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSOCKS * t_context)
	{
	int t_val__size;
	val_case_index_ = is_orig();
	switch ( val_case_index() )
		{
		case 1:
			// Parse "request"
			{
			request_ = new SOCKS5_Request();
			int t_request__size;
			t_request__size = request_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_request__size;
			}
			break;
		case 0:
			// Parse "reply"
			{
			reply_ = new SOCKS5_Reply();
			int t_reply__size;
			t_reply__size = reply_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_reply__size;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("SOCKS5_Real_Message", val_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

Domain_Name::Domain_Name()
	{
	len_ = 0;
	byteorder_ = bigendian;
	}

Domain_Name::~Domain_Name()
	{
	name_.free();
	}

int Domain_Name::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Domain_Name:len"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Domain_Name:len",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "len"
	len_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "name"
	int t_name__size;
	t_name__size = len();
	// Checking out-of-bound for "Domain_Name:name"
	if ( (t_begin_of_data + 1) + (t_name__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Domain_Name:name",
			(1) + (t_name__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 1) + t_name__size;
	int t_name_string_length;
	t_name_string_length = len();
	// check for negative sizes
	if ( t_name_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/socks/socks-protocol.pac:44", t_name_string_length);
	name_.init((t_begin_of_data + 1), t_name_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_Domain_Name__size;
	const_byteptr const t_dataptr_after_name = (t_begin_of_data + 1) + (t_name__size);
	BINPAC_ASSERT(t_dataptr_after_name <= t_end_of_data);
	t_Domain_Name__size = t_dataptr_after_name - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Domain_Name__size) <= t_end_of_data);
	return t_Domain_Name__size;
	}

SOCKS5_Address::SOCKS5_Address()
	{
	addr_type_ = 0;
	addr_case_index_ = -1;
	ipv4_ = 0;
	domain_name_ = 0;
	ipv6_ = 0;
	ipv6__elem_ = 0;
	byteorder_ = bigendian;
	}

SOCKS5_Address::~SOCKS5_Address()
	{
	switch ( addr_case_index() )
		{
		case 1:
			// Clean up "ipv4"
			{
			}
			break;
		case 3:
			// Clean up "domain_name"
			{
			delete domain_name_;
			domain_name_ = 0;
			}
			break;
		case 4:
			// Clean up "ipv6"
			{
			delete ipv6_;
			}
			break;
		default:
			// Clean up "err"
			{
			}
			break;
		}
	}

int SOCKS5_Address::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SOCKS5_Address:addr_type"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SOCKS5_Address:addr_type",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "addr_type"
	addr_type_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "addr"
	int t_addr__size;
	addr_case_index_ = addr_type();
	switch ( addr_case_index() )
		{
		case 1:
			// Parse "ipv4"
			{
			// Checking out-of-bound for "SOCKS5_Address:ipv4"
			if ( (t_begin_of_data + 1) + (4) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("SOCKS5_Address:ipv4",
					(1) + (4), 
					(t_end_of_data) - (t_begin_of_data));
				}
			ipv4_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
			// Evaluate 'let' and 'withinput' fields
			t_addr__size = 4;
			}
			break;
		case 3:
			// Parse "domain_name"
			{
			domain_name_ = new Domain_Name();
			int t_domain_name__size;
			t_domain_name__size = domain_name_->Parse((t_begin_of_data + 1), t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_addr__size = t_domain_name__size;
			}
			break;
		case 4:
			// Parse "ipv6"
			{
			int t_ipv6__arraylength;
			t_ipv6__arraylength = 0;
			t_ipv6__arraylength = 4;
			if ( t_begin_of_data + t_ipv6__arraylength > t_end_of_data + 1 )
				{
				t_ipv6__arraylength = t_end_of_data - t_begin_of_data + 1;
				}
			if ( t_ipv6__arraylength < 0 )
				{
				t_ipv6__arraylength = 0;
				}
			ipv6__elem_ = 0;
			int t_ipv6__elem__it;
			t_ipv6__elem__it = 0;
			ipv6_ = new vector<uint32>;
			ipv6_->reserve(t_ipv6__arraylength);
			const_byteptr t_ipv6__elem__dataptr = (t_begin_of_data + 1);
			for (; t_ipv6__elem__it < t_ipv6__arraylength; ++t_ipv6__elem__it)
				{
				// Check &until(ipv6__elem__dataptr >= end_of_data)
				if ( t_ipv6__elem__dataptr >= t_end_of_data )
					{
					goto end_of_ipv6;
					}
				// Checking out-of-bound for "SOCKS5_Address:ipv6__elem"
				if ( t_ipv6__elem__dataptr + (4) > t_end_of_data )
					{
					// Handle out-of-bound condition
					throw binpac::ExceptionOutOfBound("SOCKS5_Address:ipv6__elem",
						((t_ipv6__elem__dataptr - t_begin_of_data)) + (4), 
						(t_end_of_data) - (t_begin_of_data));
					}
				ipv6__elem_ = FixByteOrder(byteorder(), *((uint32 const *) (t_ipv6__elem__dataptr)));
				// Evaluate 'let' and 'withinput' fields
				ipv6_->push_back(ipv6__elem_);
				t_ipv6__elem__dataptr += 4;
				BINPAC_ASSERT(t_ipv6__elem__dataptr <= t_end_of_data);
				}
		end_of_ipv6: ;
			// Evaluate 'let' and 'withinput' fields
			t_addr__size = 16;
			}
			break;
		default:
			// Parse "err"
			{
			int t_err_string_length;
			t_err_string_length = (t_end_of_data) - ((t_begin_of_data + 1));
			int t_err__size;
			t_err__size = t_err_string_length;
			// check for negative sizes
			if ( t_err_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/socks/socks-protocol.pac:53", t_err_string_length);
			err_.init((t_begin_of_data + 1), t_err_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_addr__size = t_err__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_SOCKS5_Address__size;
	const_byteptr const t_dataptr_after_addr = (t_begin_of_data + 1) + (t_addr__size);
	BINPAC_ASSERT(t_dataptr_after_addr <= t_end_of_data);
	t_SOCKS5_Address__size = t_dataptr_after_addr - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SOCKS5_Address__size) <= t_end_of_data);
	return t_SOCKS5_Address__size;
	}

SOCKS5_Request::SOCKS5_Request()
	{
	command_ = 0;
	reserved_ = 0;
	remote_name_ = 0;
	port_ = 0;
	byteorder_ = bigendian;
	proc_ = 0;
	}

SOCKS5_Request::~SOCKS5_Request()
	{
	delete remote_name_;
	remote_name_ = 0;
	}

int SOCKS5_Request::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSOCKS * t_context)
	{
	// Checking out-of-bound for "SOCKS5_Request:reserved"
	if ( (t_begin_of_data + 1) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SOCKS5_Request:reserved",
			(1) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "command"
	command_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "reserved"
	reserved_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "remote_name"
	remote_name_ = new SOCKS5_Address();
	int t_remote_name__size;
	t_remote_name__size = remote_name_->Parse((t_begin_of_data + 2), t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_remote_name = (t_begin_of_data + 2) + (t_remote_name__size);
	BINPAC_ASSERT(t_dataptr_after_remote_name <= t_end_of_data);
	// Checking out-of-bound for "SOCKS5_Request:port"
	if ( t_dataptr_after_remote_name + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SOCKS5_Request:port",
			((t_dataptr_after_remote_name - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "port"
	port_ = FixByteOrder(byteorder(), *((uint16 const *) (t_dataptr_after_remote_name)));
	// Evaluate 'let' and 'withinput' fields
	
	int t_SOCKS5_Request__size;
	t_SOCKS5_Request__size = (t_dataptr_after_remote_name + 2) - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->socks5_request(this);
	BINPAC_ASSERT(t_begin_of_data + (t_SOCKS5_Request__size) <= t_end_of_data);
	return t_SOCKS5_Request__size;
	}

SOCKS5_Reply::SOCKS5_Reply()
	{
	reply_ = 0;
	reserved_ = 0;
	bound_ = 0;
	port_ = 0;
	byteorder_ = bigendian;
	proc_ = 0;
	}

SOCKS5_Reply::~SOCKS5_Reply()
	{
	delete bound_;
	bound_ = 0;
	}

int SOCKS5_Reply::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSOCKS * t_context)
	{
	// Checking out-of-bound for "SOCKS5_Reply:reserved"
	if ( (t_begin_of_data + 1) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SOCKS5_Reply:reserved",
			(1) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "reply"
	reply_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "reserved"
	reserved_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "bound"
	bound_ = new SOCKS5_Address();
	int t_bound__size;
	t_bound__size = bound_->Parse((t_begin_of_data + 2), t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_bound = (t_begin_of_data + 2) + (t_bound__size);
	BINPAC_ASSERT(t_dataptr_after_bound <= t_end_of_data);
	// Checking out-of-bound for "SOCKS5_Reply:port"
	if ( t_dataptr_after_bound + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SOCKS5_Reply:port",
			((t_dataptr_after_bound - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "port"
	port_ = FixByteOrder(byteorder(), *((uint16 const *) (t_dataptr_after_bound)));
	// Evaluate 'let' and 'withinput' fields
	
	int t_SOCKS5_Reply__size;
	t_SOCKS5_Reply__size = (t_dataptr_after_bound + 2) - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->socks5_reply(this);
	BINPAC_ASSERT(t_begin_of_data + (t_SOCKS5_Reply__size) <= t_end_of_data);
	return t_SOCKS5_Reply__size;
	}

SOCKS4_Message::SOCKS4_Message(bool is_orig)
	{
	val_case_index_ = -1;
	request_ = 0;
	reply_ = 0;
	is_orig_ = is_orig;
	}

SOCKS4_Message::~SOCKS4_Message()
	{
	switch ( val_case_index() )
		{
		case 1:
			// Clean up "request"
			{
			delete request_;
			request_ = 0;
			}
			break;
		case 0:
			// Clean up "reply"
			{
			delete reply_;
			reply_ = 0;
			}
			break;
		}
	}

int SOCKS4_Message::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSOCKS * t_context)
	{
	int t_val__size;
	val_case_index_ = is_orig();
	switch ( val_case_index() )
		{
		case 1:
			// Parse "request"
			{
			request_ = new SOCKS4_Request();
			int t_request__size;
			t_request__size = request_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_request__size;
			}
			break;
		case 0:
			// Parse "reply"
			{
			reply_ = new SOCKS4_Reply();
			reply_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 8;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("SOCKS4_Message", val_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

SOCKS4_Request::SOCKS4_Request()
	{
	command_ = 0;
	port_ = 0;
	addr_ = 0;
	user_ = 0;
	user__elem_ = 0;
	host_case_index_ = -1;
	name_ = 0;
	name__elem_ = 0;
	empty_ = 0;
	empty__elem_ = 0;
	byteorder_ = bigendian;
	v4a_ = 0;
	proc_ = 0;
	}

SOCKS4_Request::~SOCKS4_Request()
	{
	delete user_;
	switch ( host_case_index() )
		{
		case 1:
			// Clean up "name"
			{
			delete name_;
			}
			break;
		case 0:
			// Clean up "empty"
			{
			delete empty_;
			}
			break;
		}
	}

int SOCKS4_Request::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSOCKS * t_context)
	{
	// Checking out-of-bound for "SOCKS4_Request:addr"
	if ( (t_begin_of_data + 3) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SOCKS4_Request:addr",
			(3) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "command"
	command_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "port"
	port_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "addr"
	addr_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 3))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "user"
	int t_user__arraylength;
	t_user__arraylength = 0;
	user__elem_ = 0;
	int t_user__elem__it;
	t_user__elem__it = 0;
	int t_user__size;
	user_ = new vector<uint8>;
	const_byteptr t_user__elem__dataptr = (t_begin_of_data + 7);
	for (; /* forever */; ++t_user__elem__it)
		{
		// Check &until(user__elem__dataptr >= end_of_data)
		if ( t_user__elem__dataptr >= t_end_of_data )
			{
			goto end_of_user;
			}
		// Checking out-of-bound for "SOCKS4_Request:user__elem"
		if ( t_user__elem__dataptr + (1) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("SOCKS4_Request:user__elem",
				((t_user__elem__dataptr - t_begin_of_data)) + (1), 
				(t_end_of_data) - (t_begin_of_data));
			}
		user__elem_ = *((uint8 const *) (t_user__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		user_->push_back(user__elem_);
		t_user__elem__dataptr += 1;
		BINPAC_ASSERT(t_user__elem__dataptr <= t_end_of_data);
		// Check &until( ( $element == ((int) 0) ) )
		if (  ( user__elem_ == 0 )  )
			{
			goto end_of_user;
			}
		}
end_of_user: ;
	t_user__size = t_user__elem__dataptr - ((t_begin_of_data + 7));
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_user = (t_begin_of_data + 7) + (t_user__size);
	BINPAC_ASSERT(t_dataptr_after_user <= t_end_of_data);
	// Parse "host"
	v4a_ =  ( addr() <= 0x000000ff ) ;
	int t_host__size;
	host_case_index_ = v4a();
	switch ( host_case_index() )
		{
		case 1:
			// Parse "name"
			{
			int t_name__arraylength;
			t_name__arraylength = 0;
			name__elem_ = 0;
			int t_name__elem__it;
			t_name__elem__it = 0;
			int t_name__size;
			name_ = new vector<uint8>;
			const_byteptr t_name__elem__dataptr = t_dataptr_after_user;
			for (; /* forever */; ++t_name__elem__it)
				{
				// Check &until(name__elem__dataptr >= end_of_data)
				if ( t_name__elem__dataptr >= t_end_of_data )
					{
					goto end_of_name;
					}
				// Checking out-of-bound for "SOCKS4_Request:name__elem"
				if ( t_name__elem__dataptr + (1) > t_end_of_data )
					{
					// Handle out-of-bound condition
					throw binpac::ExceptionOutOfBound("SOCKS4_Request:name__elem",
						((t_name__elem__dataptr - t_begin_of_data)) + (1), 
						(t_end_of_data) - (t_begin_of_data));
					}
				name__elem_ = *((uint8 const *) (t_name__elem__dataptr));
				// Evaluate 'let' and 'withinput' fields
				name_->push_back(name__elem_);
				t_name__elem__dataptr += 1;
				BINPAC_ASSERT(t_name__elem__dataptr <= t_end_of_data);
				// Check &until( ( $element == ((int) 0) ) )
				if (  ( name__elem_ == 0 )  )
					{
					goto end_of_name;
					}
				}
		end_of_name: ;
			t_name__size = t_name__elem__dataptr - (t_dataptr_after_user);
			// Evaluate 'let' and 'withinput' fields
			t_host__size = t_name__size;
			}
			break;
		case 0:
			// Parse "empty"
			{
			// Checking out-of-bound for "SOCKS4_Request:empty"
			if ( t_dataptr_after_user + (0) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("SOCKS4_Request:empty",
					((t_dataptr_after_user - t_begin_of_data)) + (0), 
					(t_end_of_data) - (t_begin_of_data));
				}
			{
			// Setting t_end_of_data with &length
			const_byteptr t_end_of_data = t_dataptr_after_user + 0;
			int t_empty__arraylength;
			t_empty__arraylength = 0;
			empty__elem_ = 0;
			int t_empty__elem__it;
			t_empty__elem__it = 0;
			int t_empty__size;
			empty_ = new vector<uint8>;
			const_byteptr t_empty__elem__dataptr = t_dataptr_after_user;
			for (; /* forever */; ++t_empty__elem__it)
				{
				// Check &until(empty__elem__dataptr >= end_of_data)
				if ( t_empty__elem__dataptr >= t_end_of_data )
					{
					goto end_of_empty;
					}
				empty__elem_ = *((uint8 const *) (t_empty__elem__dataptr));
				// Evaluate 'let' and 'withinput' fields
				empty_->push_back(empty__elem_);
				t_empty__elem__dataptr += 1;
				BINPAC_ASSERT(t_empty__elem__dataptr <= t_end_of_data);
				}
		end_of_empty: ;
			t_empty__size = t_empty__elem__dataptr - (t_dataptr_after_user);
			// Evaluate 'let' and 'withinput' fields
			}
			t_host__size = 0;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("SOCKS4_Request", host_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_SOCKS4_Request__size;
	const_byteptr const t_dataptr_after_host = t_dataptr_after_user + (t_host__size);
	BINPAC_ASSERT(t_dataptr_after_host <= t_end_of_data);
	t_SOCKS4_Request__size = t_dataptr_after_host - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->socks4_request(this);
	BINPAC_ASSERT(t_begin_of_data + (t_SOCKS4_Request__size) <= t_end_of_data);
	return t_SOCKS4_Request__size;
	}

SOCKS4_Reply::SOCKS4_Reply()
	{
	zero_ = 0;
	status_ = 0;
	port_ = 0;
	addr_ = 0;
	byteorder_ = bigendian;
	proc_ = 0;
	}

SOCKS4_Reply::~SOCKS4_Reply()
	{
	}

int SOCKS4_Reply::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSOCKS * t_context)
	{
	// Checking out-of-bound for "SOCKS4_Reply"
	if ( t_begin_of_data + (8) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SOCKS4_Reply",
			(0) + (8), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "zero"
	zero_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "status"
	status_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "port"
	port_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "addr"
	addr_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->socks4_reply(this);
	BINPAC_ASSERT(t_begin_of_data + (8) <= t_end_of_data);
	return 8;
	}

SOCKS_Flow::SOCKS_Flow(SOCKS_Conn * connection, bool is_orig)
	{
	connection_ = connection;
	is_orig_ = is_orig;
	dataunit_ = 0;
	context_ = 0;
	}

SOCKS_Flow::~SOCKS_Flow()
	{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;
	}

void SOCKS_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		dataunit_ = new SOCKS_Version(is_orig());
		context_ = new ContextSOCKS(connection(), this);
		int t_dataunit__size;
		t_dataunit__size = dataunit_->Parse(t_begin_of_data, t_end_of_data, context_);
		// Evaluate 'let' and 'withinput' fields
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		}
	catch ( binpac::Exception const &e )
		{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		throw;
		}
	}

void SOCKS_Flow::NewGap(int gap_length)
	{
	}
void SOCKS_Flow::FlowEOF()
	{
	}

StringVal* array_to_string(vector<uint8> *a)
	{
	int len = a->size();
	char tmp[len];
	char *s = tmp;
	for ( vector<uint8>::iterator i = a->begin(); i != a->end(); *s++ = *i++ );

	while ( len > 0 && tmp[len-1] == '\0' )
		--len;

	return new StringVal(len, tmp);
	}

} // namespace SOCKS
}  // namespace binpac

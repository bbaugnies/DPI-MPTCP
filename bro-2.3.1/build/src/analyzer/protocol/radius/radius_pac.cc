// This file is automatically generated from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/radius/radius.pac.


#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include "/home/benjamin/Bro/bro-2.3.1/build/src/analyzer/protocol/radius/radius_pac.h"

namespace binpac {






namespace RADIUS {
ContextRADIUS::ContextRADIUS(RADIUS_Conn * connection, RADIUS_Flow * flow)
	{
	connection_ = connection;
	flow_ = flow;
	}

ContextRADIUS::~ContextRADIUS()
	{
	}

RADIUS_Conn::RADIUS_Conn(BroAnalyzer const & bro_analyzer)
	{
	upflow_ = new RADIUS_Flow(this, true);
	downflow_ = new RADIUS_Flow(this, false);
	bro_analyzer_ = bro_analyzer;
	}

RADIUS_Conn::~RADIUS_Conn()
	{
	delete upflow_;
	upflow_ = 0;
	delete downflow_;
	downflow_ = 0;
	}

void RADIUS_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void RADIUS_Conn::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void RADIUS_Conn::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

RADIUS_PDU::RADIUS_PDU(bool is_orig)
	{
	code_ = 0;
	trans_id_ = 0;
	length_ = 0;
	attributes_ = 0;
	attributes__elem_ = 0;
	is_orig_ = is_orig;
	byteorder_ = bigendian;
	proc_ = 0;
	}

RADIUS_PDU::~RADIUS_PDU()
	{
	authenticator_.free();
	delete attributes__elem_;
	attributes__elem_ = 0;
	if ( attributes() )
		{
		for ( int i = 0; i < (int) attributes()->size(); ++i )
			{
			RADIUS_Attribute * attributes__elem_ = (*attributes_)[i];
			delete attributes__elem_;
			attributes__elem_ = 0;
			}
		}
	delete attributes_;
	}

int RADIUS_PDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextRADIUS * t_context)
	{
	// Checking out-of-bound for "RADIUS_PDU:length"
	if ( (t_begin_of_data + 2) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("RADIUS_PDU:length",
			(2) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "code"
	code_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "trans_id"
	trans_id_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "length"
	length_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "authenticator"
	// Checking out-of-bound for "RADIUS_PDU:authenticator"
	if ( (t_begin_of_data + 4) + (16) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("RADIUS_PDU:authenticator",
			(4) + (16), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 4) + 16;
	int t_authenticator_string_length;
	t_authenticator_string_length = 16;
	int t_authenticator__size;
	t_authenticator__size = t_authenticator_string_length;
	authenticator_.init((t_begin_of_data + 4), t_authenticator_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_authenticator = (t_begin_of_data + 4) + (16);
	BINPAC_ASSERT(t_dataptr_after_authenticator <= t_end_of_data);
	// Parse "attributes"
	int t_attributes__arraylength;
	t_attributes__arraylength = 0;
	attributes__elem_ = 0;
	int t_attributes__elem__it;
	t_attributes__elem__it = 0;
	int t_attributes__size;
	attributes_ = new vector<RADIUS_Attribute *>;
	const_byteptr t_attributes__elem__dataptr = t_dataptr_after_authenticator;
	for (; /* forever */; ++t_attributes__elem__it)
		{
		// Check &until(attributes__elem__dataptr >= end_of_data)
		if ( t_attributes__elem__dataptr >= t_end_of_data )
			{
			attributes__elem_ = 0;
			goto end_of_attributes;
			}
		attributes__elem_ = new RADIUS_Attribute(trans_id());
		int t_attributes__elem__size;
		t_attributes__elem__size = attributes__elem_->Parse(t_attributes__elem__dataptr, t_end_of_data, t_context);
		// Evaluate 'let' and 'withinput' fields
		attributes_->push_back(attributes__elem_);
		t_attributes__elem__dataptr += t_attributes__elem__size;
		BINPAC_ASSERT(t_attributes__elem__dataptr <= t_end_of_data);
		attributes__elem_ = 0;
		}
end_of_attributes: ;
	t_attributes__size = t_attributes__elem__dataptr - (t_dataptr_after_authenticator);
	// Evaluate 'let' and 'withinput' fields
	
	int t_RADIUS_PDU__size;
	const_byteptr const t_dataptr_after_attributes = t_dataptr_after_authenticator + (t_attributes__size);
	BINPAC_ASSERT(t_dataptr_after_attributes <= t_end_of_data);
	t_RADIUS_PDU__size = t_dataptr_after_attributes - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->flow()->proc_radius_message(this);
	BINPAC_ASSERT(t_begin_of_data + (t_RADIUS_PDU__size) <= t_end_of_data);
	return t_RADIUS_PDU__size;
	}

RADIUS_Attribute::RADIUS_Attribute(uint8 trans_id)
	{
	code_ = 0;
	length_ = 0;
	trans_id_ = trans_id;
	proc_ = 0;
	}

RADIUS_Attribute::~RADIUS_Attribute()
	{
	value_.free();
	}

int RADIUS_Attribute::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextRADIUS * t_context)
	{
	// Checking out-of-bound for "RADIUS_Attribute:length"
	if ( (t_begin_of_data + 1) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("RADIUS_Attribute:length",
			(1) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "code"
	code_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "length"
	length_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	int t_value__size;
	t_value__size = length() - 2;
	// Checking out-of-bound for "RADIUS_Attribute:value"
	if ( (t_begin_of_data + 2) + (t_value__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("RADIUS_Attribute:value",
			(2) + (t_value__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 2) + t_value__size;
	int t_value_string_length;
	t_value_string_length = length() - 2;
	// check for negative sizes
	if ( t_value_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/radius/radius-protocol.pac:13", t_value_string_length);
	value_.init((t_begin_of_data + 2), t_value_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_RADIUS_Attribute__size;
	const_byteptr const t_dataptr_after_value = (t_begin_of_data + 2) + (t_value__size);
	BINPAC_ASSERT(t_dataptr_after_value <= t_end_of_data);
	t_RADIUS_Attribute__size = t_dataptr_after_value - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->flow()->proc_radius_attribute(this);
	BINPAC_ASSERT(t_begin_of_data + (t_RADIUS_Attribute__size) <= t_end_of_data);
	return t_RADIUS_Attribute__size;
	}

RADIUS_Flow::RADIUS_Flow(RADIUS_Conn * connection, bool is_orig)
	{
	connection_ = connection;
	is_orig_ = is_orig;
	dataunit_ = 0;
	context_ = 0;
	}

RADIUS_Flow::~RADIUS_Flow()
	{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;
	}

void RADIUS_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		dataunit_ = new RADIUS_PDU(is_orig());
		context_ = new ContextRADIUS(connection(), this);
		int t_dataunit__size;
		t_dataunit__size = dataunit_->Parse(t_begin_of_data, t_end_of_data, context_);
		// Evaluate 'let' and 'withinput' fields
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		}
	catch ( binpac::Exception const &e )
		{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		throw;
		}
	}

void RADIUS_Flow::NewGap(int gap_length)
	{
	}
void RADIUS_Flow::FlowEOF()
	{
	}
bool RADIUS_Flow::proc_radius_message(RADIUS_PDU * msg)
	{

		connection()->bro_analyzer()->ProtocolConfirmation();

		if ( ! radius_message )
		    return false;

		RecordVal* result = new RecordVal(BifType::Record::RADIUS::Message);
		result->Assign(0, new Val(msg->code(), TYPE_COUNT));
		result->Assign(1, new Val(msg->trans_id(), TYPE_COUNT));
		result->Assign(2, bytestring_to_val(msg->authenticator()));

		if ( msg->attributes()->size() )
			{
			TableVal* attributes = new TableVal(BifType::Table::RADIUS::Attributes);

			for ( uint i = 0; i < msg->attributes()->size(); ++i ) {
				Val* index = new Val((*(msg->attributes()))[i]->code(), TYPE_COUNT);

				// Do we already have a vector of attributes for this type?
                Val* current = attributes->Lookup(index);
				Val* val = bytestring_to_val((*(msg->attributes()))[i]->value());

				if ( current )
					{
					VectorVal* vcurrent = current->AsVectorVal();
					vcurrent->Assign(vcurrent->Size(), val);
					}

				else
				    {
					VectorVal* attribute_list = new VectorVal(BifType::Vector::RADIUS::AttributeList);
					attribute_list->Assign((unsigned int)0, val);
					attributes->Assign(index, attribute_list);
				    }

				Unref(index);
			}

			result->Assign(3, attributes);
		}

		BifEvent::generate_radius_message(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(), result);
		return true;
		
	}

bool RADIUS_Flow::proc_radius_attribute(RADIUS_Attribute * attr)
	{

		if ( ! radius_attribute )
		    return false;

		BifEvent::generate_radius_attribute(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(),
		                                    attr->code(), bytestring_to_val(attr->value()));
		return true;
		
	}

} // namespace RADIUS
}  // namespace binpac

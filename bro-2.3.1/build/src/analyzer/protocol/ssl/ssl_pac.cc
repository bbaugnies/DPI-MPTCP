// This file is automatically generated from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl.pac.


#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include "/home/benjamin/Bro/bro-2.3.1/build/src/analyzer/protocol/ssl/ssl_pac.h"

namespace binpac {






namespace SSL {
ContextSSL::ContextSSL(SSL_Conn * connection, SSL_Flow * flow, FlowBuffer * flow_buffer)
	{
	connection_ = connection;
	flow_ = flow;
	flow_buffer_ = flow_buffer;
	}

ContextSSL::~ContextSSL()
	{
	}

SSL_Conn::SSL_Conn(BroAnalyzer const & bro_analyzer)
	{
	upflow_ = new SSL_Flow(this, true);
	downflow_ = new SSL_Flow(this, false);
	bro_analyzer_ = bro_analyzer;

		server_state_ = STATE_CLEAR;
		client_state_ = STATE_CLEAR;
		record_layer_version_ = UNKNOWN_VERSION;
		chosen_cipher_ = NO_CHOSEN_CIPHER;
	

		established_ = false;
	
	}

SSL_Conn::~SSL_Conn()
	{

	
	delete upflow_;
	upflow_ = 0;
	delete downflow_;
	downflow_ = 0;
	}

void SSL_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void SSL_Conn::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void SSL_Conn::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

int SSL_Conn::chosen_cipher()
	{
 return chosen_cipher_; 
	}

bool SSL_Conn::set_cipher(uint32 cipher)
	{

		chosen_cipher_ = cipher;
		return true;
		
	}

int SSL_Conn::determine_ssl_record_layer(uint8 head0, uint8 head1, uint8 head2, uint8 head3, uint8 head4)
	{

		// re-check record layer version to be sure that we still are synchronized with
		// the data stream
		if ( record_layer_version_ != UNKNOWN_VERSION && record_layer_version_ != SSLv20 )
			{
			uint16 version = (head1<<8) | head2;
			if ( version != SSLv30 && version != TLSv10 &&
			     version != TLSv11 && version != TLSv12 )
				{
				bro_analyzer()->ProtocolViolation(fmt("Invalid version late in TLS connection. Packet reported version: %d", version));
				return UNKNOWN_VERSION;
				}
			}

		if ( record_layer_version_ != UNKNOWN_VERSION )
			return record_layer_version_;

		if ( head0 & 0x80 )
			{
			if ( head2 == 0x01 ) // SSLv2 client hello.
				{
				uint16 version = (head3 << 8) | head4;
				if ( version != SSLv20 && version != SSLv30 && version != TLSv10 &&
				     version != TLSv11 && version != TLSv12 )
					{
					bro_analyzer()->ProtocolViolation(fmt("Invalid version in SSL client hello. Version: %d", version));
					return UNKNOWN_VERSION;
					}

				else
					return SSLv20;
				}

			else if ( head2 == 0x04 ) // SSLv2 server hello. This connection will continue using SSLv2.
				{
				record_layer_version_ = SSLv20;
				return SSLv20;
				}

			else // this is not SSL or TLS.
				{
				bro_analyzer()->ProtocolViolation(fmt("Invalid headers in SSL connection. Head1: %d, head2: %d, head3: %d", head1, head2, head3));
				return UNKNOWN_VERSION;
				}
			}

		uint16 version = (head1<<8) | head2;
		if ( version != SSLv30 && version != TLSv10 &&
		     version != TLSv11 && version != TLSv12 )
			{
			bro_analyzer()->ProtocolViolation(fmt("Invalid version in TLS connection. Version: %d", version));
			return UNKNOWN_VERSION;
			}

		if ( head0 >=20 && head0 <= 30 )
			{ // ok, set record layer version, this never can be downgraded to v2
			record_layer_version_ = version;
			return version;
			}

		bro_analyzer()->ProtocolViolation(fmt("Invalid type in TLS connection. Version: %d, Type: %d", version, head0));
		return UNKNOWN_VERSION;
		
	}

int SSL_Conn::client_state()
	{
 return client_state_; 
	}

int SSL_Conn::server_state()
	{
 return client_state_; 
	}

int SSL_Conn::state(bool is_orig)
	{

		if ( is_orig )
			return client_state_;
		else
			return server_state_;
		
	}

bool SSL_Conn::startEncryption(bool is_orig)
	{

		if ( is_orig )
			client_state_ = STATE_ENCRYPTED;
		else
			server_state_ = STATE_ENCRYPTED;
		return true;
		
	}

bool SSL_Conn::proc_alert(SSLRecord * rec, int level, int desc)
	{

		BifEvent::generate_ssl_alert(bro_analyzer(), bro_analyzer()->Conn(),
						rec->is_orig(), level, desc);
		return true;
		
	}

bool SSL_Conn::proc_client_hello(SSLRecord * rec, uint16 version, double ts, bytestring const & client_random, vector<uint8> * session_id, vector<uint16> * cipher_suites16, vector<uint24 *> * cipher_suites24)
	{

		if ( ! version_ok(version) )
			bro_analyzer()->ProtocolViolation(fmt("unsupported client SSL version 0x%04x", version));
		else
			bro_analyzer()->ProtocolConfirmation();

		if ( ssl_client_hello )
			{
			vector<int>* cipher_suites = new vector<int>();
			if ( cipher_suites16 )
				std::copy(cipher_suites16->begin(), cipher_suites16->end(), std::back_inserter(*cipher_suites));
			else
				std::transform(cipher_suites24->begin(), cipher_suites24->end(), std::back_inserter(*cipher_suites), to_int());

			VectorVal* cipher_vec = new VectorVal(internal_type("index_vec")->AsVectorType());
			for ( unsigned int i = 0; i < cipher_suites->size(); ++i )
				{
				Val* ciph = new Val((*cipher_suites)[i], TYPE_COUNT);
				cipher_vec->Assign(i, ciph);
				}

			BifEvent::generate_ssl_client_hello(bro_analyzer(), bro_analyzer()->Conn(),
							version, ts, new StringVal(client_random.length(),
							(const char*) client_random.data()),
							to_string_val(session_id),
							cipher_vec);

			delete cipher_suites;
			}

		return true;
		
	}

bool SSL_Conn::proc_server_hello(SSLRecord * rec, uint16 version, double ts, bytestring const & server_random, vector<uint8> * session_id, vector<uint16> * cipher_suites16, vector<uint24 *> * cipher_suites24, uint8 comp_method)
	{

		if ( ! version_ok(version) )
			bro_analyzer()->ProtocolViolation(fmt("unsupported server SSL version 0x%04x", version));

		if ( ssl_server_hello )
			{
			vector<int>* ciphers = new vector<int>();

			if ( cipher_suites16 )
				std::copy(cipher_suites16->begin(), cipher_suites16->end(), std::back_inserter(*ciphers));
			else
				std::transform(cipher_suites24->begin(), cipher_suites24->end(), std::back_inserter(*ciphers), to_int());

			BifEvent::generate_ssl_server_hello(bro_analyzer(),
							bro_analyzer()->Conn(),
							version, ts, new StringVal(server_random.length(),
							(const char*) server_random.data()),
							to_string_val(session_id),
							ciphers->size()==0 ? 0 : ciphers->at(0), comp_method);

			delete ciphers;
			}

		return true;
		
	}

bool SSL_Conn::proc_session_ticket_handshake(SessionTicketHandshake * rec, bool is_orig)
	{

		if ( ssl_session_ticket_handshake )
			{
			BifEvent::generate_ssl_session_ticket_handshake(bro_analyzer(),
							bro_analyzer()->Conn(),
							rec->ticket_lifetime_hint(),
							new StringVal(rec->data().length(), (const char*) rec->data().data()));
			}
		return true;
		
	}

bool SSL_Conn::proc_ssl_extension(SSLRecord * rec, int type, const_bytestring const & sourcedata)
	{

		// We cheat a little bit here. We want to throw this event
		// for every extension we encounter, even those that are
		// handled by more specialized events later. To access the
		// parsed data, we use sourcedata, which contains the whole
		// data blob of the extension, including headers. We skip
		// over those (4 bytes).
		size_t length = sourcedata.length();
		if ( length < 4 )
			{
			// This should be impossible due to the binpac parser
			// and protocol description
			bro_analyzer()->ProtocolViolation(fmt("Impossible extension length: %lu", length));
			return true;
			}

		length -= 4;
		const unsigned char* data = sourcedata.begin() + 4;

		if ( ssl_extension )
			BifEvent::generate_ssl_extension(bro_analyzer(),
						bro_analyzer()->Conn(), rec->is_orig(), type,
						new StringVal(length, reinterpret_cast<const char*>(data)));
		return true;
		
	}

bool SSL_Conn::proc_ec_point_formats(SSLRecord * rec, vector<uint8> * point_format_list)
	{

		VectorVal* points = new VectorVal(internal_type("index_vec")->AsVectorType());

		if ( point_format_list )
			{
			for ( unsigned int i = 0; i < point_format_list->size(); ++i )
				points->Assign(i, new Val((*point_format_list)[i], TYPE_COUNT));
			}

		BifEvent::generate_ssl_extension_ec_point_formats(bro_analyzer(), bro_analyzer()->Conn(),
		   rec->is_orig(), points);

		return true;
		
	}

bool SSL_Conn::proc_elliptic_curves(SSLRecord * rec, vector<uint16> * list)
	{

		VectorVal* curves = new VectorVal(internal_type("index_vec")->AsVectorType());

		if ( list )
			{
			for ( unsigned int i = 0; i < list->size(); ++i )
				curves->Assign(i, new Val((*list)[i], TYPE_COUNT));
			}

		BifEvent::generate_ssl_extension_elliptic_curves(bro_analyzer(), bro_analyzer()->Conn(),
		   rec->is_orig(), curves);

		return true;
		
	}

bool SSL_Conn::proc_apnl(SSLRecord * rec, vector<ProtocolName *> * protocols)
	{

		VectorVal* plist = new VectorVal(internal_type("string_vec")->AsVectorType());

		if ( protocols )
			{
			for ( unsigned int i = 0; i < protocols->size(); ++i )
				plist->Assign(i, new StringVal((*protocols)[i]->name().length(), (const char*) (*protocols)[i]->name().data()));
			}

		BifEvent::generate_ssl_extension_application_layer_protocol_negotiation(bro_analyzer(), bro_analyzer()->Conn(),
											rec->is_orig(), plist);

		return true;
		
	}

bool SSL_Conn::proc_server_name(SSLRecord * rec, vector<ServerName *> * list)
	{

		VectorVal* servers = new VectorVal(internal_type("string_vec")->AsVectorType());

		if ( list )
			{
			for ( unsigned int i = 0, j = 0; i < list->size(); ++i )
				{
				ServerName* servername = (*list)[i];
				if ( servername->name_type() != 0 )
					{
					bro_analyzer()->Weird(fmt("Encountered unknown type in server name ssl extension: %d", servername->name_type()));
					continue;
					}

				if ( servername->host_name() )
					servers->Assign(j++, new StringVal(servername->host_name()->host_name().length(), (const char*) servername->host_name()->host_name().data()));
				else
					bro_analyzer()->Weird("Empty server_name extension in ssl connection");
				}
			}

		BifEvent::generate_ssl_extension_server_name(bro_analyzer(), bro_analyzer()->Conn(),
		   rec->is_orig(), servers);

		return true;
		
	}

bool SSL_Conn::proc_certificate(SSLRecord * rec, vector<bytestring> * certificates)
	{

		if ( certificates->size() == 0 )
			return true;

		ODesc common;
		common.AddRaw("Analyzer::ANALYZER_SSL");
		common.Add(bro_analyzer()->Conn()->StartTime());
		common.AddRaw(rec->is_orig() ? "T" : "F", 1);
		bro_analyzer()->Conn()->IDString(&common);

		for ( unsigned int i = 0; i < certificates->size(); ++i )
			{
			const bytestring& cert = (*certificates)[i];

			ODesc file_handle;
			file_handle.Add(common.Description());
			file_handle.Add(i);

			string file_id = file_mgr->HashHandle(file_handle.Description());

			file_mgr->DataIn(reinterpret_cast<const u_char*>(cert.data()),
			                 cert.length(), bro_analyzer()->GetAnalyzerTag(),
			                 bro_analyzer()->Conn(), rec->is_orig(), file_id);
			file_mgr->EndOfFile(file_id);
			}
		return true;
		
	}

bool SSL_Conn::proc_v2_certificate(SSLRecord * rec, bytestring const & cert)
	{

		vector<bytestring>* cert_list = new vector<bytestring>(1,cert);
		bool ret = proc_certificate(rec, cert_list);
		delete cert_list;
		return ret;
		
	}

bool SSL_Conn::proc_v3_certificate(SSLRecord * rec, vector<X509Certificate *> * cl)
	{

		vector<X509Certificate*>* certs = cl;
		vector<bytestring>* cert_list = new vector<bytestring>();

		std::transform(certs->begin(), certs->end(),
		std::back_inserter(*cert_list), extract_certs());

		bool ret = proc_certificate(rec, cert_list);
		delete cert_list;
		return ret;
		
	}

bool SSL_Conn::proc_v2_client_master_key(SSLRecord * rec, int cipher_kind)
	{

		BifEvent::generate_ssl_established(bro_analyzer(),
				bro_analyzer()->Conn());

		return true;
		
	}

bool SSL_Conn::proc_unknown_handshake(Handshake * hs, bool is_orig)
	{

		bro_analyzer()->ProtocolViolation(fmt("unknown handshake message (%d) from %s",
			hs->msg_type(), orig_label(is_orig).c_str()));
		return true;
		
	}

bool SSL_Conn::proc_unknown_record(SSLRecord * rec)
	{

		bro_analyzer()->ProtocolViolation(fmt("unknown SSL record type (%d) from %s",
				rec->content_type(),
				orig_label(rec->is_orig()).c_str()));
		return true;
		
	}

bool SSL_Conn::proc_ciphertext_record(SSLRecord * rec)
	{

		 if ( client_state_ == STATE_ENCRYPTED &&
		      server_state_ == STATE_ENCRYPTED &&
		      established_ == false )
			{
			established_ = true;
			BifEvent::generate_ssl_established(bro_analyzer(),
							bro_analyzer()->Conn());
			}

		BifEvent::generate_ssl_encrypted_data(bro_analyzer(),
			bro_analyzer()->Conn(), rec->is_orig(), rec->content_type(), rec->length());

		return true;
		
	}

bool SSL_Conn::proc_heartbeat(SSLRecord * rec, uint8 type, uint16 payload_length, bytestring const & data)
	{

		BifEvent::generate_ssl_heartbeat(bro_analyzer(),
			bro_analyzer()->Conn(), rec->is_orig(), rec->length(), type, payload_length,
			new StringVal(data.length(), (const char*) data.data()));
		return true;
		
	}

bool SSL_Conn::proc_check_v2_server_hello_version(uint16 version)
	{

		if ( version != SSLv20 )
			bro_analyzer()->ProtocolViolation(fmt("Invalid version in SSL server hello. Version: %d", version));

		return true;
		
	}

bool SSL_Conn::proc_certificate_status(SSLRecord * rec, uint8 status_type, bytestring const & response)
	{

		 if ( status_type == 1 ) // ocsp
			{
			BifEvent::generate_ssl_stapled_ocsp(bro_analyzer(),
							    bro_analyzer()->Conn(), rec->is_orig(),
							    new StringVal(response.length(),
							    (const char*) response.data()));
			}

		return true;
		
	}

bool SSL_Conn::proc_ec_server_key_exchange(SSLRecord * rec, uint8 curve_type, uint16 curve)
	{

		if ( curve_type == NAMED_CURVE )
			BifEvent::generate_ssl_server_curve(bro_analyzer(),
			  bro_analyzer()->Conn(), curve);

		return true;
		
	}

bool SSL_Conn::proc_dh_server_key_exchange(SSLRecord * rec, bytestring const & p, bytestring const & g, bytestring const & Ys)
	{

		BifEvent::generate_ssl_dh_server_params(bro_analyzer(),
			bro_analyzer()->Conn(),
		  new StringVal(p.length(), (const char*) p.data()),
		  new StringVal(g.length(), (const char*) g.data()),
		  new StringVal(Ys.length(), (const char*) Ys.data())
		  );

		return true;
		
	}

bool SSL_Conn::proc_ccs(SSLRecord * rec)
	{

		BifEvent::generate_ssl_change_cipher_spec(bro_analyzer(),
			bro_analyzer()->Conn(), rec->is_orig());

		return true;
		
	}

bool SSL_Conn::proc_handshake(SSLRecord * rec, uint8 msg_type, uint24 * length)
	{

		BifEvent::generate_ssl_handshake_message(bro_analyzer(),
			bro_analyzer()->Conn(), rec->is_orig(), msg_type, to_int()(length));

		return true;
		
	}

uint24::uint24()
	{
	byte1_ = 0;
	byte2_ = 0;
	byte3_ = 0;
	}

uint24::~uint24()
	{
	}

int uint24::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "uint24"
	if ( t_begin_of_data + (3) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("uint24",
			(0) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "byte1"
	byte1_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte2"
	byte2_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte3"
	byte3_ = *((uint8 const *) ((t_begin_of_data + 2)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (3) <= t_end_of_data);
	return 3;
	}

SSLRecord::SSLRecord(bool is_orig)
	{
	head0_ = 0;
	head1_ = 0;
	head2_ = 0;
	head3_ = 0;
	head4_ = 0;
	rec_ = 0;
	rec__elem_ = 0;
	is_orig_ = is_orig;
	byteorder_ = bigendian;
	version_ = 0;
	content_type_ = 0;
	length_ = 0;
	buffering_state_ = 0;
	buffering_state_ = 0;
	}

SSLRecord::~SSLRecord()
	{
	delete rec__elem_;
	rec__elem_ = 0;
	if ( rec() )
		{
		for ( int i = 0; i < (int) rec()->size(); ++i )
			{
			RecordText * rec__elem_ = (*rec_)[i];
			delete rec__elem_;
			rec__elem_ = 0;
			}
		}
	delete rec_;
	}

bool SSLRecord::ParseBuffer(flow_buffer_t t_flow_buffer, ContextSSL * t_context)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	const_byteptr t_begin_of_data = t_flow_buffer->begin();
	const_byteptr t_end_of_data = t_flow_buffer->end();
	switch ( buffering_state_ )
		{
		case 0:
			if ( buffering_state_ == 0 )
				{
				t_flow_buffer->NewFrame(5, false);
				buffering_state_ = 1;
				}
			buffering_state_ = 1;
			break;
		case 1:
			{
			buffering_state_ = 2;
			int t_t_var_001;
			// Checking out-of-bound for "SSLRecord:head4"
			if ( (t_begin_of_data + 4) + (1) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("SSLRecord:head4",
					(4) + (1), 
					(t_end_of_data) - (t_begin_of_data));
				}
			// Parse "head0"
			head0_ = *((uint8 const *) (t_begin_of_data));
			// Evaluate 'let' and 'withinput' fields
			// Parse "head1"
			head1_ = *((uint8 const *) ((t_begin_of_data + 1)));
			// Evaluate 'let' and 'withinput' fields
			// Parse "head2"
			head2_ = *((uint8 const *) ((t_begin_of_data + 2)));
			// Evaluate 'let' and 'withinput' fields
			// Parse "head3"
			head3_ = *((uint8 const *) ((t_begin_of_data + 3)));
			// Evaluate 'let' and 'withinput' fields
			// Parse "head4"
			head4_ = *((uint8 const *) ((t_begin_of_data + 4)));
			// Evaluate 'let' and 'withinput' fields
			version_ = t_context->connection()->determine_ssl_record_layer(head0(), head1(), head2(), head3(), head4());
			switch ( version() )
				{
				case 0:
					t_t_var_001 = 0;
					break;
				case 2:
					t_t_var_001 =  (  (  ( head0() & 0x7f )  << 8 )  | head1() )  - 3;
					break;
				default:
					t_t_var_001 =  ( head3() << 8 )  | head4();
					break;
				}
			length_ = t_t_var_001;
			t_flow_buffer->GrowFrame(length() + 5);
			}
			break;
		case 2:
			BINPAC_ASSERT(t_flow_buffer->ready());
			if ( t_flow_buffer->ready() )
				{
				
				
				
				
				
				// Parse "rec"
				int t_rec__size;
				t_rec__size = length();
				// Checking out-of-bound for "SSLRecord:rec"
				if ( (t_begin_of_data + 5) + (t_rec__size) > t_end_of_data )
					{
					// Handle out-of-bound condition
					throw binpac::ExceptionOutOfBound("SSLRecord:rec",
						(5) + (t_rec__size), 
						(t_end_of_data) - (t_begin_of_data));
					}
				{
				// Setting t_end_of_data with &length
				const_byteptr t_end_of_data = (t_begin_of_data + 5) + t_rec__size;
				int t_t_var_002;
				switch ( version() )
					{
					case 2:
						t_t_var_002 = head2() + 300;
						break;
					default:
						t_t_var_002 = head0();
						break;
					}
				content_type_ = t_t_var_002;
				int t_rec__arraylength;
				t_rec__arraylength = 0;
				rec__elem_ = 0;
				int t_rec__elem__it;
				t_rec__elem__it = 0;
				rec_ = new vector<RecordText *>;
				const_byteptr t_rec__elem__dataptr = (t_begin_of_data + 5);
				for (; /* forever */; ++t_rec__elem__it)
					{
					// Check &until(rec__elem__dataptr >= end_of_data)
					if ( t_rec__elem__dataptr >= t_end_of_data )
						{
						rec__elem_ = 0;
						goto end_of_rec;
						}
					rec__elem_ = new RecordText(this);
					int t_rec__elem__size;
					t_rec__elem__size = rec__elem_->Parse(t_rec__elem__dataptr, t_end_of_data, t_context, byteorder());
					// Evaluate 'let' and 'withinput' fields
					rec_->push_back(rec__elem_);
					t_rec__elem__dataptr += t_rec__elem__size;
					BINPAC_ASSERT(t_rec__elem__dataptr <= t_end_of_data);
					rec__elem_ = 0;
					}
			end_of_rec: ;
				// Evaluate 'let' and 'withinput' fields
				}
				
				t_val_parsing_complete = true;
				if ( t_val_parsing_complete )
					{
					// Evaluate 'let' and 'withinput' fields
					}
				BINPAC_ASSERT(t_val_parsing_complete);
				buffering_state_ = 0;
				}
			break;
		default:
			BINPAC_ASSERT(buffering_state_ <= 2);
			break;
		}
	return t_val_parsing_complete;
	}

RecordText::RecordText(SSLRecord * rec)
	{
	val_case_index_ = -1;
	ciphertext_ = 0;
	plaintext_ = 0;
	rec_ = rec;
	}

RecordText::~RecordText()
	{
	switch ( val_case_index() )
		{
		case 1:
			// Clean up "ciphertext"
			{
			delete ciphertext_;
			ciphertext_ = 0;
			}
			break;
		default:
			// Clean up "plaintext"
			{
			delete plaintext_;
			plaintext_ = 0;
			}
			break;
		}
	}

int RecordText::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder)
	{
	int t_val__size;
	val_case_index_ = t_context->connection()->state(rec()->is_orig());
	switch ( val_case_index() )
		{
		case 1:
			// Parse "ciphertext"
			{
			ciphertext_ = new CiphertextRecord(rec());
			int t_ciphertext__size;
			t_ciphertext__size = ciphertext_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_ciphertext__size;
			}
			break;
		default:
			// Parse "plaintext"
			{
			plaintext_ = new PlaintextRecord(rec());
			int t_plaintext__size;
			t_plaintext__size = plaintext_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_plaintext__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

PlaintextRecord::PlaintextRecord(SSLRecord * rec)
	{
	val_case_index_ = -1;
	ch_cipher_ = 0;
	alert_ = 0;
	handshake_ = 0;
	heartbeat_ = 0;
	app_data_ = 0;
	v2_error_ = 0;
	v2_client_hello_ = 0;
	v2_client_master_key_ = 0;
	v2_server_hello_ = 0;
	unknown_record_ = 0;
	rec_ = rec;
	}

PlaintextRecord::~PlaintextRecord()
	{
	switch ( val_case_index() )
		{
		case 20:
			// Clean up "ch_cipher"
			{
			delete ch_cipher_;
			ch_cipher_ = 0;
			}
			break;
		case 21:
			// Clean up "alert"
			{
			delete alert_;
			alert_ = 0;
			}
			break;
		case 22:
			// Clean up "handshake"
			{
			delete handshake_;
			handshake_ = 0;
			}
			break;
		case 24:
			// Clean up "heartbeat"
			{
			delete heartbeat_;
			heartbeat_ = 0;
			}
			break;
		case 23:
			// Clean up "app_data"
			{
			delete app_data_;
			app_data_ = 0;
			}
			break;
		case 300:
			// Clean up "v2_error"
			{
			delete v2_error_;
			v2_error_ = 0;
			}
			break;
		case 301:
			// Clean up "v2_client_hello"
			{
			delete v2_client_hello_;
			v2_client_hello_ = 0;
			}
			break;
		case 302:
			// Clean up "v2_client_master_key"
			{
			delete v2_client_master_key_;
			v2_client_master_key_ = 0;
			}
			break;
		case 304:
			// Clean up "v2_server_hello"
			{
			delete v2_server_hello_;
			v2_server_hello_ = 0;
			}
			break;
		default:
			// Clean up "unknown_record"
			{
			delete unknown_record_;
			unknown_record_ = 0;
			}
			break;
		}
	}

int PlaintextRecord::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder)
	{
	int t_val__size;
	val_case_index_ = rec()->content_type();
	switch ( val_case_index() )
		{
		case 20:
			// Parse "ch_cipher"
			{
			ch_cipher_ = new ChangeCipherSpec(rec());
			ch_cipher_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 1;
			}
			break;
		case 21:
			// Parse "alert"
			{
			alert_ = new Alert(rec());
			alert_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 2;
			}
			break;
		case 22:
			// Parse "handshake"
			{
			handshake_ = new Handshake(rec());
			int t_handshake__size;
			t_handshake__size = handshake_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_handshake__size;
			}
			break;
		case 24:
			// Parse "heartbeat"
			{
			heartbeat_ = new Heartbeat(rec());
			int t_heartbeat__size;
			t_heartbeat__size = heartbeat_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_heartbeat__size;
			}
			break;
		case 23:
			// Parse "app_data"
			{
			app_data_ = new ApplicationData(rec());
			int t_app_data__size;
			t_app_data__size = app_data_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_app_data__size;
			}
			break;
		case 300:
			// Parse "v2_error"
			{
			v2_error_ = new V2Error(rec());
			int t_v2_error__size;
			t_v2_error__size = v2_error_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_v2_error__size;
			}
			break;
		case 301:
			// Parse "v2_client_hello"
			{
			v2_client_hello_ = new V2ClientHello(rec());
			int t_v2_client_hello__size;
			t_v2_client_hello__size = v2_client_hello_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_v2_client_hello__size;
			}
			break;
		case 302:
			// Parse "v2_client_master_key"
			{
			v2_client_master_key_ = new V2ClientMasterKey(rec());
			int t_v2_client_master_key__size;
			t_v2_client_master_key__size = v2_client_master_key_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_v2_client_master_key__size;
			}
			break;
		case 304:
			// Parse "v2_server_hello"
			{
			v2_server_hello_ = new V2ServerHello(rec());
			int t_v2_server_hello__size;
			t_v2_server_hello__size = v2_server_hello_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_v2_server_hello__size;
			}
			break;
		default:
			// Parse "unknown_record"
			{
			unknown_record_ = new UnknownRecord(rec());
			int t_unknown_record__size;
			t_unknown_record__size = unknown_record_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_unknown_record__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

SSLExtension::SSLExtension(SSLRecord * rec)
	{
	type_ = 0;
	data_len_ = 0;
	ext_case_index_ = -1;
	apnl_ = 0;
	apnl__elem_ = 0;
	elliptic_curves_ = 0;
	elliptic_curves__elem_ = 0;
	ec_point_formats_ = 0;
	ec_point_formats__elem_ = 0;
	server_name_ = 0;
	server_name__elem_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

SSLExtension::~SSLExtension()
	{
	switch ( ext_case_index() )
		{
		case 16:
			// Clean up "apnl"
			{
			delete apnl__elem_;
			apnl__elem_ = 0;
			if ( apnl() )
				{
				for ( int i = 0; i < (int) apnl()->size(); ++i )
					{
					ApplicationLayerProtocolNegotiationExtension * apnl__elem_ = (*apnl_)[i];
					delete apnl__elem_;
					apnl__elem_ = 0;
					}
				}
			delete apnl_;
			}
			break;
		case 10:
			// Clean up "elliptic_curves"
			{
			delete elliptic_curves__elem_;
			elliptic_curves__elem_ = 0;
			if ( elliptic_curves() )
				{
				for ( int i = 0; i < (int) elliptic_curves()->size(); ++i )
					{
					EllipticCurves * elliptic_curves__elem_ = (*elliptic_curves_)[i];
					delete elliptic_curves__elem_;
					elliptic_curves__elem_ = 0;
					}
				}
			delete elliptic_curves_;
			}
			break;
		case 11:
			// Clean up "ec_point_formats"
			{
			delete ec_point_formats__elem_;
			ec_point_formats__elem_ = 0;
			if ( ec_point_formats() )
				{
				for ( int i = 0; i < (int) ec_point_formats()->size(); ++i )
					{
					EcPointFormats * ec_point_formats__elem_ = (*ec_point_formats_)[i];
					delete ec_point_formats__elem_;
					ec_point_formats__elem_ = 0;
					}
				}
			delete ec_point_formats_;
			}
			break;
		case 0:
			// Clean up "server_name"
			{
			delete server_name__elem_;
			server_name__elem_ = 0;
			if ( server_name() )
				{
				for ( int i = 0; i < (int) server_name()->size(); ++i )
					{
					ServerNameExt * server_name__elem_ = (*server_name_)[i];
					delete server_name__elem_;
					server_name__elem_ = 0;
					}
				}
			delete server_name_;
			}
			break;
		default:
			// Clean up "data"
			{
			data_.free();
			}
			break;
		}
	}

int SSLExtension::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder)
	{
	int t_SSLExtension__size;
	// Checking out-of-bound for "SSLExtension:data_len"
	if ( (t_begin_of_data + 2) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SSLExtension:data_len",
			(2) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "data_len"
	data_len_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	t_SSLExtension__size = data_len() + 4;
	// Checking out-of-bound for "SSLExtension"
	if ( t_begin_of_data + (t_SSLExtension__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SSLExtension",
			(0) + (t_SSLExtension__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + t_SSLExtension__size;
	sourcedata_ = const_bytestring(t_begin_of_data, t_end_of_data);
	// Parse "type"
	type_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	
	// Parse "ext"
	int t_ext__size;
	ext_case_index_ = type();
	switch ( ext_case_index() )
		{
		case 16:
			// Parse "apnl"
			{
			int t_apnl__arraylength;
			t_apnl__arraylength = 0;
			apnl__elem_ = 0;
			int t_apnl__elem__it;
			t_apnl__elem__it = 0;
			int t_apnl__size;
			apnl_ = new vector<ApplicationLayerProtocolNegotiationExtension *>;
			const_byteptr t_apnl__elem__dataptr = (t_begin_of_data + 4);
			for (; /* forever */; ++t_apnl__elem__it)
				{
				// Check &until(apnl__elem__dataptr >= end_of_data)
				if ( t_apnl__elem__dataptr >= t_end_of_data )
					{
					apnl__elem_ = 0;
					goto end_of_apnl;
					}
				apnl__elem_ = new ApplicationLayerProtocolNegotiationExtension(rec());
				int t_apnl__elem__size;
				t_apnl__elem__size = apnl__elem_->Parse(t_apnl__elem__dataptr, t_end_of_data, t_context, t_byteorder);
				// Evaluate 'let' and 'withinput' fields
				apnl_->push_back(apnl__elem_);
				t_apnl__elem__dataptr += t_apnl__elem__size;
				BINPAC_ASSERT(t_apnl__elem__dataptr <= t_end_of_data);
				// Check &until( ( $element == ((int) 0) || $element != ((int) 0) ) )
				if (  ( apnl__elem_ == 0 || apnl__elem_ != 0 )  )
					{
					apnl__elem_ = 0;
					goto end_of_apnl;
					}
				apnl__elem_ = 0;
				}
		end_of_apnl: ;
			t_apnl__size = t_apnl__elem__dataptr - ((t_begin_of_data + 4));
			// Evaluate 'let' and 'withinput' fields
			t_ext__size = t_apnl__size;
			}
			break;
		case 10:
			// Parse "elliptic_curves"
			{
			int t_elliptic_curves__arraylength;
			t_elliptic_curves__arraylength = 0;
			elliptic_curves__elem_ = 0;
			int t_elliptic_curves__elem__it;
			t_elliptic_curves__elem__it = 0;
			int t_elliptic_curves__size;
			elliptic_curves_ = new vector<EllipticCurves *>;
			const_byteptr t_elliptic_curves__elem__dataptr = (t_begin_of_data + 4);
			for (; /* forever */; ++t_elliptic_curves__elem__it)
				{
				// Check &until(elliptic_curves__elem__dataptr >= end_of_data)
				if ( t_elliptic_curves__elem__dataptr >= t_end_of_data )
					{
					elliptic_curves__elem_ = 0;
					goto end_of_elliptic_curves;
					}
				elliptic_curves__elem_ = new EllipticCurves(rec());
				int t_elliptic_curves__elem__size;
				t_elliptic_curves__elem__size = elliptic_curves__elem_->Parse(t_elliptic_curves__elem__dataptr, t_end_of_data, t_context, t_byteorder);
				// Evaluate 'let' and 'withinput' fields
				elliptic_curves_->push_back(elliptic_curves__elem_);
				t_elliptic_curves__elem__dataptr += t_elliptic_curves__elem__size;
				BINPAC_ASSERT(t_elliptic_curves__elem__dataptr <= t_end_of_data);
				// Check &until( ( $element == ((int) 0) || $element != ((int) 0) ) )
				if (  ( elliptic_curves__elem_ == 0 || elliptic_curves__elem_ != 0 )  )
					{
					elliptic_curves__elem_ = 0;
					goto end_of_elliptic_curves;
					}
				elliptic_curves__elem_ = 0;
				}
		end_of_elliptic_curves: ;
			t_elliptic_curves__size = t_elliptic_curves__elem__dataptr - ((t_begin_of_data + 4));
			// Evaluate 'let' and 'withinput' fields
			t_ext__size = t_elliptic_curves__size;
			}
			break;
		case 11:
			// Parse "ec_point_formats"
			{
			int t_ec_point_formats__arraylength;
			t_ec_point_formats__arraylength = 0;
			ec_point_formats__elem_ = 0;
			int t_ec_point_formats__elem__it;
			t_ec_point_formats__elem__it = 0;
			int t_ec_point_formats__size;
			ec_point_formats_ = new vector<EcPointFormats *>;
			const_byteptr t_ec_point_formats__elem__dataptr = (t_begin_of_data + 4);
			for (; /* forever */; ++t_ec_point_formats__elem__it)
				{
				// Check &until(ec_point_formats__elem__dataptr >= end_of_data)
				if ( t_ec_point_formats__elem__dataptr >= t_end_of_data )
					{
					ec_point_formats__elem_ = 0;
					goto end_of_ec_point_formats;
					}
				ec_point_formats__elem_ = new EcPointFormats(rec());
				int t_ec_point_formats__elem__size;
				t_ec_point_formats__elem__size = ec_point_formats__elem_->Parse(t_ec_point_formats__elem__dataptr, t_end_of_data, t_context);
				// Evaluate 'let' and 'withinput' fields
				ec_point_formats_->push_back(ec_point_formats__elem_);
				t_ec_point_formats__elem__dataptr += t_ec_point_formats__elem__size;
				BINPAC_ASSERT(t_ec_point_formats__elem__dataptr <= t_end_of_data);
				// Check &until( ( $element == ((int) 0) || $element != ((int) 0) ) )
				if (  ( ec_point_formats__elem_ == 0 || ec_point_formats__elem_ != 0 )  )
					{
					ec_point_formats__elem_ = 0;
					goto end_of_ec_point_formats;
					}
				ec_point_formats__elem_ = 0;
				}
		end_of_ec_point_formats: ;
			t_ec_point_formats__size = t_ec_point_formats__elem__dataptr - ((t_begin_of_data + 4));
			// Evaluate 'let' and 'withinput' fields
			t_ext__size = t_ec_point_formats__size;
			}
			break;
		case 0:
			// Parse "server_name"
			{
			int t_server_name__arraylength;
			t_server_name__arraylength = 0;
			server_name__elem_ = 0;
			int t_server_name__elem__it;
			t_server_name__elem__it = 0;
			int t_server_name__size;
			server_name_ = new vector<ServerNameExt *>;
			const_byteptr t_server_name__elem__dataptr = (t_begin_of_data + 4);
			for (; /* forever */; ++t_server_name__elem__it)
				{
				// Check &until(server_name__elem__dataptr >= end_of_data)
				if ( t_server_name__elem__dataptr >= t_end_of_data )
					{
					server_name__elem_ = 0;
					goto end_of_server_name;
					}
				server_name__elem_ = new ServerNameExt(rec());
				int t_server_name__elem__size;
				t_server_name__elem__size = server_name__elem_->Parse(t_server_name__elem__dataptr, t_end_of_data, t_context, t_byteorder);
				// Evaluate 'let' and 'withinput' fields
				server_name_->push_back(server_name__elem_);
				t_server_name__elem__dataptr += t_server_name__elem__size;
				BINPAC_ASSERT(t_server_name__elem__dataptr <= t_end_of_data);
				// Check &until( ( $element == ((int) 0) || $element != ((int) 0) ) )
				if (  ( server_name__elem_ == 0 || server_name__elem_ != 0 )  )
					{
					server_name__elem_ = 0;
					goto end_of_server_name;
					}
				server_name__elem_ = 0;
				}
		end_of_server_name: ;
			t_server_name__size = t_server_name__elem__dataptr - ((t_begin_of_data + 4));
			// Evaluate 'let' and 'withinput' fields
			t_ext__size = t_server_name__size;
			}
			break;
		default:
			// Parse "data"
			{
			int t_data_string_length;
			t_data_string_length = (t_end_of_data) - ((t_begin_of_data + 4));
			int t_data__size;
			t_data__size = t_data_string_length;
			// check for negative sizes
			if ( t_data_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:90", t_data_string_length);
			data_.init((t_begin_of_data + 4), t_data_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_ext__size = t_data__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_ssl_extension(rec(), type(), sourcedata());
	sourcedata_.set_end(t_begin_of_data + t_SSLExtension__size);
	}
	BINPAC_ASSERT(t_begin_of_data + (t_SSLExtension__size) <= t_end_of_data);
	return t_SSLExtension__size;
	}

ServerNameHostName::ServerNameHostName()
	{
	length_ = 0;
	}

ServerNameHostName::~ServerNameHostName()
	{
	host_name_.free();
	}

int ServerNameHostName::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "ServerNameHostName:length"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ServerNameHostName:length",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "host_name"
	int t_host_name__size;
	t_host_name__size = length();
	// Checking out-of-bound for "ServerNameHostName:host_name"
	if ( (t_begin_of_data + 2) + (t_host_name__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ServerNameHostName:host_name",
			(2) + (t_host_name__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 2) + t_host_name__size;
	int t_host_name_string_length;
	t_host_name_string_length = length();
	// check for negative sizes
	if ( t_host_name_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:96", t_host_name_string_length);
	host_name_.init((t_begin_of_data + 2), t_host_name_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_ServerNameHostName__size;
	const_byteptr const t_dataptr_after_host_name = (t_begin_of_data + 2) + (t_host_name__size);
	BINPAC_ASSERT(t_dataptr_after_host_name <= t_end_of_data);
	t_ServerNameHostName__size = t_dataptr_after_host_name - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ServerNameHostName__size) <= t_end_of_data);
	return t_ServerNameHostName__size;
	}

ServerName::ServerName()
	{
	name_type_ = 0;
	name_case_index_ = -1;
	host_name_ = 0;
	}

ServerName::~ServerName()
	{
	switch ( name_case_index() )
		{
		case 0:
			// Clean up "host_name"
			{
			delete host_name_;
			host_name_ = 0;
			}
			break;
		default:
			// Clean up "data"
			{
			}
			break;
		}
	}

int ServerName::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "ServerName:name_type"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ServerName:name_type",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "name_type"
	name_type_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "name"
	int t_name__size;
	name_case_index_ = name_type();
	switch ( name_case_index() )
		{
		case 0:
			// Parse "host_name"
			{
			host_name_ = new ServerNameHostName();
			int t_host_name__size;
			t_host_name__size = host_name_->Parse((t_begin_of_data + 1), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_name__size = t_host_name__size;
			}
			break;
		default:
			// Parse "data"
			{
			int t_data_string_length;
			t_data_string_length = (t_end_of_data) - ((t_begin_of_data + 1));
			int t_data__size;
			t_data__size = t_data_string_length;
			// check for negative sizes
			if ( t_data_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:103", t_data_string_length);
			data_.init((t_begin_of_data + 1), t_data_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_name__size = t_data__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_ServerName__size;
	const_byteptr const t_dataptr_after_name = (t_begin_of_data + 1) + (t_name__size);
	BINPAC_ASSERT(t_dataptr_after_name <= t_end_of_data);
	t_ServerName__size = t_dataptr_after_name - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ServerName__size) <= t_end_of_data);
	return t_ServerName__size;
	}

ServerNameExt::ServerNameExt(SSLRecord * rec)
	{
	length_ = 0;
	server_names_ = 0;
	server_names__elem_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

ServerNameExt::~ServerNameExt()
	{
	delete server_names__elem_;
	server_names__elem_ = 0;
	if ( server_names() )
		{
		for ( int i = 0; i < (int) server_names()->size(); ++i )
			{
			ServerName * server_names__elem_ = (*server_names_)[i];
			delete server_names__elem_;
			server_names__elem_ = 0;
			}
		}
	delete server_names_;
	}

int ServerNameExt::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder)
	{
	int t_ServerNameExt__size;
	// Checking out-of-bound for "ServerNameExt:length"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ServerNameExt:length",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	t_ServerNameExt__size = length() + 2;
	// Checking out-of-bound for "ServerNameExt"
	if ( t_begin_of_data + (t_ServerNameExt__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ServerNameExt",
			(0) + (t_ServerNameExt__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + t_ServerNameExt__size;
	
	// Parse "server_names"
	int t_server_names__arraylength;
	t_server_names__arraylength = 0;
	server_names__elem_ = 0;
	int t_server_names__elem__it;
	t_server_names__elem__it = 0;
	int t_server_names__size;
	server_names_ = new vector<ServerName *>;
	const_byteptr t_server_names__elem__dataptr = (t_begin_of_data + 2);
	for (; /* forever */; ++t_server_names__elem__it)
		{
		// Check &until(server_names__elem__dataptr >= end_of_data)
		if ( t_server_names__elem__dataptr >= t_end_of_data )
			{
			server_names__elem_ = 0;
			goto end_of_server_names;
			}
		server_names__elem_ = new ServerName();
		int t_server_names__elem__size;
		t_server_names__elem__size = server_names__elem_->Parse(t_server_names__elem__dataptr, t_end_of_data, t_byteorder);
		// Evaluate 'let' and 'withinput' fields
		server_names_->push_back(server_names__elem_);
		t_server_names__elem__dataptr += t_server_names__elem__size;
		BINPAC_ASSERT(t_server_names__elem__dataptr <= t_end_of_data);
		server_names__elem_ = 0;
		}
end_of_server_names: ;
	t_server_names__size = t_server_names__elem__dataptr - ((t_begin_of_data + 2));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_server_name(rec(), server_names());
	}
	BINPAC_ASSERT(t_begin_of_data + (t_ServerNameExt__size) <= t_end_of_data);
	return t_ServerNameExt__size;
	}

EcPointFormats::EcPointFormats(SSLRecord * rec)
	{
	length_ = 0;
	point_format_list_ = 0;
	point_format_list__elem_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

EcPointFormats::~EcPointFormats()
	{
	delete point_format_list_;
	}

int EcPointFormats::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context)
	{
	// Checking out-of-bound for "EcPointFormats:length"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("EcPointFormats:length",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "point_format_list"
	int t_point_format_list__arraylength;
	t_point_format_list__arraylength = 0;
	t_point_format_list__arraylength = length();
	if ( t_begin_of_data + t_point_format_list__arraylength > t_end_of_data + 1 )
		{
		t_point_format_list__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_point_format_list__arraylength < 0 )
		{
		t_point_format_list__arraylength = 0;
		}
	point_format_list__elem_ = 0;
	int t_point_format_list__elem__it;
	t_point_format_list__elem__it = 0;
	int t_point_format_list__size;
	point_format_list_ = new vector<uint8>;
	point_format_list_->reserve(t_point_format_list__arraylength);
	const_byteptr t_point_format_list__elem__dataptr = (t_begin_of_data + 1);
	for (; t_point_format_list__elem__it < t_point_format_list__arraylength; ++t_point_format_list__elem__it)
		{
		// Check &until(point_format_list__elem__dataptr >= end_of_data)
		if ( t_point_format_list__elem__dataptr >= t_end_of_data )
			{
			goto end_of_point_format_list;
			}
		// Checking out-of-bound for "EcPointFormats:point_format_list__elem"
		if ( t_point_format_list__elem__dataptr + (1) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("EcPointFormats:point_format_list__elem",
				((t_point_format_list__elem__dataptr - t_begin_of_data)) + (1), 
				(t_end_of_data) - (t_begin_of_data));
			}
		point_format_list__elem_ = *((uint8 const *) (t_point_format_list__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		point_format_list_->push_back(point_format_list__elem_);
		t_point_format_list__elem__dataptr += 1;
		BINPAC_ASSERT(t_point_format_list__elem__dataptr <= t_end_of_data);
		}
end_of_point_format_list: ;
	t_point_format_list__size = t_point_format_list__elem__dataptr - ((t_begin_of_data + 1));
	// Evaluate 'let' and 'withinput' fields
	
	int t_EcPointFormats__size;
	const_byteptr const t_dataptr_after_point_format_list = (t_begin_of_data + 1) + (t_point_format_list__size);
	BINPAC_ASSERT(t_dataptr_after_point_format_list <= t_end_of_data);
	t_EcPointFormats__size = t_dataptr_after_point_format_list - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_ec_point_formats(rec(), point_format_list());
	BINPAC_ASSERT(t_begin_of_data + (t_EcPointFormats__size) <= t_end_of_data);
	return t_EcPointFormats__size;
	}

EllipticCurves::EllipticCurves(SSLRecord * rec)
	{
	length_ = 0;
	elliptic_curve_list_ = 0;
	elliptic_curve_list__elem_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

EllipticCurves::~EllipticCurves()
	{
	delete elliptic_curve_list_;
	}

int EllipticCurves::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "EllipticCurves:length"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("EllipticCurves:length",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "elliptic_curve_list"
	int t_elliptic_curve_list__arraylength;
	t_elliptic_curve_list__arraylength = 0;
	t_elliptic_curve_list__arraylength = length() / 2;
	if ( t_begin_of_data + t_elliptic_curve_list__arraylength > t_end_of_data + 1 )
		{
		t_elliptic_curve_list__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_elliptic_curve_list__arraylength < 0 )
		{
		t_elliptic_curve_list__arraylength = 0;
		}
	elliptic_curve_list__elem_ = 0;
	int t_elliptic_curve_list__elem__it;
	t_elliptic_curve_list__elem__it = 0;
	int t_elliptic_curve_list__size;
	elliptic_curve_list_ = new vector<uint16>;
	elliptic_curve_list_->reserve(t_elliptic_curve_list__arraylength);
	const_byteptr t_elliptic_curve_list__elem__dataptr = (t_begin_of_data + 2);
	for (; t_elliptic_curve_list__elem__it < t_elliptic_curve_list__arraylength; ++t_elliptic_curve_list__elem__it)
		{
		// Check &until(elliptic_curve_list__elem__dataptr >= end_of_data)
		if ( t_elliptic_curve_list__elem__dataptr >= t_end_of_data )
			{
			goto end_of_elliptic_curve_list;
			}
		// Checking out-of-bound for "EllipticCurves:elliptic_curve_list__elem"
		if ( t_elliptic_curve_list__elem__dataptr + (2) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("EllipticCurves:elliptic_curve_list__elem",
				((t_elliptic_curve_list__elem__dataptr - t_begin_of_data)) + (2), 
				(t_end_of_data) - (t_begin_of_data));
			}
		elliptic_curve_list__elem_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_elliptic_curve_list__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		elliptic_curve_list_->push_back(elliptic_curve_list__elem_);
		t_elliptic_curve_list__elem__dataptr += 2;
		BINPAC_ASSERT(t_elliptic_curve_list__elem__dataptr <= t_end_of_data);
		}
end_of_elliptic_curve_list: ;
	t_elliptic_curve_list__size = t_elliptic_curve_list__elem__dataptr - ((t_begin_of_data + 2));
	// Evaluate 'let' and 'withinput' fields
	
	int t_EllipticCurves__size;
	const_byteptr const t_dataptr_after_elliptic_curve_list = (t_begin_of_data + 2) + (t_elliptic_curve_list__size);
	BINPAC_ASSERT(t_dataptr_after_elliptic_curve_list <= t_end_of_data);
	t_EllipticCurves__size = t_dataptr_after_elliptic_curve_list - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_elliptic_curves(rec(), elliptic_curve_list());
	BINPAC_ASSERT(t_begin_of_data + (t_EllipticCurves__size) <= t_end_of_data);
	return t_EllipticCurves__size;
	}

ProtocolName::ProtocolName()
	{
	length_ = 0;
	}

ProtocolName::~ProtocolName()
	{
	name_.free();
	}

int ProtocolName::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "ProtocolName:length"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ProtocolName:length",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "name"
	int t_name__size;
	t_name__size = length();
	// Checking out-of-bound for "ProtocolName:name"
	if ( (t_begin_of_data + 1) + (t_name__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ProtocolName:name",
			(1) + (t_name__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 1) + t_name__size;
	int t_name_string_length;
	t_name_string_length = length();
	// check for negative sizes
	if ( t_name_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:140", t_name_string_length);
	name_.init((t_begin_of_data + 1), t_name_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_ProtocolName__size;
	const_byteptr const t_dataptr_after_name = (t_begin_of_data + 1) + (t_name__size);
	BINPAC_ASSERT(t_dataptr_after_name <= t_end_of_data);
	t_ProtocolName__size = t_dataptr_after_name - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ProtocolName__size) <= t_end_of_data);
	return t_ProtocolName__size;
	}

ApplicationLayerProtocolNegotiationExtension::ApplicationLayerProtocolNegotiationExtension(SSLRecord * rec)
	{
	length_ = 0;
	protocol_name_list_ = 0;
	protocol_name_list__elem_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

ApplicationLayerProtocolNegotiationExtension::~ApplicationLayerProtocolNegotiationExtension()
	{
	delete protocol_name_list__elem_;
	protocol_name_list__elem_ = 0;
	if ( protocol_name_list() )
		{
		for ( int i = 0; i < (int) protocol_name_list()->size(); ++i )
			{
			ProtocolName * protocol_name_list__elem_ = (*protocol_name_list_)[i];
			delete protocol_name_list__elem_;
			protocol_name_list__elem_ = 0;
			}
		}
	delete protocol_name_list_;
	}

int ApplicationLayerProtocolNegotiationExtension::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder)
	{
	int t_ApplicationLayerProtocolNegotiationExtension__size;
	// Checking out-of-bound for "ApplicationLayerProtocolNegotiationExtension:length"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ApplicationLayerProtocolNegotiationExtension:length",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	t_ApplicationLayerProtocolNegotiationExtension__size = length() + 2;
	// Checking out-of-bound for "ApplicationLayerProtocolNegotiationExtension"
	if ( t_begin_of_data + (t_ApplicationLayerProtocolNegotiationExtension__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ApplicationLayerProtocolNegotiationExtension",
			(0) + (t_ApplicationLayerProtocolNegotiationExtension__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + t_ApplicationLayerProtocolNegotiationExtension__size;
	
	// Parse "protocol_name_list"
	int t_protocol_name_list__arraylength;
	t_protocol_name_list__arraylength = 0;
	protocol_name_list__elem_ = 0;
	int t_protocol_name_list__elem__it;
	t_protocol_name_list__elem__it = 0;
	int t_protocol_name_list__size;
	protocol_name_list_ = new vector<ProtocolName *>;
	const_byteptr t_protocol_name_list__elem__dataptr = (t_begin_of_data + 2);
	for (; /* forever */; ++t_protocol_name_list__elem__it)
		{
		// Check &until(protocol_name_list__elem__dataptr >= end_of_data)
		if ( t_protocol_name_list__elem__dataptr >= t_end_of_data )
			{
			protocol_name_list__elem_ = 0;
			goto end_of_protocol_name_list;
			}
		protocol_name_list__elem_ = new ProtocolName();
		int t_protocol_name_list__elem__size;
		t_protocol_name_list__elem__size = protocol_name_list__elem_->Parse(t_protocol_name_list__elem__dataptr, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		protocol_name_list_->push_back(protocol_name_list__elem_);
		t_protocol_name_list__elem__dataptr += t_protocol_name_list__elem__size;
		BINPAC_ASSERT(t_protocol_name_list__elem__dataptr <= t_end_of_data);
		protocol_name_list__elem_ = 0;
		}
end_of_protocol_name_list: ;
	t_protocol_name_list__size = t_protocol_name_list__elem__dataptr - ((t_begin_of_data + 2));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_apnl(rec(), protocol_name_list());
	}
	BINPAC_ASSERT(t_begin_of_data + (t_ApplicationLayerProtocolNegotiationExtension__size) <= t_end_of_data);
	return t_ApplicationLayerProtocolNegotiationExtension__size;
	}


	string state_label(int state_nr)
		{
		switch ( state_nr ) {
		case STATE_CLEAR:
			return string("CLEAR");

		case STATE_ENCRYPTED:
			return string("ENCRYPTED");

		default:
			return string(fmt("UNKNOWN (%d)", state_nr));
		}
		}

ChangeCipherSpec::ChangeCipherSpec(SSLRecord * rec)
	{
	type_ = 0;
	rec_ = rec;
	state_changed_ = 0;
	proc_ = 0;
	}

ChangeCipherSpec::~ChangeCipherSpec()
	{
	}

int ChangeCipherSpec::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context)
	{
	// Checking out-of-bound for "ChangeCipherSpec"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ChangeCipherSpec",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + 1;
	// Parse "type"
	type_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	state_changed_ = t_context->connection()->startEncryption(rec()->is_orig());
	proc_ = t_context->connection()->proc_ccs(rec());
	}
	BINPAC_ASSERT(t_begin_of_data + (1) <= t_end_of_data);
	return 1;
	}

Alert::Alert(SSLRecord * rec)
	{
	level_ = 0;
	description_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

Alert::~Alert()
	{
	}

int Alert::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context)
	{
	// Checking out-of-bound for "Alert"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Alert",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "level"
	level_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "description"
	description_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_alert(rec(), level(), description());
	BINPAC_ASSERT(t_begin_of_data + (2) <= t_end_of_data);
	return 2;
	}

V2Error::V2Error(SSLRecord * rec)
	{
	rec_ = rec;
	error_code_ = 0;
	proc_ = 0;
	}

V2Error::~V2Error()
	{
	}

int V2Error::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context)
	{
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:221", t_data_string_length);
	data_.init(t_begin_of_data, t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_V2Error__size;
	const_byteptr const t_dataptr_after_data = t_begin_of_data + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_V2Error__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	error_code_ =  (  ( rec()->head3() << 8 )  | rec()->head4() ) ;
	proc_ = t_context->connection()->proc_alert(rec(), -1, error_code());
	BINPAC_ASSERT(t_begin_of_data + (t_V2Error__size) <= t_end_of_data);
	return t_V2Error__size;
	}

ApplicationData::ApplicationData(SSLRecord * rec)
	{
	rec_ = rec;
	}

ApplicationData::~ApplicationData()
	{
	}

int ApplicationData::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context)
	{
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:234", t_data_string_length);
	data_.init(t_begin_of_data, t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ApplicationData__size;
	const_byteptr const t_dataptr_after_data = t_begin_of_data + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_ApplicationData__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ApplicationData__size) <= t_end_of_data);
	return t_ApplicationData__size;
	}

Heartbeat::Heartbeat(SSLRecord * rec)
	{
	type_ = 0;
	payload_length_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

Heartbeat::~Heartbeat()
	{
	data_.free();
	}

int Heartbeat::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "Heartbeat:payload_length"
	if ( (t_begin_of_data + 1) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Heartbeat:payload_length",
			(1) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "type"
	type_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "payload_length"
	payload_length_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - ((t_begin_of_data + 3));
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:244", t_data_string_length);
	data_.init((t_begin_of_data + 3), t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_Heartbeat__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 3) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_Heartbeat__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_heartbeat(rec(), type(), payload_length(), data());
	BINPAC_ASSERT(t_begin_of_data + (t_Heartbeat__size) <= t_end_of_data);
	return t_Heartbeat__size;
	}

HelloRequest::HelloRequest(SSLRecord * rec)
	{
	rec_ = rec;
	}

HelloRequest::~HelloRequest()
	{
	}

int HelloRequest::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context)
	{
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (0) <= t_end_of_data);
	return 0;
	}

ClientHello::ClientHello(SSLRecord * rec)
	{
	client_version_ = 0;
	gmt_unix_time_ = 0;
	session_len_ = 0;
	session_id_ = 0;
	session_id__elem_ = 0;
	csuit_len_ = 0;
	csuits_ = 0;
	csuits__elem_ = 0;
	cmeth_len_ = 0;
	cmeths_ = 0;
	cmeths__elem_ = 0;
	ext_len_ = 0;
	ext_len__elem_ = 0;
	extensions_ = 0;
	extensions__elem_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

ClientHello::~ClientHello()
	{
	random_bytes_.free();
	delete session_id_;
	delete csuits_;
	delete cmeths_;
	delete ext_len_;
	delete extensions__elem_;
	extensions__elem_ = 0;
	if ( extensions() )
		{
		for ( int i = 0; i < (int) extensions()->size(); ++i )
			{
			SSLExtension * extensions__elem_ = (*extensions_)[i];
			delete extensions__elem_;
			extensions__elem_ = 0;
			}
		}
	delete extensions_;
	}

int ClientHello::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "ClientHello:gmt_unix_time"
	if ( (t_begin_of_data + 2) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ClientHello:gmt_unix_time",
			(2) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "client_version"
	client_version_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "gmt_unix_time"
	gmt_unix_time_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "random_bytes"
	// Checking out-of-bound for "ClientHello:random_bytes"
	if ( (t_begin_of_data + 6) + (28) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ClientHello:random_bytes",
			(6) + (28), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 6) + 28;
	int t_random_bytes_string_length;
	t_random_bytes_string_length = 28;
	int t_random_bytes__size;
	t_random_bytes__size = t_random_bytes_string_length;
	random_bytes_.init((t_begin_of_data + 6), t_random_bytes_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_random_bytes = (t_begin_of_data + 6) + (28);
	BINPAC_ASSERT(t_dataptr_after_random_bytes <= t_end_of_data);
	// Checking out-of-bound for "ClientHello:session_len"
	if ( t_dataptr_after_random_bytes + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ClientHello:session_len",
			((t_dataptr_after_random_bytes - t_begin_of_data)) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "session_len"
	session_len_ = *((uint8 const *) (t_dataptr_after_random_bytes));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "session_id"
	int t_session_id__arraylength;
	t_session_id__arraylength = 0;
	t_session_id__arraylength = session_len();
	if ( t_begin_of_data + t_session_id__arraylength > t_end_of_data + 1 )
		{
		t_session_id__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_session_id__arraylength < 0 )
		{
		t_session_id__arraylength = 0;
		}
	session_id__elem_ = 0;
	int t_session_id__elem__it;
	t_session_id__elem__it = 0;
	int t_session_id__size;
	session_id_ = new vector<uint8>;
	session_id_->reserve(t_session_id__arraylength);
	const_byteptr t_session_id__elem__dataptr = (t_dataptr_after_random_bytes + 1);
	for (; t_session_id__elem__it < t_session_id__arraylength; ++t_session_id__elem__it)
		{
		// Check &until(session_id__elem__dataptr >= end_of_data)
		if ( t_session_id__elem__dataptr >= t_end_of_data )
			{
			goto end_of_session_id;
			}
		// Checking out-of-bound for "ClientHello:session_id__elem"
		if ( t_session_id__elem__dataptr + (1) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("ClientHello:session_id__elem",
				((t_session_id__elem__dataptr - t_begin_of_data)) + (1), 
				(t_end_of_data) - (t_begin_of_data));
			}
		session_id__elem_ = *((uint8 const *) (t_session_id__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		session_id_->push_back(session_id__elem_);
		t_session_id__elem__dataptr += 1;
		BINPAC_ASSERT(t_session_id__elem__dataptr <= t_end_of_data);
		}
end_of_session_id: ;
	t_session_id__size = t_session_id__elem__dataptr - ((t_dataptr_after_random_bytes + 1));
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_session_id = (t_dataptr_after_random_bytes + 1) + (t_session_id__size);
	BINPAC_ASSERT(t_dataptr_after_session_id <= t_end_of_data);
	// Checking out-of-bound for "ClientHello:csuit_len"
	if ( t_dataptr_after_session_id + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ClientHello:csuit_len",
			((t_dataptr_after_session_id - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "csuit_len"
	csuit_len_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_dataptr_after_session_id)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "csuits"
	int t_csuits__arraylength;
	t_csuits__arraylength = 0;
	t_csuits__arraylength = csuit_len() / 2;
	if ( t_begin_of_data + t_csuits__arraylength > t_end_of_data + 1 )
		{
		t_csuits__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_csuits__arraylength < 0 )
		{
		t_csuits__arraylength = 0;
		}
	csuits__elem_ = 0;
	int t_csuits__elem__it;
	t_csuits__elem__it = 0;
	int t_csuits__size;
	csuits_ = new vector<uint16>;
	csuits_->reserve(t_csuits__arraylength);
	const_byteptr t_csuits__elem__dataptr = (t_dataptr_after_session_id + 2);
	for (; t_csuits__elem__it < t_csuits__arraylength; ++t_csuits__elem__it)
		{
		// Check &until(csuits__elem__dataptr >= end_of_data)
		if ( t_csuits__elem__dataptr >= t_end_of_data )
			{
			goto end_of_csuits;
			}
		// Checking out-of-bound for "ClientHello:csuits__elem"
		if ( t_csuits__elem__dataptr + (2) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("ClientHello:csuits__elem",
				((t_csuits__elem__dataptr - t_begin_of_data)) + (2), 
				(t_end_of_data) - (t_begin_of_data));
			}
		csuits__elem_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_csuits__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		csuits_->push_back(csuits__elem_);
		t_csuits__elem__dataptr += 2;
		BINPAC_ASSERT(t_csuits__elem__dataptr <= t_end_of_data);
		}
end_of_csuits: ;
	t_csuits__size = t_csuits__elem__dataptr - ((t_dataptr_after_session_id + 2));
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_csuits = (t_dataptr_after_session_id + 2) + (t_csuits__size);
	BINPAC_ASSERT(t_dataptr_after_csuits <= t_end_of_data);
	// Checking out-of-bound for "ClientHello:cmeth_len"
	if ( t_dataptr_after_csuits + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ClientHello:cmeth_len",
			((t_dataptr_after_csuits - t_begin_of_data)) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "cmeth_len"
	cmeth_len_ = *((uint8 const *) (t_dataptr_after_csuits));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "cmeths"
	int t_cmeths__arraylength;
	t_cmeths__arraylength = 0;
	t_cmeths__arraylength = cmeth_len();
	if ( t_begin_of_data + t_cmeths__arraylength > t_end_of_data + 1 )
		{
		t_cmeths__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_cmeths__arraylength < 0 )
		{
		t_cmeths__arraylength = 0;
		}
	cmeths__elem_ = 0;
	int t_cmeths__elem__it;
	t_cmeths__elem__it = 0;
	int t_cmeths__size;
	cmeths_ = new vector<uint8>;
	cmeths_->reserve(t_cmeths__arraylength);
	const_byteptr t_cmeths__elem__dataptr = (t_dataptr_after_csuits + 1);
	for (; t_cmeths__elem__it < t_cmeths__arraylength; ++t_cmeths__elem__it)
		{
		// Check &until(cmeths__elem__dataptr >= end_of_data)
		if ( t_cmeths__elem__dataptr >= t_end_of_data )
			{
			goto end_of_cmeths;
			}
		// Checking out-of-bound for "ClientHello:cmeths__elem"
		if ( t_cmeths__elem__dataptr + (1) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("ClientHello:cmeths__elem",
				((t_cmeths__elem__dataptr - t_begin_of_data)) + (1), 
				(t_end_of_data) - (t_begin_of_data));
			}
		cmeths__elem_ = *((uint8 const *) (t_cmeths__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		cmeths_->push_back(cmeths__elem_);
		t_cmeths__elem__dataptr += 1;
		BINPAC_ASSERT(t_cmeths__elem__dataptr <= t_end_of_data);
		}
end_of_cmeths: ;
	t_cmeths__size = t_cmeths__elem__dataptr - ((t_dataptr_after_csuits + 1));
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_cmeths = (t_dataptr_after_csuits + 1) + (t_cmeths__size);
	BINPAC_ASSERT(t_dataptr_after_cmeths <= t_end_of_data);
	// Parse "ext_len"
	int t_ext_len__arraylength;
	t_ext_len__arraylength = 0;
	ext_len__elem_ = 0;
	int t_ext_len__elem__it;
	t_ext_len__elem__it = 0;
	int t_ext_len__size;
	ext_len_ = new vector<uint16>;
	const_byteptr t_ext_len__elem__dataptr = t_dataptr_after_cmeths;
	for (; /* forever */; ++t_ext_len__elem__it)
		{
		// Check &until(ext_len__elem__dataptr >= end_of_data)
		if ( t_ext_len__elem__dataptr >= t_end_of_data )
			{
			goto end_of_ext_len;
			}
		// Checking out-of-bound for "ClientHello:ext_len__elem"
		if ( t_ext_len__elem__dataptr + (2) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("ClientHello:ext_len__elem",
				((t_ext_len__elem__dataptr - t_begin_of_data)) + (2), 
				(t_end_of_data) - (t_begin_of_data));
			}
		ext_len__elem_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_ext_len__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		ext_len_->push_back(ext_len__elem_);
		t_ext_len__elem__dataptr += 2;
		BINPAC_ASSERT(t_ext_len__elem__dataptr <= t_end_of_data);
		// Check &until( ( $element == ((int) 0) || $element != ((int) 0) ) )
		if (  ( ext_len__elem_ == 0 || ext_len__elem_ != 0 )  )
			{
			goto end_of_ext_len;
			}
		}
end_of_ext_len: ;
	t_ext_len__size = t_ext_len__elem__dataptr - (t_dataptr_after_cmeths);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_ext_len = t_dataptr_after_cmeths + (t_ext_len__size);
	BINPAC_ASSERT(t_dataptr_after_ext_len <= t_end_of_data);
	// Parse "extensions"
	int t_extensions__arraylength;
	t_extensions__arraylength = 0;
	extensions__elem_ = 0;
	int t_extensions__elem__it;
	t_extensions__elem__it = 0;
	int t_extensions__size;
	extensions_ = new vector<SSLExtension *>;
	const_byteptr t_extensions__elem__dataptr = t_dataptr_after_ext_len;
	for (; /* forever */; ++t_extensions__elem__it)
		{
		// Check &until(extensions__elem__dataptr >= end_of_data)
		if ( t_extensions__elem__dataptr >= t_end_of_data )
			{
			extensions__elem_ = 0;
			goto end_of_extensions;
			}
		extensions__elem_ = new SSLExtension(rec());
		int t_extensions__elem__size;
		t_extensions__elem__size = extensions__elem_->Parse(t_extensions__elem__dataptr, t_end_of_data, t_context, t_byteorder);
		// Evaluate 'let' and 'withinput' fields
		extensions_->push_back(extensions__elem_);
		t_extensions__elem__dataptr += t_extensions__elem__size;
		BINPAC_ASSERT(t_extensions__elem__dataptr <= t_end_of_data);
		extensions__elem_ = 0;
		}
end_of_extensions: ;
	t_extensions__size = t_extensions__elem__dataptr - (t_dataptr_after_ext_len);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ClientHello__size;
	const_byteptr const t_dataptr_after_extensions = t_dataptr_after_ext_len + (t_extensions__size);
	BINPAC_ASSERT(t_dataptr_after_extensions <= t_end_of_data);
	t_ClientHello__size = t_dataptr_after_extensions - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_client_hello(rec(), client_version(), gmt_unix_time(), random_bytes(), session_id(), csuits(), 0);
	BINPAC_ASSERT(t_begin_of_data + (t_ClientHello__size) <= t_end_of_data);
	return t_ClientHello__size;
	}

V2ClientHello::V2ClientHello(SSLRecord * rec)
	{
	csuit_len_ = 0;
	session_len_ = 0;
	chal_len_ = 0;
	ciphers_ = 0;
	ciphers__elem_ = 0;
	session_id_ = 0;
	session_id__elem_ = 0;
	rec_ = rec;
	client_version_ = 0;
	proc_ = 0;
	}

V2ClientHello::~V2ClientHello()
	{
	delete ciphers__elem_;
	ciphers__elem_ = 0;
	if ( ciphers() )
		{
		for ( int i = 0; i < (int) ciphers()->size(); ++i )
			{
			uint24 * ciphers__elem_ = (*ciphers_)[i];
			delete ciphers__elem_;
			ciphers__elem_ = 0;
			}
		}
	delete ciphers_;
	delete session_id_;
	challenge_.free();
	}

int V2ClientHello::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder)
	{
	int t_V2ClientHello__size;
	// Checking out-of-bound for "V2ClientHello:chal_len"
	if ( (t_begin_of_data + 4) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("V2ClientHello:chal_len",
			(4) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "csuit_len"
	csuit_len_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	// Parse "session_len"
	session_len_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	// Parse "chal_len"
	chal_len_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	t_V2ClientHello__size = 6 + csuit_len() + session_len() + chal_len();
	// Checking out-of-bound for "V2ClientHello"
	if ( t_begin_of_data + (t_V2ClientHello__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("V2ClientHello",
			(0) + (t_V2ClientHello__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + t_V2ClientHello__size;
	
	
	
	// Parse "ciphers"
	int t_ciphers__arraylength;
	t_ciphers__arraylength = 0;
	t_ciphers__arraylength = csuit_len() / 3;
	if ( t_begin_of_data + t_ciphers__arraylength > t_end_of_data + 1 )
		{
		t_ciphers__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_ciphers__arraylength < 0 )
		{
		t_ciphers__arraylength = 0;
		}
	ciphers__elem_ = 0;
	int t_ciphers__elem__it;
	t_ciphers__elem__it = 0;
	int t_ciphers__size;
	ciphers_ = new vector<uint24 *>;
	ciphers_->reserve(t_ciphers__arraylength);
	const_byteptr t_ciphers__elem__dataptr = (t_begin_of_data + 6);
	for (; t_ciphers__elem__it < t_ciphers__arraylength; ++t_ciphers__elem__it)
		{
		// Check &until(ciphers__elem__dataptr >= end_of_data)
		if ( t_ciphers__elem__dataptr >= t_end_of_data )
			{
			ciphers__elem_ = 0;
			goto end_of_ciphers;
			}
		ciphers__elem_ = new uint24();
		ciphers__elem_->Parse(t_ciphers__elem__dataptr, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		ciphers_->push_back(ciphers__elem_);
		t_ciphers__elem__dataptr += 3;
		BINPAC_ASSERT(t_ciphers__elem__dataptr <= t_end_of_data);
		ciphers__elem_ = 0;
		}
end_of_ciphers: ;
	t_ciphers__size = t_ciphers__elem__dataptr - ((t_begin_of_data + 6));
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_ciphers = (t_begin_of_data + 6) + (t_ciphers__size);
	BINPAC_ASSERT(t_dataptr_after_ciphers <= t_end_of_data);
	// Parse "session_id"
	int t_session_id__arraylength;
	t_session_id__arraylength = 0;
	t_session_id__arraylength = session_len();
	if ( t_begin_of_data + t_session_id__arraylength > t_end_of_data + 1 )
		{
		t_session_id__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_session_id__arraylength < 0 )
		{
		t_session_id__arraylength = 0;
		}
	session_id__elem_ = 0;
	int t_session_id__elem__it;
	t_session_id__elem__it = 0;
	int t_session_id__size;
	session_id_ = new vector<uint8>;
	session_id_->reserve(t_session_id__arraylength);
	const_byteptr t_session_id__elem__dataptr = t_dataptr_after_ciphers;
	for (; t_session_id__elem__it < t_session_id__arraylength; ++t_session_id__elem__it)
		{
		// Check &until(session_id__elem__dataptr >= end_of_data)
		if ( t_session_id__elem__dataptr >= t_end_of_data )
			{
			goto end_of_session_id;
			}
		session_id__elem_ = *((uint8 const *) (t_session_id__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		session_id_->push_back(session_id__elem_);
		t_session_id__elem__dataptr += 1;
		BINPAC_ASSERT(t_session_id__elem__dataptr <= t_end_of_data);
		}
end_of_session_id: ;
	t_session_id__size = t_session_id__elem__dataptr - (t_dataptr_after_ciphers);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_session_id = t_dataptr_after_ciphers + (t_session_id__size);
	BINPAC_ASSERT(t_dataptr_after_session_id <= t_end_of_data);
	// Parse "challenge"
	int t_challenge__size;
	t_challenge__size = chal_len();
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_session_id + t_challenge__size;
	int t_challenge_string_length;
	t_challenge_string_length = chal_len();
	// check for negative sizes
	if ( t_challenge_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:285", t_challenge_string_length);
	challenge_.init(t_dataptr_after_session_id, t_challenge_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	// Evaluate 'let' and 'withinput' fields
	client_version_ = rec()->version();
	proc_ = t_context->connection()->proc_client_hello(rec(), client_version(), 0, challenge(), session_id(), 0, ciphers());
	}
	BINPAC_ASSERT(t_begin_of_data + (t_V2ClientHello__size) <= t_end_of_data);
	return t_V2ClientHello__size;
	}

ServerHello::ServerHello(SSLRecord * rec)
	{
	server_version_ = 0;
	gmt_unix_time_ = 0;
	session_len_ = 0;
	session_id_ = 0;
	session_id__elem_ = 0;
	cipher_suite_ = 0;
	cipher_suite__elem_ = 0;
	compression_method_ = 0;
	ext_len_ = 0;
	ext_len__elem_ = 0;
	extensions_ = 0;
	extensions__elem_ = 0;
	rec_ = rec;
	cipher_set_ = 0;
	proc_ = 0;
	}

ServerHello::~ServerHello()
	{
	random_bytes_.free();
	delete session_id_;
	delete cipher_suite_;
	delete ext_len_;
	delete extensions__elem_;
	extensions__elem_ = 0;
	if ( extensions() )
		{
		for ( int i = 0; i < (int) extensions()->size(); ++i )
			{
			SSLExtension * extensions__elem_ = (*extensions_)[i];
			delete extensions__elem_;
			extensions__elem_ = 0;
			}
		}
	delete extensions_;
	}

int ServerHello::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "ServerHello:gmt_unix_time"
	if ( (t_begin_of_data + 2) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ServerHello:gmt_unix_time",
			(2) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "server_version"
	server_version_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "gmt_unix_time"
	gmt_unix_time_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "random_bytes"
	// Checking out-of-bound for "ServerHello:random_bytes"
	if ( (t_begin_of_data + 6) + (28) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ServerHello:random_bytes",
			(6) + (28), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 6) + 28;
	int t_random_bytes_string_length;
	t_random_bytes_string_length = 28;
	int t_random_bytes__size;
	t_random_bytes__size = t_random_bytes_string_length;
	random_bytes_.init((t_begin_of_data + 6), t_random_bytes_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_random_bytes = (t_begin_of_data + 6) + (28);
	BINPAC_ASSERT(t_dataptr_after_random_bytes <= t_end_of_data);
	// Checking out-of-bound for "ServerHello:session_len"
	if ( t_dataptr_after_random_bytes + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ServerHello:session_len",
			((t_dataptr_after_random_bytes - t_begin_of_data)) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "session_len"
	session_len_ = *((uint8 const *) (t_dataptr_after_random_bytes));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "session_id"
	int t_session_id__arraylength;
	t_session_id__arraylength = 0;
	t_session_id__arraylength = session_len();
	if ( t_begin_of_data + t_session_id__arraylength > t_end_of_data + 1 )
		{
		t_session_id__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_session_id__arraylength < 0 )
		{
		t_session_id__arraylength = 0;
		}
	session_id__elem_ = 0;
	int t_session_id__elem__it;
	t_session_id__elem__it = 0;
	int t_session_id__size;
	session_id_ = new vector<uint8>;
	session_id_->reserve(t_session_id__arraylength);
	const_byteptr t_session_id__elem__dataptr = (t_dataptr_after_random_bytes + 1);
	for (; t_session_id__elem__it < t_session_id__arraylength; ++t_session_id__elem__it)
		{
		// Check &until(session_id__elem__dataptr >= end_of_data)
		if ( t_session_id__elem__dataptr >= t_end_of_data )
			{
			goto end_of_session_id;
			}
		// Checking out-of-bound for "ServerHello:session_id__elem"
		if ( t_session_id__elem__dataptr + (1) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("ServerHello:session_id__elem",
				((t_session_id__elem__dataptr - t_begin_of_data)) + (1), 
				(t_end_of_data) - (t_begin_of_data));
			}
		session_id__elem_ = *((uint8 const *) (t_session_id__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		session_id_->push_back(session_id__elem_);
		t_session_id__elem__dataptr += 1;
		BINPAC_ASSERT(t_session_id__elem__dataptr <= t_end_of_data);
		}
end_of_session_id: ;
	t_session_id__size = t_session_id__elem__dataptr - ((t_dataptr_after_random_bytes + 1));
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_session_id = (t_dataptr_after_random_bytes + 1) + (t_session_id__size);
	BINPAC_ASSERT(t_dataptr_after_session_id <= t_end_of_data);
	// Checking out-of-bound for "ServerHello:compression_method"
	if ( (t_dataptr_after_session_id + 2) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ServerHello:compression_method",
			(((t_dataptr_after_session_id + 2) - t_begin_of_data)) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "cipher_suite"
	int t_cipher_suite__arraylength;
	t_cipher_suite__arraylength = 0;
	t_cipher_suite__arraylength = 1;
	if ( t_begin_of_data + t_cipher_suite__arraylength > t_end_of_data + 1 )
		{
		t_cipher_suite__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_cipher_suite__arraylength < 0 )
		{
		t_cipher_suite__arraylength = 0;
		}
	cipher_suite__elem_ = 0;
	int t_cipher_suite__elem__it;
	t_cipher_suite__elem__it = 0;
	cipher_suite_ = new vector<uint16>;
	cipher_suite_->reserve(t_cipher_suite__arraylength);
	const_byteptr t_cipher_suite__elem__dataptr = t_dataptr_after_session_id;
	for (; t_cipher_suite__elem__it < t_cipher_suite__arraylength; ++t_cipher_suite__elem__it)
		{
		// Check &until(cipher_suite__elem__dataptr >= end_of_data)
		if ( t_cipher_suite__elem__dataptr >= t_end_of_data )
			{
			goto end_of_cipher_suite;
			}
		cipher_suite__elem_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_cipher_suite__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		cipher_suite_->push_back(cipher_suite__elem_);
		t_cipher_suite__elem__dataptr += 2;
		BINPAC_ASSERT(t_cipher_suite__elem__dataptr <= t_end_of_data);
		}
end_of_cipher_suite: ;
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "compression_method"
	compression_method_ = *((uint8 const *) ((t_dataptr_after_session_id + 2)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "ext_len"
	int t_ext_len__arraylength;
	t_ext_len__arraylength = 0;
	ext_len__elem_ = 0;
	int t_ext_len__elem__it;
	t_ext_len__elem__it = 0;
	int t_ext_len__size;
	ext_len_ = new vector<uint16>;
	const_byteptr t_ext_len__elem__dataptr = (t_dataptr_after_session_id + 3);
	for (; /* forever */; ++t_ext_len__elem__it)
		{
		// Check &until(ext_len__elem__dataptr >= end_of_data)
		if ( t_ext_len__elem__dataptr >= t_end_of_data )
			{
			goto end_of_ext_len;
			}
		// Checking out-of-bound for "ServerHello:ext_len__elem"
		if ( t_ext_len__elem__dataptr + (2) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("ServerHello:ext_len__elem",
				((t_ext_len__elem__dataptr - t_begin_of_data)) + (2), 
				(t_end_of_data) - (t_begin_of_data));
			}
		ext_len__elem_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_ext_len__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		ext_len_->push_back(ext_len__elem_);
		t_ext_len__elem__dataptr += 2;
		BINPAC_ASSERT(t_ext_len__elem__dataptr <= t_end_of_data);
		// Check &until( ( $element == ((int) 0) || $element != ((int) 0) ) )
		if (  ( ext_len__elem_ == 0 || ext_len__elem_ != 0 )  )
			{
			goto end_of_ext_len;
			}
		}
end_of_ext_len: ;
	t_ext_len__size = t_ext_len__elem__dataptr - ((t_dataptr_after_session_id + 3));
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_ext_len = (t_dataptr_after_session_id + 3) + (t_ext_len__size);
	BINPAC_ASSERT(t_dataptr_after_ext_len <= t_end_of_data);
	// Parse "extensions"
	int t_extensions__arraylength;
	t_extensions__arraylength = 0;
	extensions__elem_ = 0;
	int t_extensions__elem__it;
	t_extensions__elem__it = 0;
	int t_extensions__size;
	extensions_ = new vector<SSLExtension *>;
	const_byteptr t_extensions__elem__dataptr = t_dataptr_after_ext_len;
	for (; /* forever */; ++t_extensions__elem__it)
		{
		// Check &until(extensions__elem__dataptr >= end_of_data)
		if ( t_extensions__elem__dataptr >= t_end_of_data )
			{
			extensions__elem_ = 0;
			goto end_of_extensions;
			}
		extensions__elem_ = new SSLExtension(rec());
		int t_extensions__elem__size;
		t_extensions__elem__size = extensions__elem_->Parse(t_extensions__elem__dataptr, t_end_of_data, t_context, t_byteorder);
		// Evaluate 'let' and 'withinput' fields
		extensions_->push_back(extensions__elem_);
		t_extensions__elem__dataptr += t_extensions__elem__size;
		BINPAC_ASSERT(t_extensions__elem__dataptr <= t_end_of_data);
		extensions__elem_ = 0;
		}
end_of_extensions: ;
	t_extensions__size = t_extensions__elem__dataptr - (t_dataptr_after_ext_len);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ServerHello__size;
	const_byteptr const t_dataptr_after_extensions = t_dataptr_after_ext_len + (t_extensions__size);
	BINPAC_ASSERT(t_dataptr_after_extensions <= t_end_of_data);
	t_ServerHello__size = t_dataptr_after_extensions - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	cipher_set_ = t_context->connection()->set_cipher((*(cipher_suite()))[0]);
	proc_ = t_context->connection()->proc_server_hello(rec(), server_version(), gmt_unix_time(), random_bytes(), session_id(), cipher_suite(), 0, compression_method());
	BINPAC_ASSERT(t_begin_of_data + (t_ServerHello__size) <= t_end_of_data);
	return t_ServerHello__size;
	}

V2ServerHello::V2ServerHello(SSLRecord * rec)
	{
	server_version_ = 0;
	cert_len_ = 0;
	ciph_len_ = 0;
	conn_id_len_ = 0;
	ciphers_ = 0;
	ciphers__elem_ = 0;
	rec_ = rec;
	session_id_hit_ = 0;
	cert_type_ = 0;
	proc_ = 0;
	check_v2_ = 0;
	cert_ = 0;
	}

V2ServerHello::~V2ServerHello()
	{
	cert_data_.free();
	delete ciphers__elem_;
	ciphers__elem_ = 0;
	if ( ciphers() )
		{
		for ( int i = 0; i < (int) ciphers()->size(); ++i )
			{
			uint24 * ciphers__elem_ = (*ciphers_)[i];
			delete ciphers__elem_;
			ciphers__elem_ = 0;
			}
		}
	delete ciphers_;
	conn_id_data_.free();
	}

int V2ServerHello::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "V2ServerHello:conn_id_len"
	if ( (t_begin_of_data + 6) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("V2ServerHello:conn_id_len",
			(6) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "server_version"
	server_version_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "cert_len"
	cert_len_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "ciph_len"
	ciph_len_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "conn_id_len"
	conn_id_len_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 6))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "cert_data"
	int t_cert_data__size;
	t_cert_data__size = cert_len();
	// Checking out-of-bound for "V2ServerHello:cert_data"
	if ( (t_begin_of_data + 8) + (t_cert_data__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("V2ServerHello:cert_data",
			(8) + (t_cert_data__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 8) + t_cert_data__size;
	int t_cert_data_string_length;
	t_cert_data_string_length = cert_len();
	// check for negative sizes
	if ( t_cert_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:323", t_cert_data_string_length);
	cert_data_.init((t_begin_of_data + 8), t_cert_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_cert_data = (t_begin_of_data + 8) + (t_cert_data__size);
	BINPAC_ASSERT(t_dataptr_after_cert_data <= t_end_of_data);
	// Parse "ciphers"
	int t_ciphers__arraylength;
	t_ciphers__arraylength = 0;
	t_ciphers__arraylength = ciph_len() / 3;
	if ( t_begin_of_data + t_ciphers__arraylength > t_end_of_data + 1 )
		{
		t_ciphers__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_ciphers__arraylength < 0 )
		{
		t_ciphers__arraylength = 0;
		}
	ciphers__elem_ = 0;
	int t_ciphers__elem__it;
	t_ciphers__elem__it = 0;
	int t_ciphers__size;
	ciphers_ = new vector<uint24 *>;
	ciphers_->reserve(t_ciphers__arraylength);
	const_byteptr t_ciphers__elem__dataptr = t_dataptr_after_cert_data;
	for (; t_ciphers__elem__it < t_ciphers__arraylength; ++t_ciphers__elem__it)
		{
		// Check &until(ciphers__elem__dataptr >= end_of_data)
		if ( t_ciphers__elem__dataptr >= t_end_of_data )
			{
			ciphers__elem_ = 0;
			goto end_of_ciphers;
			}
		ciphers__elem_ = new uint24();
		ciphers__elem_->Parse(t_ciphers__elem__dataptr, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		ciphers_->push_back(ciphers__elem_);
		t_ciphers__elem__dataptr += 3;
		BINPAC_ASSERT(t_ciphers__elem__dataptr <= t_end_of_data);
		ciphers__elem_ = 0;
		}
end_of_ciphers: ;
	t_ciphers__size = t_ciphers__elem__dataptr - (t_dataptr_after_cert_data);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_ciphers = t_dataptr_after_cert_data + (t_ciphers__size);
	BINPAC_ASSERT(t_dataptr_after_ciphers <= t_end_of_data);
	// Parse "conn_id_data"
	int t_conn_id_data__size;
	t_conn_id_data__size = conn_id_len();
	// Checking out-of-bound for "V2ServerHello:conn_id_data"
	if ( t_dataptr_after_ciphers + (t_conn_id_data__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("V2ServerHello:conn_id_data",
			((t_dataptr_after_ciphers - t_begin_of_data)) + (t_conn_id_data__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_ciphers + t_conn_id_data__size;
	int t_conn_id_data_string_length;
	t_conn_id_data_string_length = conn_id_len();
	// check for negative sizes
	if ( t_conn_id_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:325", t_conn_id_data_string_length);
	conn_id_data_.init(t_dataptr_after_ciphers, t_conn_id_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_V2ServerHello__size;
	const_byteptr const t_dataptr_after_conn_id_data = t_dataptr_after_ciphers + (t_conn_id_data__size);
	BINPAC_ASSERT(t_dataptr_after_conn_id_data <= t_end_of_data);
	t_V2ServerHello__size = t_dataptr_after_conn_id_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	session_id_hit_ = rec()->head3();
	cert_type_ = rec()->head4();
	proc_ = t_context->connection()->proc_server_hello(rec(), server_version(), 0, conn_id_data(), 0, 0, ciphers(), 0);
	check_v2_ = t_context->connection()->proc_check_v2_server_hello_version(server_version());
	cert_ = t_context->connection()->proc_v2_certificate(rec(), cert_data());
	BINPAC_ASSERT(t_begin_of_data + (t_V2ServerHello__size) <= t_end_of_data);
	return t_V2ServerHello__size;
	}

X509Certificate::X509Certificate()
	{
	length_ = 0;
	}

X509Certificate::~X509Certificate()
	{
	delete length_;
	length_ = 0;
	certificate_.free();
	}

int X509Certificate::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "X509Certificate:length"
	if ( t_begin_of_data + (3) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("X509Certificate:length",
			(0) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = new uint24();
	length_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "certificate"
	int t_certificate__size;
	t_certificate__size = to_int()(length());
	// Checking out-of-bound for "X509Certificate:certificate"
	if ( (t_begin_of_data + 3) + (t_certificate__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("X509Certificate:certificate",
			(3) + (t_certificate__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 3) + t_certificate__size;
	int t_certificate_string_length;
	t_certificate_string_length = to_int()(length());
	// check for negative sizes
	if ( t_certificate_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:338", t_certificate_string_length);
	certificate_.init((t_begin_of_data + 3), t_certificate_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_X509Certificate__size;
	const_byteptr const t_dataptr_after_certificate = (t_begin_of_data + 3) + (t_certificate__size);
	BINPAC_ASSERT(t_dataptr_after_certificate <= t_end_of_data);
	t_X509Certificate__size = t_dataptr_after_certificate - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_X509Certificate__size) <= t_end_of_data);
	return t_X509Certificate__size;
	}

Certificate::Certificate(SSLRecord * rec)
	{
	length_ = 0;
	certificates_ = 0;
	certificates__elem_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

Certificate::~Certificate()
	{
	delete length_;
	length_ = 0;
	delete certificates__elem_;
	certificates__elem_ = 0;
	if ( certificates() )
		{
		for ( int i = 0; i < (int) certificates()->size(); ++i )
			{
			X509Certificate * certificates__elem_ = (*certificates_)[i];
			delete certificates__elem_;
			certificates__elem_ = 0;
			}
		}
	delete certificates_;
	}

int Certificate::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context)
	{
	int t_Certificate__size;
	// Checking out-of-bound for "Certificate:length"
	if ( t_begin_of_data + (3) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Certificate:length",
			(0) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "length"
	length_ = new uint24();
	length_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	t_Certificate__size = to_int()(length()) + 3;
	// Checking out-of-bound for "Certificate"
	if ( t_begin_of_data + (t_Certificate__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Certificate",
			(0) + (t_Certificate__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + t_Certificate__size;
	
	// Parse "certificates"
	int t_certificates__arraylength;
	t_certificates__arraylength = 0;
	certificates__elem_ = 0;
	int t_certificates__elem__it;
	t_certificates__elem__it = 0;
	int t_certificates__size;
	certificates_ = new vector<X509Certificate *>;
	const_byteptr t_certificates__elem__dataptr = (t_begin_of_data + 3);
	for (; /* forever */; ++t_certificates__elem__it)
		{
		// Check &until(certificates__elem__dataptr >= end_of_data)
		if ( t_certificates__elem__dataptr >= t_end_of_data )
			{
			certificates__elem_ = 0;
			goto end_of_certificates;
			}
		certificates__elem_ = new X509Certificate();
		int t_certificates__elem__size;
		t_certificates__elem__size = certificates__elem_->Parse(t_certificates__elem__dataptr, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		certificates_->push_back(certificates__elem_);
		t_certificates__elem__dataptr += t_certificates__elem__size;
		BINPAC_ASSERT(t_certificates__elem__dataptr <= t_end_of_data);
		certificates__elem_ = 0;
		}
end_of_certificates: ;
	t_certificates__size = t_certificates__elem__dataptr - ((t_begin_of_data + 3));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_v3_certificate(rec(), certificates());
	}
	BINPAC_ASSERT(t_begin_of_data + (t_Certificate__size) <= t_end_of_data);
	return t_Certificate__size;
	}

CertificateStatus::CertificateStatus(SSLRecord * rec)
	{
	status_type_ = 0;
	length_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

CertificateStatus::~CertificateStatus()
	{
	delete length_;
	length_ = 0;
	response_.free();
	}

int CertificateStatus::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context)
	{
	// Checking out-of-bound for "CertificateStatus:length"
	if ( (t_begin_of_data + 1) + (3) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("CertificateStatus:length",
			(1) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "status_type"
	status_type_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "length"
	length_ = new uint24();
	length_->Parse((t_begin_of_data + 1), t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "response"
	int t_response_string_length;
	t_response_string_length = (t_end_of_data) - ((t_begin_of_data + 4));
	int t_response__size;
	t_response__size = t_response_string_length;
	// check for negative sizes
	if ( t_response_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:351", t_response_string_length);
	response_.init((t_begin_of_data + 4), t_response_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_CertificateStatus__size;
	const_byteptr const t_dataptr_after_response = (t_begin_of_data + 4) + (t_response__size);
	BINPAC_ASSERT(t_dataptr_after_response <= t_end_of_data);
	t_CertificateStatus__size = t_dataptr_after_response - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_certificate_status(rec(), status_type(), response());
	BINPAC_ASSERT(t_begin_of_data + (t_CertificateStatus__size) <= t_end_of_data);
	return t_CertificateStatus__size;
	}

ServerKeyExchange::ServerKeyExchange(SSLRecord * rec)
	{
	val_case_index_ = -1;
	ec_server_key_exchange_ = 0;
	dh_server_key_exchange_ = 0;
	rec_ = rec;
	}

ServerKeyExchange::~ServerKeyExchange()
	{
	switch ( val_case_index() )
		{
		case 49153:
		case 49154:
		case 49155:
		case 49156:
		case 49157:
		case 49158:
		case 49159:
		case 49160:
		case 49161:
		case 49162:
		case 49163:
		case 49164:
		case 49165:
		case 49166:
		case 49167:
		case 49168:
		case 49169:
		case 49170:
		case 49171:
		case 49172:
		case 49173:
		case 49174:
		case 49175:
		case 49176:
		case 49177:
		case 49187:
		case 49188:
		case 49189:
		case 49190:
		case 49191:
		case 49192:
		case 49193:
		case 49194:
		case 49195:
		case 49196:
		case 49197:
		case 49198:
		case 49199:
		case 49200:
		case 49201:
		case 49202:
		case 49203:
		case 49204:
		case 49205:
		case 49206:
		case 49207:
		case 49208:
		case 49209:
		case 49210:
		case 49211:
		case 49224:
		case 49225:
		case 49226:
		case 49227:
		case 49228:
		case 49229:
		case 49230:
		case 49231:
		case 49244:
		case 49245:
		case 49246:
		case 49247:
		case 49248:
		case 49249:
		case 49250:
		case 49251:
		case 49264:
		case 49265:
		case 49266:
		case 49267:
		case 49268:
		case 49269:
		case 49270:
		case 49271:
		case 49272:
		case 49273:
		case 49286:
		case 49287:
		case 49288:
		case 49289:
		case 49290:
		case 49291:
		case 49292:
		case 49293:
		case 49306:
		case 49307:
		case 49324:
		case 49325:
		case 49326:
		case 49327:
		case 52243:
		case 52244:
			// Clean up "ec_server_key_exchange"
			{
			delete ec_server_key_exchange_;
			ec_server_key_exchange_ = 0;
			}
			break;
		case 17:
		case 18:
		case 19:
		case 20:
		case 21:
		case 22:
		case 50:
		case 51:
		case 56:
		case 57:
		case 64:
		case 68:
		case 69:
		case 99:
		case 101:
		case 102:
		case 103:
		case 106:
		case 107:
		case 114:
		case 115:
		case 116:
		case 119:
		case 120:
		case 121:
		case 135:
		case 136:
		case 142:
		case 143:
		case 144:
		case 145:
		case 153:
		case 154:
		case 158:
		case 159:
		case 162:
		case 163:
		case 170:
		case 171:
		case 178:
		case 179:
		case 180:
		case 181:
		case 189:
		case 190:
		case 195:
		case 196:
		case 49218:
		case 49219:
		case 49220:
		case 49221:
		case 49234:
		case 49235:
		case 49238:
		case 49239:
		case 49254:
		case 49255:
		case 49260:
		case 49261:
		case 49276:
		case 49277:
		case 49280:
		case 49281:
		case 49296:
		case 49297:
		case 49302:
		case 49303:
		case 49310:
		case 49311:
		case 49314:
		case 49315:
		case 49318:
		case 49319:
		case 49322:
		case 49323:
		case 52245:
		case 23:
		case 24:
		case 25:
		case 26:
		case 27:
		case 52:
		case 58:
		case 70:
		case 108:
		case 109:
		case 137:
		case 155:
		case 166:
		case 167:
		case 191:
		case 197:
		case 49222:
		case 49223:
		case 49242:
		case 49243:
		case 49284:
		case 49285:
			// Clean up "dh_server_key_exchange"
			{
			delete dh_server_key_exchange_;
			dh_server_key_exchange_ = 0;
			}
			break;
		default:
			// Clean up "key"
			{
			}
			break;
		}
	}

int ServerKeyExchange::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder)
	{
	int t_val__size;
	val_case_index_ = t_context->connection()->chosen_cipher();
	switch ( val_case_index() )
		{
		case 49153:
		case 49154:
		case 49155:
		case 49156:
		case 49157:
		case 49158:
		case 49159:
		case 49160:
		case 49161:
		case 49162:
		case 49163:
		case 49164:
		case 49165:
		case 49166:
		case 49167:
		case 49168:
		case 49169:
		case 49170:
		case 49171:
		case 49172:
		case 49173:
		case 49174:
		case 49175:
		case 49176:
		case 49177:
		case 49187:
		case 49188:
		case 49189:
		case 49190:
		case 49191:
		case 49192:
		case 49193:
		case 49194:
		case 49195:
		case 49196:
		case 49197:
		case 49198:
		case 49199:
		case 49200:
		case 49201:
		case 49202:
		case 49203:
		case 49204:
		case 49205:
		case 49206:
		case 49207:
		case 49208:
		case 49209:
		case 49210:
		case 49211:
		case 49224:
		case 49225:
		case 49226:
		case 49227:
		case 49228:
		case 49229:
		case 49230:
		case 49231:
		case 49244:
		case 49245:
		case 49246:
		case 49247:
		case 49248:
		case 49249:
		case 49250:
		case 49251:
		case 49264:
		case 49265:
		case 49266:
		case 49267:
		case 49268:
		case 49269:
		case 49270:
		case 49271:
		case 49272:
		case 49273:
		case 49286:
		case 49287:
		case 49288:
		case 49289:
		case 49290:
		case 49291:
		case 49292:
		case 49293:
		case 49306:
		case 49307:
		case 49324:
		case 49325:
		case 49326:
		case 49327:
		case 52243:
		case 52244:
			// Parse "ec_server_key_exchange"
			{
			ec_server_key_exchange_ = new EcServerKeyExchange(rec());
			int t_ec_server_key_exchange__size;
			t_ec_server_key_exchange__size = ec_server_key_exchange_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_ec_server_key_exchange__size;
			}
			break;
		case 17:
		case 18:
		case 19:
		case 20:
		case 21:
		case 22:
		case 50:
		case 51:
		case 56:
		case 57:
		case 64:
		case 68:
		case 69:
		case 99:
		case 101:
		case 102:
		case 103:
		case 106:
		case 107:
		case 114:
		case 115:
		case 116:
		case 119:
		case 120:
		case 121:
		case 135:
		case 136:
		case 142:
		case 143:
		case 144:
		case 145:
		case 153:
		case 154:
		case 158:
		case 159:
		case 162:
		case 163:
		case 170:
		case 171:
		case 178:
		case 179:
		case 180:
		case 181:
		case 189:
		case 190:
		case 195:
		case 196:
		case 49218:
		case 49219:
		case 49220:
		case 49221:
		case 49234:
		case 49235:
		case 49238:
		case 49239:
		case 49254:
		case 49255:
		case 49260:
		case 49261:
		case 49276:
		case 49277:
		case 49280:
		case 49281:
		case 49296:
		case 49297:
		case 49302:
		case 49303:
		case 49310:
		case 49311:
		case 49314:
		case 49315:
		case 49318:
		case 49319:
		case 49322:
		case 49323:
		case 52245:
		case 23:
		case 24:
		case 25:
		case 26:
		case 27:
		case 52:
		case 58:
		case 70:
		case 108:
		case 109:
		case 137:
		case 155:
		case 166:
		case 167:
		case 191:
		case 197:
		case 49222:
		case 49223:
		case 49242:
		case 49243:
		case 49284:
		case 49285:
			// Parse "dh_server_key_exchange"
			{
			dh_server_key_exchange_ = new DhServerKeyExchange(rec());
			int t_dh_server_key_exchange__size;
			t_dh_server_key_exchange__size = dh_server_key_exchange_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_dh_server_key_exchange__size;
			}
			break;
		default:
			// Parse "key"
			{
			int t_key_string_length;
			t_key_string_length = (t_end_of_data) - (t_begin_of_data);
			int t_key__size;
			t_key__size = t_key_string_length;
			// check for negative sizes
			if ( t_key_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:563", t_key_string_length);
			key_.init(t_begin_of_data, t_key_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_key__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

EcServerKeyExchange::EcServerKeyExchange(SSLRecord * rec)
	{
	curve_type_ = 0;
	curve_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

EcServerKeyExchange::~EcServerKeyExchange()
	{
	}

int EcServerKeyExchange::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "EcServerKeyExchange:curve"
	if ( (t_begin_of_data + 1) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("EcServerKeyExchange:curve",
			(1) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "curve_type"
	curve_type_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "curve"
	curve_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - ((t_begin_of_data + 3));
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:572", t_data_string_length);
	data_.init((t_begin_of_data + 3), t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_EcServerKeyExchange__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 3) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_EcServerKeyExchange__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_ec_server_key_exchange(rec(), curve_type(), curve());
	BINPAC_ASSERT(t_begin_of_data + (t_EcServerKeyExchange__size) <= t_end_of_data);
	return t_EcServerKeyExchange__size;
	}

DhServerKeyExchange::DhServerKeyExchange(SSLRecord * rec)
	{
	dh_p_length_ = 0;
	dh_g_length_ = 0;
	dh_Ys_length_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

DhServerKeyExchange::~DhServerKeyExchange()
	{
	dh_p_.free();
	dh_g_.free();
	dh_Ys_.free();
	}

int DhServerKeyExchange::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "DhServerKeyExchange:dh_p_length"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DhServerKeyExchange:dh_p_length",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "dh_p_length"
	dh_p_length_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "dh_p"
	int t_dh_p__size;
	t_dh_p__size = dh_p_length();
	// Checking out-of-bound for "DhServerKeyExchange:dh_p"
	if ( (t_begin_of_data + 2) + (t_dh_p__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DhServerKeyExchange:dh_p",
			(2) + (t_dh_p__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 2) + t_dh_p__size;
	int t_dh_p_string_length;
	t_dh_p_string_length = dh_p_length();
	// check for negative sizes
	if ( t_dh_p_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:579", t_dh_p_string_length);
	dh_p_.init((t_begin_of_data + 2), t_dh_p_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_dh_p = (t_begin_of_data + 2) + (t_dh_p__size);
	BINPAC_ASSERT(t_dataptr_after_dh_p <= t_end_of_data);
	// Checking out-of-bound for "DhServerKeyExchange:dh_g_length"
	if ( t_dataptr_after_dh_p + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DhServerKeyExchange:dh_g_length",
			((t_dataptr_after_dh_p - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "dh_g_length"
	dh_g_length_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_dataptr_after_dh_p)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "dh_g"
	int t_dh_g__size;
	t_dh_g__size = dh_g_length();
	// Checking out-of-bound for "DhServerKeyExchange:dh_g"
	if ( (t_dataptr_after_dh_p + 2) + (t_dh_g__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DhServerKeyExchange:dh_g",
			(((t_dataptr_after_dh_p + 2) - t_begin_of_data)) + (t_dh_g__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_dataptr_after_dh_p + 2) + t_dh_g__size;
	int t_dh_g_string_length;
	t_dh_g_string_length = dh_g_length();
	// check for negative sizes
	if ( t_dh_g_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:581", t_dh_g_string_length);
	dh_g_.init((t_dataptr_after_dh_p + 2), t_dh_g_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_dh_g = (t_dataptr_after_dh_p + 2) + (t_dh_g__size);
	BINPAC_ASSERT(t_dataptr_after_dh_g <= t_end_of_data);
	// Checking out-of-bound for "DhServerKeyExchange:dh_Ys_length"
	if ( t_dataptr_after_dh_g + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DhServerKeyExchange:dh_Ys_length",
			((t_dataptr_after_dh_g - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "dh_Ys_length"
	dh_Ys_length_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_dataptr_after_dh_g)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "dh_Ys"
	int t_dh_Ys__size;
	t_dh_Ys__size = dh_Ys_length();
	// Checking out-of-bound for "DhServerKeyExchange:dh_Ys"
	if ( (t_dataptr_after_dh_g + 2) + (t_dh_Ys__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DhServerKeyExchange:dh_Ys",
			(((t_dataptr_after_dh_g + 2) - t_begin_of_data)) + (t_dh_Ys__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_dataptr_after_dh_g + 2) + t_dh_Ys__size;
	int t_dh_Ys_string_length;
	t_dh_Ys_string_length = dh_Ys_length();
	// check for negative sizes
	if ( t_dh_Ys_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:583", t_dh_Ys_string_length);
	dh_Ys_.init((t_dataptr_after_dh_g + 2), t_dh_Ys_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_dh_Ys = (t_dataptr_after_dh_g + 2) + (t_dh_Ys__size);
	BINPAC_ASSERT(t_dataptr_after_dh_Ys <= t_end_of_data);
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - (t_dataptr_after_dh_Ys);
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:584", t_data_string_length);
	data_.init(t_dataptr_after_dh_Ys, t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_DhServerKeyExchange__size;
	const_byteptr const t_dataptr_after_data = t_dataptr_after_dh_Ys + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_DhServerKeyExchange__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_dh_server_key_exchange(rec(), dh_p(), dh_g(), dh_Ys());
	BINPAC_ASSERT(t_begin_of_data + (t_DhServerKeyExchange__size) <= t_end_of_data);
	return t_DhServerKeyExchange__size;
	}

CertificateRequest::CertificateRequest(SSLRecord * rec)
	{
	rec_ = rec;
	}

CertificateRequest::~CertificateRequest()
	{
	}

int CertificateRequest::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context)
	{
	// Parse "cont"
	int t_cont_string_length;
	t_cont_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_cont__size;
	t_cont__size = t_cont_string_length;
	// check for negative sizes
	if ( t_cont_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:594", t_cont_string_length);
	cont_.init(t_begin_of_data, t_cont_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_CertificateRequest__size;
	const_byteptr const t_dataptr_after_cont = t_begin_of_data + (t_cont__size);
	BINPAC_ASSERT(t_dataptr_after_cont <= t_end_of_data);
	t_CertificateRequest__size = t_dataptr_after_cont - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_CertificateRequest__size) <= t_end_of_data);
	return t_CertificateRequest__size;
	}

ServerHelloDone::ServerHelloDone(SSLRecord * rec)
	{
	rec_ = rec;
	}

ServerHelloDone::~ServerHelloDone()
	{
	}

int ServerHelloDone::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context)
	{
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (0) <= t_end_of_data);
	return 0;
	}

ClientKeyExchange::ClientKeyExchange(SSLRecord * rec)
	{
	rec_ = rec;
	}

ClientKeyExchange::~ClientKeyExchange()
	{
	}

int ClientKeyExchange::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context)
	{
	// Parse "key"
	int t_key_string_length;
	t_key_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_key__size;
	t_key__size = t_key_string_length;
	// check for negative sizes
	if ( t_key_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:621", t_key_string_length);
	key_.init(t_begin_of_data, t_key_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_ClientKeyExchange__size;
	const_byteptr const t_dataptr_after_key = t_begin_of_data + (t_key__size);
	BINPAC_ASSERT(t_dataptr_after_key <= t_end_of_data);
	t_ClientKeyExchange__size = t_dataptr_after_key - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ClientKeyExchange__size) <= t_end_of_data);
	return t_ClientKeyExchange__size;
	}

V2ClientMasterKey::V2ClientMasterKey(SSLRecord * rec)
	{
	cipher_kind_8_ = 0;
	cl_key_len_ = 0;
	en_key_len_ = 0;
	key_arg_len_ = 0;
	rec_ = rec;
	cipher_kind_ = 0;
	state_changed_client_ = 0;
	state_changed_server_ = 0;
	proc_ = 0;
	}

V2ClientMasterKey::~V2ClientMasterKey()
	{
	}

int V2ClientMasterKey::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder)
	{
	int t_V2ClientMasterKey__size;
	// Checking out-of-bound for "V2ClientMasterKey:key_arg_len"
	if ( (t_begin_of_data + 5) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("V2ClientMasterKey:key_arg_len",
			(5) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "cl_key_len"
	cl_key_len_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	// Parse "en_key_len"
	en_key_len_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 3))));
	// Evaluate 'let' and 'withinput' fields
	// Parse "key_arg_len"
	key_arg_len_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 5))));
	// Evaluate 'let' and 'withinput' fields
	t_V2ClientMasterKey__size = 7 + cl_key_len() + en_key_len() + key_arg_len();
	// Checking out-of-bound for "V2ClientMasterKey"
	if ( t_begin_of_data + (t_V2ClientMasterKey__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("V2ClientMasterKey",
			(0) + (t_V2ClientMasterKey__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + t_V2ClientMasterKey__size;
	// Parse "cipher_kind_8"
	cipher_kind_8_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	
	
	
	// Parse "cl_key_data"
	int t_cl_key_data__size;
	t_cl_key_data__size = cl_key_len();
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 7) + t_cl_key_data__size;
	int t_cl_key_data_string_length;
	t_cl_key_data_string_length = cl_key_len();
	// check for negative sizes
	if ( t_cl_key_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:633", t_cl_key_data_string_length);
	cl_key_data_.init((t_begin_of_data + 7), t_cl_key_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_cl_key_data = (t_begin_of_data + 7) + (t_cl_key_data__size);
	BINPAC_ASSERT(t_dataptr_after_cl_key_data <= t_end_of_data);
	// Parse "en_key_data"
	int t_en_key_data__size;
	t_en_key_data__size = en_key_len();
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_cl_key_data + t_en_key_data__size;
	int t_en_key_data_string_length;
	t_en_key_data_string_length = en_key_len();
	// check for negative sizes
	if ( t_en_key_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:634", t_en_key_data_string_length);
	en_key_data_.init(t_dataptr_after_cl_key_data, t_en_key_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_en_key_data = t_dataptr_after_cl_key_data + (t_en_key_data__size);
	BINPAC_ASSERT(t_dataptr_after_en_key_data <= t_end_of_data);
	// Parse "key_arg_data"
	int t_key_arg_data__size;
	t_key_arg_data__size = key_arg_len();
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_en_key_data + t_key_arg_data__size;
	int t_key_arg_data_string_length;
	t_key_arg_data_string_length = key_arg_len();
	// check for negative sizes
	if ( t_key_arg_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:635", t_key_arg_data_string_length);
	key_arg_data_.init(t_dataptr_after_en_key_data, t_key_arg_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	// Evaluate 'let' and 'withinput' fields
	cipher_kind_ =  (  (  ( rec()->head3() << 16 )  |  ( rec()->head4() << 8 )  )  | cipher_kind_8() ) ;
	state_changed_client_ = t_context->connection()->startEncryption(true);
	state_changed_server_ = t_context->connection()->startEncryption(false);
	proc_ = t_context->connection()->proc_v2_client_master_key(rec(), cipher_kind());
	}
	BINPAC_ASSERT(t_begin_of_data + (t_V2ClientMasterKey__size) <= t_end_of_data);
	return t_V2ClientMasterKey__size;
	}

CertificateVerify::CertificateVerify(SSLRecord * rec)
	{
	rec_ = rec;
	}

CertificateVerify::~CertificateVerify()
	{
	}

int CertificateVerify::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context)
	{
	// Parse "cont"
	int t_cont_string_length;
	t_cont_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_cont__size;
	t_cont__size = t_cont_string_length;
	// check for negative sizes
	if ( t_cont_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:650", t_cont_string_length);
	cont_.init(t_begin_of_data, t_cont_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_CertificateVerify__size;
	const_byteptr const t_dataptr_after_cont = t_begin_of_data + (t_cont__size);
	BINPAC_ASSERT(t_dataptr_after_cont <= t_end_of_data);
	t_CertificateVerify__size = t_dataptr_after_cont - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_CertificateVerify__size) <= t_end_of_data);
	return t_CertificateVerify__size;
	}

Finished::Finished(SSLRecord * rec)
	{
	rec_ = rec;
	}

Finished::~Finished()
	{
	}

int Finished::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context)
	{
	// Parse "cont"
	int t_cont_string_length;
	t_cont_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_cont__size;
	t_cont__size = t_cont_string_length;
	// check for negative sizes
	if ( t_cont_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:661", t_cont_string_length);
	cont_.init(t_begin_of_data, t_cont_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_Finished__size;
	const_byteptr const t_dataptr_after_cont = t_begin_of_data + (t_cont__size);
	BINPAC_ASSERT(t_dataptr_after_cont <= t_end_of_data);
	t_Finished__size = t_dataptr_after_cont - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Finished__size) <= t_end_of_data);
	return t_Finished__size;
	}

SessionTicketHandshake::SessionTicketHandshake(SSLRecord * rec)
	{
	ticket_lifetime_hint_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

SessionTicketHandshake::~SessionTicketHandshake()
	{
	data_.free();
	}

int SessionTicketHandshake::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "SessionTicketHandshake:ticket_lifetime_hint"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SessionTicketHandshake:ticket_lifetime_hint",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "ticket_lifetime_hint"
	ticket_lifetime_hint_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - ((t_begin_of_data + 4));
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:666", t_data_string_length);
	data_.init((t_begin_of_data + 4), t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_SessionTicketHandshake__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 4) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_SessionTicketHandshake__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_session_ticket_handshake(this, rec()->is_orig());
	BINPAC_ASSERT(t_begin_of_data + (t_SessionTicketHandshake__size) <= t_end_of_data);
	return t_SessionTicketHandshake__size;
	}

UnknownHandshake::UnknownHandshake(Handshake * hs, bool is_orig)
	{
	hs_ = hs;
	is_orig_ = is_orig;
	proc_ = 0;
	}

UnknownHandshake::~UnknownHandshake()
	{
	}

int UnknownHandshake::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context)
	{
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:674", t_data_string_length);
	data_.init(t_begin_of_data, t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_UnknownHandshake__size;
	const_byteptr const t_dataptr_after_data = t_begin_of_data + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_UnknownHandshake__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_unknown_handshake(hs(), is_orig());
	BINPAC_ASSERT(t_begin_of_data + (t_UnknownHandshake__size) <= t_end_of_data);
	return t_UnknownHandshake__size;
	}

Handshake::Handshake(SSLRecord * rec)
	{
	msg_type_ = 0;
	length_ = 0;
	body_case_index_ = -1;
	hello_request_ = 0;
	client_hello_ = 0;
	server_hello_ = 0;
	session_ticket_ = 0;
	certificate_ = 0;
	server_key_exchange_ = 0;
	certificate_request_ = 0;
	server_hello_done_ = 0;
	certificate_verify_ = 0;
	client_key_exchange_ = 0;
	finished_ = 0;
	certificate_status_ = 0;
	unknown_handshake_ = 0;
	rec_ = rec;
	proc_ = 0;
	}

Handshake::~Handshake()
	{
	delete length_;
	length_ = 0;
	switch ( body_case_index() )
		{
		case 0:
			// Clean up "hello_request"
			{
			delete hello_request_;
			hello_request_ = 0;
			}
			break;
		case 1:
			// Clean up "client_hello"
			{
			delete client_hello_;
			client_hello_ = 0;
			}
			break;
		case 2:
			// Clean up "server_hello"
			{
			delete server_hello_;
			server_hello_ = 0;
			}
			break;
		case 4:
			// Clean up "session_ticket"
			{
			delete session_ticket_;
			session_ticket_ = 0;
			}
			break;
		case 11:
			// Clean up "certificate"
			{
			delete certificate_;
			certificate_ = 0;
			}
			break;
		case 12:
			// Clean up "server_key_exchange"
			{
			delete server_key_exchange_;
			server_key_exchange_ = 0;
			}
			break;
		case 13:
			// Clean up "certificate_request"
			{
			delete certificate_request_;
			certificate_request_ = 0;
			}
			break;
		case 14:
			// Clean up "server_hello_done"
			{
			delete server_hello_done_;
			server_hello_done_ = 0;
			}
			break;
		case 15:
			// Clean up "certificate_verify"
			{
			delete certificate_verify_;
			certificate_verify_ = 0;
			}
			break;
		case 16:
			// Clean up "client_key_exchange"
			{
			delete client_key_exchange_;
			client_key_exchange_ = 0;
			}
			break;
		case 20:
			// Clean up "finished"
			{
			delete finished_;
			finished_ = 0;
			}
			break;
		case 21:
			// Clean up "certificate_url"
			{
			}
			break;
		case 22:
			// Clean up "certificate_status"
			{
			delete certificate_status_;
			certificate_status_ = 0;
			}
			break;
		default:
			// Clean up "unknown_handshake"
			{
			delete unknown_handshake_;
			unknown_handshake_ = 0;
			}
			break;
		}
	}

int Handshake::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context, int t_byteorder)
	{
	// Checking out-of-bound for "Handshake:length"
	if ( (t_begin_of_data + 1) + (3) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Handshake:length",
			(1) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "msg_type"
	msg_type_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "length"
	length_ = new uint24();
	length_->Parse((t_begin_of_data + 1), t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "body"
	int t_body__size;
	t_body__size = to_int()(length());
	// Checking out-of-bound for "Handshake:body"
	if ( (t_begin_of_data + 4) + (t_body__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Handshake:body",
			(4) + (t_body__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 4) + t_body__size;
	body_case_index_ = msg_type();
	switch ( body_case_index() )
		{
		case 0:
			// Parse "hello_request"
			{
			hello_request_ = new HelloRequest(rec());
			hello_request_->Parse(0, 0, t_context);
			// Evaluate 'let' and 'withinput' fields
			}
			break;
		case 1:
			// Parse "client_hello"
			{
			client_hello_ = new ClientHello(rec());
			int t_client_hello__size;
			t_client_hello__size = client_hello_->Parse((t_begin_of_data + 4), t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			}
			break;
		case 2:
			// Parse "server_hello"
			{
			server_hello_ = new ServerHello(rec());
			int t_server_hello__size;
			t_server_hello__size = server_hello_->Parse((t_begin_of_data + 4), t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			}
			break;
		case 4:
			// Parse "session_ticket"
			{
			session_ticket_ = new SessionTicketHandshake(rec());
			int t_session_ticket__size;
			t_session_ticket__size = session_ticket_->Parse((t_begin_of_data + 4), t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			}
			break;
		case 11:
			// Parse "certificate"
			{
			certificate_ = new Certificate(rec());
			int t_certificate__size;
			t_certificate__size = certificate_->Parse((t_begin_of_data + 4), t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			}
			break;
		case 12:
			// Parse "server_key_exchange"
			{
			server_key_exchange_ = new ServerKeyExchange(rec());
			int t_server_key_exchange__size;
			t_server_key_exchange__size = server_key_exchange_->Parse((t_begin_of_data + 4), t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			}
			break;
		case 13:
			// Parse "certificate_request"
			{
			certificate_request_ = new CertificateRequest(rec());
			int t_certificate_request__size;
			t_certificate_request__size = certificate_request_->Parse((t_begin_of_data + 4), t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			}
			break;
		case 14:
			// Parse "server_hello_done"
			{
			server_hello_done_ = new ServerHelloDone(rec());
			server_hello_done_->Parse(0, 0, t_context);
			// Evaluate 'let' and 'withinput' fields
			}
			break;
		case 15:
			// Parse "certificate_verify"
			{
			certificate_verify_ = new CertificateVerify(rec());
			int t_certificate_verify__size;
			t_certificate_verify__size = certificate_verify_->Parse((t_begin_of_data + 4), t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			}
			break;
		case 16:
			// Parse "client_key_exchange"
			{
			client_key_exchange_ = new ClientKeyExchange(rec());
			int t_client_key_exchange__size;
			t_client_key_exchange__size = client_key_exchange_->Parse((t_begin_of_data + 4), t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			}
			break;
		case 20:
			// Parse "finished"
			{
			finished_ = new Finished(rec());
			int t_finished__size;
			t_finished__size = finished_->Parse((t_begin_of_data + 4), t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			}
			break;
		case 21:
			// Parse "certificate_url"
			{
			int t_certificate_url_string_length;
			t_certificate_url_string_length = (t_end_of_data) - ((t_begin_of_data + 4));
			int t_certificate_url__size;
			t_certificate_url__size = t_certificate_url_string_length;
			// check for negative sizes
			if ( t_certificate_url_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:693", t_certificate_url_string_length);
			certificate_url_.init((t_begin_of_data + 4), t_certificate_url_string_length);
			// Evaluate 'let' and 'withinput' fields
			}
			break;
		case 22:
			// Parse "certificate_status"
			{
			certificate_status_ = new CertificateStatus(rec());
			int t_certificate_status__size;
			t_certificate_status__size = certificate_status_->Parse((t_begin_of_data + 4), t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			}
			break;
		default:
			// Parse "unknown_handshake"
			{
			unknown_handshake_ = new UnknownHandshake(this, rec()->is_orig());
			int t_unknown_handshake__size;
			t_unknown_handshake__size = unknown_handshake_->Parse((t_begin_of_data + 4), t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_Handshake__size;
	const_byteptr const t_dataptr_after_body = (t_begin_of_data + 4) + (t_body__size);
	BINPAC_ASSERT(t_dataptr_after_body <= t_end_of_data);
	t_Handshake__size = t_dataptr_after_body - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_handshake(rec(), msg_type(), length());
	BINPAC_ASSERT(t_begin_of_data + (t_Handshake__size) <= t_end_of_data);
	return t_Handshake__size;
	}

UnknownRecord::UnknownRecord(SSLRecord * rec)
	{
	rec_ = rec;
	proc_ = 0;
	}

UnknownRecord::~UnknownRecord()
	{
	}

int UnknownRecord::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context)
	{
	// Parse "cont"
	int t_cont_string_length;
	t_cont_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_cont__size;
	t_cont__size = t_cont_string_length;
	// check for negative sizes
	if ( t_cont_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:705", t_cont_string_length);
	cont_.init(t_begin_of_data, t_cont_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_UnknownRecord__size;
	const_byteptr const t_dataptr_after_cont = t_begin_of_data + (t_cont__size);
	BINPAC_ASSERT(t_dataptr_after_cont <= t_end_of_data);
	t_UnknownRecord__size = t_dataptr_after_cont - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_unknown_record(rec());
	BINPAC_ASSERT(t_begin_of_data + (t_UnknownRecord__size) <= t_end_of_data);
	return t_UnknownRecord__size;
	}

CiphertextRecord::CiphertextRecord(SSLRecord * rec)
	{
	rec_ = rec;
	proc_ = 0;
	}

CiphertextRecord::~CiphertextRecord()
	{
	}

int CiphertextRecord::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextSSL * t_context)
	{
	// Parse "cont"
	int t_cont_string_length;
	t_cont_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_cont__size;
	t_cont__size = t_cont_string_length;
	// check for negative sizes
	if ( t_cont_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/ssl/ssl-protocol.pac:709", t_cont_string_length);
	cont_.init(t_begin_of_data, t_cont_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_CiphertextRecord__size;
	const_byteptr const t_dataptr_after_cont = t_begin_of_data + (t_cont__size);
	BINPAC_ASSERT(t_dataptr_after_cont <= t_end_of_data);
	t_CiphertextRecord__size = t_dataptr_after_cont - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->connection()->proc_ciphertext_record(rec());
	BINPAC_ASSERT(t_begin_of_data + (t_CiphertextRecord__size) <= t_end_of_data);
	return t_CiphertextRecord__size;
	}

SSLPDU::SSLPDU(bool is_orig)
	{
	records_ = 0;
	records__elem_ = 0;
	records__arraylength_ = 0;
	records__elem__it_ = 0;
	records__elem__it_ = -1;
	is_orig_ = is_orig;
	byteorder_ = bigendian;
	parsing_state_ = 0;
	parsing_state_ = 0;
	}

SSLPDU::~SSLPDU()
	{
	delete records__elem_;
	records__elem_ = 0;
	if ( records_ )
		{
		for ( int i = 0; i < (int) records_->size(); ++i )
			{
			SSLRecord * records__elem_ = (*records_)[i];
			delete records__elem_;
			records__elem_ = 0;
			}
		}
	delete records_;
	}

bool SSLPDU::ParseBuffer(flow_buffer_t t_flow_buffer, ContextSSL * t_context)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	switch ( parsing_state_ ) {
	case 0:
		// Parse "records"
		if ( ! records_ )
			{
			}
		parsing_state_ = 1;
	case 1:
		{
		bool t_records_parsing_complete;
		t_records_parsing_complete = false;
		if ( records__elem__it_ < 0 )
			{
			// Initialize only once
			records__elem__it_ = 0;
			records_ = new vector<SSLRecord *>;
			}
		for (; /* forever */; ++records__elem__it_)
			{
			if ( ! records__elem_ )
				{
				records__elem_ = new SSLRecord(is_orig());
				}
			bool t_records__elem_parsing_complete;
			t_records__elem_parsing_complete = false;
			while ( ! t_records__elem_parsing_complete && t_flow_buffer->ready() )
				{
				const_byteptr t_begin_of_data = t_flow_buffer->begin();
				const_byteptr t_end_of_data = t_flow_buffer->end();
				t_records__elem_parsing_complete = records__elem_->ParseBuffer(t_flow_buffer, t_context);
				if ( t_records__elem_parsing_complete )
					{
					// Evaluate 'let' and 'withinput' fields
					}
				}
			if ( ! t_records__elem_parsing_complete )
				goto need_more_data;
			delete records__elem_;
			records__elem_ = 0;
			}
	end_of_records: ;
		if ( t_records_parsing_complete )
			{
			// Evaluate 'let' and 'withinput' fields
			}
		if ( ! (t_records_parsing_complete) )
			goto need_more_data;
		}
		
		
		t_val_parsing_complete = true;
	}
	if ( t_val_parsing_complete )
		{
		// Evaluate 'let' and 'withinput' fields
		}
	BINPAC_ASSERT(t_val_parsing_complete);
	return t_val_parsing_complete;
	
need_more_data:
	BINPAC_ASSERT(!(t_val_parsing_complete));
	return false;
	}

SSL_Flow::SSL_Flow(SSL_Conn * connection, bool is_orig)
	{
	flow_buffer_ = 0;
	connection_ = connection;
	is_orig_ = is_orig;
	dataunit_ = 0;
	context_ = 0;
	flow_buffer_ = new FlowBuffer();
	}

SSL_Flow::~SSL_Flow()
	{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;
	delete flow_buffer_;
	flow_buffer_ = 0;
	}

void SSL_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		flow_buffer_->NewData(t_begin_of_data, t_end_of_data);
		while ( flow_buffer_->data_available() && 
			( !flow_buffer_->have_pending_request() || flow_buffer_->ready() ) )
			{
			if ( ! dataunit_ )
				{
				BINPAC_ASSERT(!context_);
				dataunit_ = new SSLPDU(is_orig());
				context_ = new ContextSSL(connection(), this, flow_buffer());
				}
			bool t_dataunit_parsing_complete;
			t_dataunit_parsing_complete = false;
			t_dataunit_parsing_complete = dataunit_->ParseBuffer(flow_buffer(), context_);
			if ( t_dataunit_parsing_complete )
				{
				// Evaluate 'let' and 'withinput' fields
				}
			if ( t_dataunit_parsing_complete )
				{
				// Clean up the flow unit after parsing
				delete dataunit_;
				dataunit_ = 0;
				delete context_;
				context_ = 0;
				}
			else
				{
				// Resume upon next input segment
				BINPAC_ASSERT(!flow_buffer()->ready());
				break;
				}
			}
		}
	catch ( binpac::Exception const &e )
		{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		flow_buffer_->DiscardData();
		throw;
		}
	}

void SSL_Flow::NewGap(int gap_length)
	{
	flow_buffer_->NewGap(gap_length);
	}
void SSL_Flow::FlowEOF()
	{
	flow_buffer_->set_eof();
	NewData(0, 0);
	}

string orig_label(bool is_orig)
		{
		return string(is_orig ? "originator" :"responder");
		}

	string handshake_type_label(int type)
		{
		switch ( type ) {
		case HELLO_REQUEST: return string("HELLO_REQUEST");
		case CLIENT_HELLO: return string("CLIENT_HELLO");
		case SERVER_HELLO: return string("SERVER_HELLO");
		case SESSION_TICKET: return string("SESSION_TICKET");
		case CERTIFICATE: return string("CERTIFICATE");
		case SERVER_KEY_EXCHANGE: return string("SERVER_KEY_EXCHANGE");
		case CERTIFICATE_REQUEST: return string("CERTIFICATE_REQUEST");
		case SERVER_HELLO_DONE: return string("SERVER_HELLO_DONE");
		case CERTIFICATE_VERIFY: return string("CERTIFICATE_VERIFY");
		case CLIENT_KEY_EXCHANGE: return string("CLIENT_KEY_EXCHANGE");
		case FINISHED: return string("FINISHED");
		case CERTIFICATE_URL: return string("CERTIFICATE_URL");
		case CERTIFICATE_STATUS: return string("CERTIFICATE_STATUS");
		default: return string(fmt("UNKNOWN (%d)", type));
		}
		}


StringVal * to_string_val(vector<uint8> * data)
	{

	char tmp[32];
	memset(tmp, 0, sizeof(tmp));

	// Just return an empty string if the string is longer than 32 bytes
	if ( data && data->size() <= 32 )
		{
		for ( unsigned int i = data->size(); i > 0; --i )
			tmp[i-1] = (*data)[i-1];
		}

	return new StringVal(32, tmp);
	
	}

bool version_ok(uint16 vers)
	{

	switch ( vers ) {
	case SSLv20:
	case SSLv30:
	case TLSv10:
	case TLSv11:
	case TLSv12:
		return true;

	default:
		return false;
	}
	
	}

} // namespace SSL
}  // namespace binpac

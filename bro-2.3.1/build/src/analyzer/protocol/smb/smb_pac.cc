// This file is automatically generated from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb.pac.


#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include "/home/benjamin/Bro/bro-2.3.1/build/src/analyzer/protocol/smb/smb_pac.h"

namespace binpac {






namespace SMB {
ContextSMB::ContextSMB()
	{
	}

ContextSMB::~ContextSMB()
	{
	}

const_bytestring extract_string(SMB_string * s)
	{

	int length = 0;

	char* buf;
	const char* sp;

	if( s->val_case_index() == 0 )
		{
		length = s->a()->size();
		buf = new char[ length ];

		for( int i = 0; i < length; i++)
			{
			unsigned char t = (*(s->a()))[i];
			buf[i] = t;
			}
		}
	else
		{
		length = s->u()->s()->size();
		buf = new char[ length ];

		for( int i = 0; i < length; i++)
			{
			unsigned short temp = (*(s->u()->s()))[i];
			buf[i] = temp & 0xff;
			}
		}

	return bytestring((uint8*) buf, length);
	
	}

TransactionType determine_transaction_type(int setup_count, SMB_string * name)
	{

	// This logic needs to be verified! the relationship between
	// setup_count and type is very unclear.
	if ( name == NULL )
		return SMB_UNKNOWN;

	if ( bytestring_caseprefix( extract_string(name),
			"\\PIPE\\LANMAN" ) )
		{
		return SMB_RAP;
		}
	else if ( bytestring_caseprefix( extract_string(name),
			"\\MAILSLOT\\LANMAN" ) )
		{
		return SMB_MAILSLOT_LANMAN;
		//return SMB_MAILSLOT_BROWSE;
		}
	else if ( bytestring_caseprefix( extract_string(name),
			"\\MAILSLOT\\NET\\NETLOGON" ) )
		{
		/* Don't really know what to do here, its got a Mailslot
		 * type but its a depricated packet format that handles
		 * old windows logon
		 */
		return SMB_UNKNOWN;
		}
	else if(setup_count == 2 ||
			bytestring_caseprefix( extract_string(name), "\\PIPE\\" ) )
		{
		return SMB_PIPE;
		}
	else if (setup_count == 3 ||
			bytestring_caseprefix( extract_string(name), "\\MAILSLOT\\" ) )
		{
		return SMB_MAILSLOT_BROWSE;
		}
	else
		return SMB_UNKNOWN;
	
	}

SMB_string * name_string(SMB_transaction * trans)
	{

	if( trans->trans_type() == 1 )
		return trans->name();
	else
		return NULL;
	
	}

SMB_dos_error::SMB_dos_error()
	{
	error_class_ = 0;
	reserved_ = 0;
	error_ = 0;
	}

SMB_dos_error::~SMB_dos_error()
	{
	}

int SMB_dos_error::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "SMB_dos_error"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_dos_error",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "error_class"
	error_class_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "reserved"
	reserved_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "error"
	error_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

SMB_error::SMB_error(int err_status_type)
	{
	val_case_index_ = -1;
	dos_error_ = 0;
	status_ = 0;
	err_status_type_ = err_status_type;
	}

SMB_error::~SMB_error()
	{
	switch ( val_case_index() )
		{
		case 0:
			// Clean up "dos_error"
			{
			delete dos_error_;
			dos_error_ = 0;
			}
			break;
		case 1:
			// Clean up "status"
			{
			}
			break;
		}
	}

int SMB_error::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "SMB_error:val"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_error:val",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	val_case_index_ = err_status_type();
	switch ( val_case_index() )
		{
		case 0:
			// Parse "dos_error"
			{
			dos_error_ = new SMB_dos_error();
			dos_error_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			}
			break;
		case 1:
			// Parse "status"
			{
			status_ = FixByteOrder(t_byteorder, *((int32 const *) (t_begin_of_data)));
			// Evaluate 'let' and 'withinput' fields
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("SMB_error", val_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

SMB_header::SMB_header()
	{
	command_ = 0;
	status_ = 0;
	flags_ = 0;
	flags2_ = 0;
	tid_ = 0;
	pid_ = 0;
	uid_ = 0;
	mid_ = 0;
	byteorder_ = littleendian;
	err_status_type_ = 0;
	unicode_ = 0;
	}

SMB_header::~SMB_header()
	{
	protocol_.free();
	delete status_;
	status_ = 0;
	}

int SMB_header::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "protocol"
	// Checking out-of-bound for "SMB_header:protocol"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_header:protocol",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_begin_of_data + 4;
	int t_protocol_string_length;
	t_protocol_string_length = 4;
	int t_protocol__size;
	t_protocol__size = t_protocol_string_length;
	protocol_.init(t_begin_of_data, t_protocol_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_protocol = t_begin_of_data + (4);
	BINPAC_ASSERT(t_dataptr_after_protocol <= t_end_of_data);
	// Checking out-of-bound for "SMB_header:mid"
	if ( (t_dataptr_after_protocol + 26) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_header:mid",
			(((t_dataptr_after_protocol + 26) - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "command"
	command_ = *((uint8 const *) (t_dataptr_after_protocol));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "status"
	// Parse "flags2"
	flags2_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_dataptr_after_protocol + 6))));
	// Evaluate 'let' and 'withinput' fields
	err_status_type_ =  ( flags2() >> 14 )  & 1;
	status_ = new SMB_error(err_status_type());
	status_->Parse((t_dataptr_after_protocol + 1), t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "flags"
	flags_ = *((uint8 const *) ((t_dataptr_after_protocol + 5)));
	// Evaluate 'let' and 'withinput' fields
	
	
	
	// Parse "tid"
	tid_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_dataptr_after_protocol + 20))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "pid"
	pid_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_dataptr_after_protocol + 22))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "uid"
	uid_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_dataptr_after_protocol + 24))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "mid"
	mid_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_dataptr_after_protocol + 26))));
	// Evaluate 'let' and 'withinput' fields
	
	int t_SMB_header__size;
	t_SMB_header__size = (t_dataptr_after_protocol + 28) - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	unicode_ =  ( flags2() >> 15 )  & 1;
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_header__size) <= t_end_of_data);
	return t_SMB_header__size;
	}

int const smb_header_length = 32;
SMB_body::SMB_body()
	{
	word_count_ = 0;
	parameter_words_ = 0;
	parameter_words__elem_ = 0;
	byte_count_ = 0;
	byteorder_ = littleendian;
	body_length_ = 0;
	}

SMB_body::~SMB_body()
	{
	delete parameter_words_;
	}

int SMB_body::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_body:word_count"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_body:word_count",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "word_count"
	word_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "parameter_words"
	int t_parameter_words__arraylength;
	t_parameter_words__arraylength = 0;
	t_parameter_words__arraylength = word_count();
	if ( t_begin_of_data + t_parameter_words__arraylength > t_end_of_data + 1 )
		{
		t_parameter_words__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_parameter_words__arraylength < 0 )
		{
		t_parameter_words__arraylength = 0;
		}
	parameter_words__elem_ = 0;
	int t_parameter_words__elem__it;
	t_parameter_words__elem__it = 0;
	int t_parameter_words__size;
	parameter_words_ = new vector<uint16>;
	parameter_words_->reserve(t_parameter_words__arraylength);
	const_byteptr t_parameter_words__elem__dataptr = (t_begin_of_data + 1);
	for (; t_parameter_words__elem__it < t_parameter_words__arraylength; ++t_parameter_words__elem__it)
		{
		// Check &until(parameter_words__elem__dataptr >= end_of_data)
		if ( t_parameter_words__elem__dataptr >= t_end_of_data )
			{
			goto end_of_parameter_words;
			}
		// Checking out-of-bound for "SMB_body:parameter_words__elem"
		if ( t_parameter_words__elem__dataptr + (2) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("SMB_body:parameter_words__elem",
				((t_parameter_words__elem__dataptr - t_begin_of_data)) + (2), 
				(t_end_of_data) - (t_begin_of_data));
			}
		parameter_words__elem_ = FixByteOrder(byteorder(), *((uint16 const *) (t_parameter_words__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		parameter_words_->push_back(parameter_words__elem_);
		t_parameter_words__elem__dataptr += 2;
		BINPAC_ASSERT(t_parameter_words__elem__dataptr <= t_end_of_data);
		}
end_of_parameter_words: ;
	t_parameter_words__size = t_parameter_words__elem__dataptr - ((t_begin_of_data + 1));
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_parameter_words = (t_begin_of_data + 1) + (t_parameter_words__size);
	BINPAC_ASSERT(t_dataptr_after_parameter_words <= t_end_of_data);
	// Checking out-of-bound for "SMB_body:byte_count"
	if ( t_dataptr_after_parameter_words + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_body:byte_count",
			((t_dataptr_after_parameter_words - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "byte_count"
	byte_count_ = FixByteOrder(byteorder(), *((uint16 const *) (t_dataptr_after_parameter_words)));
	// Evaluate 'let' and 'withinput' fields
	
	int t_SMB_body__size;
	t_SMB_body__size = (t_dataptr_after_parameter_words + 2) - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	body_length_ = 1 + word_count() * 2 + 2 + byte_count();
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_body__size) <= t_end_of_data);
	return t_SMB_body__size;
	}

SMB_ascii_string::SMB_ascii_string()
	{
	val_ = 0;
	val__elem_ = 0;
	}

SMB_ascii_string::~SMB_ascii_string()
	{
	delete val_;
	}

int SMB_ascii_string::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	int t_val__arraylength;
	t_val__arraylength = 0;
	val__elem_ = 0;
	int t_val__elem__it;
	t_val__elem__it = 0;
	int t_val__size;
	val_ = new vector<uint8>;
	const_byteptr t_val__elem__dataptr = t_begin_of_data;
	for (; /* forever */; ++t_val__elem__it)
		{
		// Check &until(val__elem__dataptr >= end_of_data)
		if ( t_val__elem__dataptr >= t_end_of_data )
			{
			goto end_of_val;
			}
		// Checking out-of-bound for "SMB_ascii_string:val__elem"
		if ( t_val__elem__dataptr + (1) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("SMB_ascii_string:val__elem",
				((t_val__elem__dataptr - t_begin_of_data)) + (1), 
				(t_end_of_data) - (t_begin_of_data));
			}
		val__elem_ = *((uint8 const *) (t_val__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		val_->push_back(val__elem_);
		t_val__elem__dataptr += 1;
		BINPAC_ASSERT(t_val__elem__dataptr <= t_end_of_data);
		// Check &until( ( $element == ((int) 0) ) )
		if (  ( val__elem_ == 0 )  )
			{
			goto end_of_val;
			}
		}
end_of_val: ;
	t_val__size = t_val__elem__dataptr - (t_begin_of_data);
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

SMB_unicode_string::SMB_unicode_string(int offset)
	{
	s_ = 0;
	s__elem_ = 0;
	offset_ = offset;
	}

SMB_unicode_string::~SMB_unicode_string()
	{
	delete s_;
	}

int SMB_unicode_string::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	
	const_byteptr const t_dataptr_after_pad = t_begin_of_data + (offset() & 1);
	// Parse "s"
	int t_s__arraylength;
	t_s__arraylength = 0;
	s__elem_ = 0;
	int t_s__elem__it;
	t_s__elem__it = 0;
	int t_s__size;
	s_ = new vector<uint16>;
	const_byteptr t_s__elem__dataptr = t_dataptr_after_pad;
	for (; /* forever */; ++t_s__elem__it)
		{
		// Check &until(s__elem__dataptr >= end_of_data)
		if ( t_s__elem__dataptr >= t_end_of_data )
			{
			goto end_of_s;
			}
		// Checking out-of-bound for "SMB_unicode_string:s__elem"
		if ( t_s__elem__dataptr + (2) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("SMB_unicode_string:s__elem",
				((t_s__elem__dataptr - t_begin_of_data)) + (2), 
				(t_end_of_data) - (t_begin_of_data));
			}
		s__elem_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_s__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		s_->push_back(s__elem_);
		t_s__elem__dataptr += 2;
		BINPAC_ASSERT(t_s__elem__dataptr <= t_end_of_data);
		// Check &until( ( $element == ((int) 0) ) )
		if (  ( s__elem_ == 0 )  )
			{
			goto end_of_s;
			}
		}
end_of_s: ;
	t_s__size = t_s__elem__dataptr - (t_dataptr_after_pad);
	// Evaluate 'let' and 'withinput' fields
	
	int t_SMB_unicode_string__size;
	const_byteptr const t_dataptr_after_s = t_dataptr_after_pad + (t_s__size);
	BINPAC_ASSERT(t_dataptr_after_s <= t_end_of_data);
	t_SMB_unicode_string__size = t_dataptr_after_s - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_unicode_string__size) <= t_end_of_data);
	return t_SMB_unicode_string__size;
	}

SMB_string::SMB_string(bool unicode, int offset)
	{
	val_case_index_ = -1;
	u_ = 0;
	a_ = 0;
	unicode_ = unicode;
	offset_ = offset;
	}

SMB_string::~SMB_string()
	{
	switch ( val_case_index() )
		{
		case 1:
			// Clean up "u"
			{
			delete u_;
			u_ = 0;
			}
			break;
		case 0:
			// Clean up "a"
			{
			delete a_;
			a_ = 0;
			}
			break;
		}
	}

int SMB_string::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	int t_val__size;
	val_case_index_ = unicode();
	switch ( val_case_index() )
		{
		case 1:
			// Parse "u"
			{
			u_ = new SMB_unicode_string(offset());
			int t_u__size;
			t_u__size = u_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_u__size;
			}
			break;
		case 0:
			// Parse "a"
			{
			a_ = new SMB_ascii_string();
			int t_a__size;
			t_a__size = a_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_a__size;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("SMB_string", val_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

SMB_time::SMB_time()
	{
	two_seconds_ = 0;
	minutes_ = 0;
	hours_ = 0;
	byteorder_ = littleendian;
	}

SMB_time::~SMB_time()
	{
	}

int SMB_time::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_time"
	if ( t_begin_of_data + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_time",
			(0) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "two_seconds"
	two_seconds_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "minutes"
	minutes_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "hours"
	hours_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (6) <= t_end_of_data);
	return 6;
	}

SMB_date::SMB_date()
	{
	day_ = 0;
	month_ = 0;
	year_ = 0;
	byteorder_ = littleendian;
	}

SMB_date::~SMB_date()
	{
	}

int SMB_date::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_date"
	if ( t_begin_of_data + (6) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_date",
			(0) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "day"
	day_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "month"
	month_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "year"
	year_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (6) <= t_end_of_data);
	return 6;
	}

SMB_andx::SMB_andx()
	{
	command_ = 0;
	reserved_ = 0;
	offset_ = 0;
	}

SMB_andx::~SMB_andx()
	{
	}

int SMB_andx::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "SMB_andx"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_andx",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "command"
	command_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "reserved"
	reserved_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "offset"
	offset_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

SMB_generic_andx::SMB_generic_andx()
	{
	word_count_ = 0;
	andx_u_case_index_ = -1;
	andx_ = 0;
	byteorder_ = littleendian;
	}

SMB_generic_andx::~SMB_generic_andx()
	{
	switch ( andx_u_case_index() )
		{
		case 0:
			// Clean up "null"
			{
			}
			break;
		default:
			// Clean up "andx"
			{
			Unref(andx_);
			andx_ = 0;
			}
			break;
		}
	data_.free();
	}

int SMB_generic_andx::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_generic_andx:word_count"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_generic_andx:word_count",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "word_count"
	word_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "andx_u"
	int t_andx_u__size;
	andx_u_case_index_ = word_count();
	switch ( andx_u_case_index() )
		{
		case 0:
			// Parse "null"
			{
			// Evaluate 'let' and 'withinput' fields
			t_andx_u__size = 0;
			}
			break;
		default:
			// Parse "andx"
			{
			andx_ = new SMB_andx();
			andx_->Parse((t_begin_of_data + 1), t_end_of_data, byteorder());
			// Evaluate 'let' and 'withinput' fields
			t_andx_u__size = 4;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_andx_u = (t_begin_of_data + 1) + (t_andx_u__size);
	BINPAC_ASSERT(t_dataptr_after_andx_u <= t_end_of_data);
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - (t_dataptr_after_andx_u);
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-protocol.pac:174", t_data_string_length);
	data_.init(t_dataptr_after_andx_u, t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_SMB_generic_andx__size;
	const_byteptr const t_dataptr_after_data = t_dataptr_after_andx_u + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_SMB_generic_andx__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_generic_andx__size) <= t_end_of_data);
	return t_SMB_generic_andx__size;
	}

SMB_dialect::SMB_dialect()
	{
	bufferformat_ = 0;
	dialectname_ = 0;
	}

SMB_dialect::~SMB_dialect()
	{
	delete dialectname_;
	dialectname_ = 0;
	}

int SMB_dialect::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_dialect:bufferformat"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_dialect:bufferformat",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "bufferformat"
	bufferformat_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "dialectname"
	dialectname_ = new SMB_ascii_string();
	int t_dialectname__size;
	t_dialectname__size = dialectname_->Parse((t_begin_of_data + 1), t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_SMB_dialect__size;
	const_byteptr const t_dataptr_after_dialectname = (t_begin_of_data + 1) + (t_dialectname__size);
	BINPAC_ASSERT(t_dataptr_after_dialectname <= t_end_of_data);
	t_SMB_dialect__size = t_dataptr_after_dialectname - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_dialect__size) <= t_end_of_data);
	return t_SMB_dialect__size;
	}

SMB_negotiate::SMB_negotiate()
	{
	word_count_ = 0;
	byte_count_ = 0;
	dialects_ = 0;
	dialects__elem_ = 0;
	byteorder_ = littleendian;
	}

SMB_negotiate::~SMB_negotiate()
	{
	delete dialects__elem_;
	dialects__elem_ = 0;
	if ( dialects() )
		{
		for ( int i = 0; i < (int) dialects()->size(); ++i )
			{
			SMB_dialect * dialects__elem_ = (*dialects_)[i];
			delete dialects__elem_;
			dialects__elem_ = 0;
			}
		}
	delete dialects_;
	}

int SMB_negotiate::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_negotiate:byte_count"
	if ( (t_begin_of_data + 1) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_negotiate:byte_count",
			(1) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "word_count"
	word_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte_count"
	byte_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "dialects"
	int t_dialects__size;
	t_dialects__size = byte_count();
	// Checking out-of-bound for "SMB_negotiate:dialects"
	if ( (t_begin_of_data + 3) + (t_dialects__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_negotiate:dialects",
			(3) + (t_dialects__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 3) + t_dialects__size;
	int t_dialects__arraylength;
	t_dialects__arraylength = 0;
	dialects__elem_ = 0;
	int t_dialects__elem__it;
	t_dialects__elem__it = 0;
	dialects_ = new vector<SMB_dialect *>;
	const_byteptr t_dialects__elem__dataptr = (t_begin_of_data + 3);
	for (; /* forever */; ++t_dialects__elem__it)
		{
		// Check &until(dialects__elem__dataptr >= end_of_data)
		if ( t_dialects__elem__dataptr >= t_end_of_data )
			{
			dialects__elem_ = 0;
			goto end_of_dialects;
			}
		dialects__elem_ = new SMB_dialect();
		int t_dialects__elem__size;
		t_dialects__elem__size = dialects__elem_->Parse(t_dialects__elem__dataptr, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		dialects_->push_back(dialects__elem_);
		t_dialects__elem__dataptr += t_dialects__elem__size;
		BINPAC_ASSERT(t_dialects__elem__dataptr <= t_end_of_data);
		dialects__elem_ = 0;
		}
end_of_dialects: ;
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_SMB_negotiate__size;
	const_byteptr const t_dataptr_after_dialects = (t_begin_of_data + 3) + (t_dialects__size);
	BINPAC_ASSERT(t_dataptr_after_dialects <= t_end_of_data);
	t_SMB_negotiate__size = t_dataptr_after_dialects - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_negotiate__size) <= t_end_of_data);
	return t_SMB_negotiate__size;
	}

SMB_negotiate_response::SMB_negotiate_response()
	{
	word_count_ = 0;
	dialect_index_ = 0;
	byte_count_ = 0;
	byteorder_ = littleendian;
	}

SMB_negotiate_response::~SMB_negotiate_response()
	{
	}

int SMB_negotiate_response::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_negotiate_response"
	if ( t_begin_of_data + (5) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_negotiate_response",
			(0) + (5), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "word_count"
	word_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "dialect_index"
	dialect_index_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte_count"
	byte_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 3))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (5) <= t_end_of_data);
	return 5;
	}

SMB_negotiate_response_long::SMB_negotiate_response_long(bool unicode)
	{
	word_count_ = 0;
	dialect_index_ = 0;
	security_mode_ = 0;
	max_buffer_size_ = 0;
	max_mpx_count_ = 0;
	max_number_vcs_ = 0;
	raw_mode_ = 0;
	session_key_ = 0;
	server_time_ = 0;
	server_date_ = 0;
	server_tz_ = 0;
	enc_key_len_ = 0;
	reserved_ = 0;
	byte_count_ = 0;
	encryption_key_ = 0;
	encryption_key__elem_ = 0;
	primary_domain_ = 0;
	unicode_ = unicode;
	byteorder_ = littleendian;
	}

SMB_negotiate_response_long::~SMB_negotiate_response_long()
	{
	delete server_time_;
	server_time_ = 0;
	delete server_date_;
	server_date_ = 0;
	delete encryption_key_;
	delete primary_domain_;
	primary_domain_ = 0;
	}

int SMB_negotiate_response_long::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_negotiate_response_long:byte_count"
	if ( (t_begin_of_data + 35) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_negotiate_response_long:byte_count",
			(35) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "word_count"
	word_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "dialect_index"
	dialect_index_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "security_mode"
	security_mode_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 3))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "max_buffer_size"
	max_buffer_size_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 5))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "max_mpx_count"
	max_mpx_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 7))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "max_number_vcs"
	max_number_vcs_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 9))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "raw_mode"
	raw_mode_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 11))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "session_key"
	session_key_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 13))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "server_time"
	server_time_ = new SMB_time();
	server_time_->Parse((t_begin_of_data + 17), t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "server_date"
	server_date_ = new SMB_date();
	server_date_->Parse((t_begin_of_data + 23), t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "server_tz"
	server_tz_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 29))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "enc_key_len"
	enc_key_len_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 31))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "reserved"
	reserved_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 33))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte_count"
	byte_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 35))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "encryption_key"
	int t_encryption_key__arraylength;
	t_encryption_key__arraylength = 0;
	t_encryption_key__arraylength = enc_key_len();
	if ( t_begin_of_data + t_encryption_key__arraylength > t_end_of_data + 1 )
		{
		t_encryption_key__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_encryption_key__arraylength < 0 )
		{
		t_encryption_key__arraylength = 0;
		}
	encryption_key__elem_ = 0;
	int t_encryption_key__elem__it;
	t_encryption_key__elem__it = 0;
	int t_encryption_key__size;
	encryption_key_ = new vector<uint8>;
	encryption_key_->reserve(t_encryption_key__arraylength);
	const_byteptr t_encryption_key__elem__dataptr = (t_begin_of_data + 37);
	for (; t_encryption_key__elem__it < t_encryption_key__arraylength; ++t_encryption_key__elem__it)
		{
		// Check &until(encryption_key__elem__dataptr >= end_of_data)
		if ( t_encryption_key__elem__dataptr >= t_end_of_data )
			{
			goto end_of_encryption_key;
			}
		// Checking out-of-bound for "SMB_negotiate_response_long:encryption_key__elem"
		if ( t_encryption_key__elem__dataptr + (1) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("SMB_negotiate_response_long:encryption_key__elem",
				((t_encryption_key__elem__dataptr - t_begin_of_data)) + (1), 
				(t_end_of_data) - (t_begin_of_data));
			}
		encryption_key__elem_ = *((uint8 const *) (t_encryption_key__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		encryption_key_->push_back(encryption_key__elem_);
		t_encryption_key__elem__dataptr += 1;
		BINPAC_ASSERT(t_encryption_key__elem__dataptr <= t_end_of_data);
		}
end_of_encryption_key: ;
	t_encryption_key__size = t_encryption_key__elem__dataptr - ((t_begin_of_data + 37));
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_encryption_key = (t_begin_of_data + 37) + (t_encryption_key__size);
	BINPAC_ASSERT(t_dataptr_after_encryption_key <= t_end_of_data);
	// Parse "primary_domain"
	primary_domain_ = new SMB_string(unicode(), (t_dataptr_after_encryption_key - t_begin_of_data));
	int t_primary_domain__size;
	t_primary_domain__size = primary_domain_->Parse(t_dataptr_after_encryption_key, t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	int t_SMB_negotiate_response_long__size;
	const_byteptr const t_dataptr_after_primary_domain = t_dataptr_after_encryption_key + (t_primary_domain__size);
	BINPAC_ASSERT(t_dataptr_after_primary_domain <= t_end_of_data);
	t_SMB_negotiate_response_long__size = t_dataptr_after_primary_domain - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_negotiate_response_long__size) <= t_end_of_data);
	return t_SMB_negotiate_response_long__size;
	}

SMB_setup_andx_basic::SMB_setup_andx_basic(bool unicode)
	{
	word_count_ = 0;
	andx_ = 0;
	max_buffer_size_ = 0;
	max_mpx_count_ = 0;
	vc_number_ = 0;
	session_key_ = 0;
	passwd_length_ = 0;
	reserved_ = 0;
	byte_count_ = 0;
	password_ = 0;
	password__elem_ = 0;
	name_ = 0;
	domain_ = 0;
	native_os_ = 0;
	native_lanman_ = 0;
	unicode_ = unicode;
	byteorder_ = littleendian;
	}

SMB_setup_andx_basic::~SMB_setup_andx_basic()
	{
	Unref(andx_);
	andx_ = 0;
	delete password_;
	delete name_;
	name_ = 0;
	delete domain_;
	domain_ = 0;
	delete native_os_;
	native_os_ = 0;
	delete native_lanman_;
	native_lanman_ = 0;
	}

int SMB_setup_andx_basic::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_setup_andx_basic:byte_count"
	if ( (t_begin_of_data + 20) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_setup_andx_basic:byte_count",
			(20) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "word_count"
	word_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "andx"
	andx_ = new SMB_andx();
	andx_->Parse((t_begin_of_data + 1), t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "max_buffer_size"
	max_buffer_size_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 5))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "max_mpx_count"
	max_mpx_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 7))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "vc_number"
	vc_number_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 9))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "session_key"
	session_key_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 11))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "passwd_length"
	passwd_length_ = *((uint8 const *) ((t_begin_of_data + 15)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "reserved"
	reserved_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 16))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte_count"
	byte_count_ = *((uint8 const *) ((t_begin_of_data + 20)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "password"
	int t_password__arraylength;
	t_password__arraylength = 0;
	t_password__arraylength = passwd_length();
	if ( t_begin_of_data + t_password__arraylength > t_end_of_data + 1 )
		{
		t_password__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_password__arraylength < 0 )
		{
		t_password__arraylength = 0;
		}
	password__elem_ = 0;
	int t_password__elem__it;
	t_password__elem__it = 0;
	int t_password__size;
	password_ = new vector<uint8>;
	password_->reserve(t_password__arraylength);
	const_byteptr t_password__elem__dataptr = (t_begin_of_data + 21);
	for (; t_password__elem__it < t_password__arraylength; ++t_password__elem__it)
		{
		// Check &until(password__elem__dataptr >= end_of_data)
		if ( t_password__elem__dataptr >= t_end_of_data )
			{
			goto end_of_password;
			}
		// Checking out-of-bound for "SMB_setup_andx_basic:password__elem"
		if ( t_password__elem__dataptr + (1) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("SMB_setup_andx_basic:password__elem",
				((t_password__elem__dataptr - t_begin_of_data)) + (1), 
				(t_end_of_data) - (t_begin_of_data));
			}
		password__elem_ = *((uint8 const *) (t_password__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		password_->push_back(password__elem_);
		t_password__elem__dataptr += 1;
		BINPAC_ASSERT(t_password__elem__dataptr <= t_end_of_data);
		}
end_of_password: ;
	t_password__size = t_password__elem__dataptr - ((t_begin_of_data + 21));
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_password = (t_begin_of_data + 21) + (t_password__size);
	BINPAC_ASSERT(t_dataptr_after_password <= t_end_of_data);
	// Parse "name"
	name_ = new SMB_string(unicode(), (t_dataptr_after_password - t_begin_of_data));
	int t_name__size;
	t_name__size = name_->Parse(t_dataptr_after_password, t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_name = t_dataptr_after_password + (t_name__size);
	BINPAC_ASSERT(t_dataptr_after_name <= t_end_of_data);
	// Parse "domain"
	domain_ = new SMB_string(unicode(), (t_dataptr_after_name - t_begin_of_data));
	int t_domain__size;
	t_domain__size = domain_->Parse(t_dataptr_after_name, t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_domain = t_dataptr_after_name + (t_domain__size);
	BINPAC_ASSERT(t_dataptr_after_domain <= t_end_of_data);
	// Parse "native_os"
	native_os_ = new SMB_string(unicode(), (t_dataptr_after_domain - t_begin_of_data));
	int t_native_os__size;
	t_native_os__size = native_os_->Parse(t_dataptr_after_domain, t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_native_os = t_dataptr_after_domain + (t_native_os__size);
	BINPAC_ASSERT(t_dataptr_after_native_os <= t_end_of_data);
	// Parse "native_lanman"
	native_lanman_ = new SMB_string(unicode(), (t_dataptr_after_native_os - t_begin_of_data));
	int t_native_lanman__size;
	t_native_lanman__size = native_lanman_->Parse(t_dataptr_after_native_os, t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	int t_SMB_setup_andx_basic__size;
	const_byteptr const t_dataptr_after_native_lanman = t_dataptr_after_native_os + (t_native_lanman__size);
	BINPAC_ASSERT(t_dataptr_after_native_lanman <= t_end_of_data);
	t_SMB_setup_andx_basic__size = t_dataptr_after_native_lanman - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_setup_andx_basic__size) <= t_end_of_data);
	return t_SMB_setup_andx_basic__size;
	}

SMB_setup_andx_basic_response::SMB_setup_andx_basic_response(bool unicode)
	{
	word_count_ = 0;
	andx_ = 0;
	action_ = 0;
	byte_count_ = 0;
	native_os_ = 0;
	native_lanman_ = 0;
	primary_domain_ = 0;
	unicode_ = unicode;
	byteorder_ = littleendian;
	}

SMB_setup_andx_basic_response::~SMB_setup_andx_basic_response()
	{
	Unref(andx_);
	andx_ = 0;
	delete native_os_;
	native_os_ = 0;
	delete native_lanman_;
	native_lanman_ = 0;
	delete primary_domain_;
	primary_domain_ = 0;
	}

int SMB_setup_andx_basic_response::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_setup_andx_basic_response:byte_count"
	if ( (t_begin_of_data + 6) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_setup_andx_basic_response:byte_count",
			(6) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "word_count"
	word_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "andx"
	andx_ = new SMB_andx();
	andx_->Parse((t_begin_of_data + 1), t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "action"
	action_ = *((uint8 const *) ((t_begin_of_data + 5)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte_count"
	byte_count_ = *((uint8 const *) ((t_begin_of_data + 6)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "native_os"
	native_os_ = new SMB_string(unicode(), 7);
	int t_native_os__size;
	t_native_os__size = native_os_->Parse((t_begin_of_data + 7), t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_native_os = (t_begin_of_data + 7) + (t_native_os__size);
	BINPAC_ASSERT(t_dataptr_after_native_os <= t_end_of_data);
	// Parse "native_lanman"
	native_lanman_ = new SMB_string(unicode(), (t_dataptr_after_native_os - t_begin_of_data));
	int t_native_lanman__size;
	t_native_lanman__size = native_lanman_->Parse(t_dataptr_after_native_os, t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_native_lanman = t_dataptr_after_native_os + (t_native_lanman__size);
	BINPAC_ASSERT(t_dataptr_after_native_lanman <= t_end_of_data);
	// Parse "primary_domain"
	primary_domain_ = new SMB_string(unicode(), (t_dataptr_after_native_lanman - t_begin_of_data));
	int t_primary_domain__size;
	t_primary_domain__size = primary_domain_->Parse(t_dataptr_after_native_lanman, t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	int t_SMB_setup_andx_basic_response__size;
	const_byteptr const t_dataptr_after_primary_domain = t_dataptr_after_native_lanman + (t_primary_domain__size);
	BINPAC_ASSERT(t_dataptr_after_primary_domain <= t_end_of_data);
	t_SMB_setup_andx_basic_response__size = t_dataptr_after_primary_domain - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_setup_andx_basic_response__size) <= t_end_of_data);
	return t_SMB_setup_andx_basic_response__size;
	}

SMB_setup_andx_ext::SMB_setup_andx_ext(bool unicode)
	{
	word_count_ = 0;
	andx_ = 0;
	max_buffer_size_ = 0;
	max_mpx_count_ = 0;
	vc_number_ = 0;
	session_key_ = 0;
	security_length_ = 0;
	reserved_ = 0;
	capabilities_ = 0;
	byte_count_ = 0;
	security_blob_ = 0;
	security_blob__elem_ = 0;
	native_os_ = 0;
	native_lanman_ = 0;
	unicode_ = unicode;
	byteorder_ = littleendian;
	}

SMB_setup_andx_ext::~SMB_setup_andx_ext()
	{
	Unref(andx_);
	andx_ = 0;
	delete security_blob_;
	delete native_os_;
	native_os_ = 0;
	delete native_lanman_;
	native_lanman_ = 0;
	}

int SMB_setup_andx_ext::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_setup_andx_ext:byte_count"
	if ( (t_begin_of_data + 24) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_setup_andx_ext:byte_count",
			(24) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "word_count"
	word_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "andx"
	andx_ = new SMB_andx();
	andx_->Parse((t_begin_of_data + 1), t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "max_buffer_size"
	max_buffer_size_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 5))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "max_mpx_count"
	max_mpx_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 7))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "vc_number"
	vc_number_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 9))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "session_key"
	session_key_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 11))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "security_length"
	security_length_ = *((uint8 const *) ((t_begin_of_data + 15)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "reserved"
	reserved_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 16))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "capabilities"
	capabilities_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 20))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte_count"
	byte_count_ = *((uint8 const *) ((t_begin_of_data + 24)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "security_blob"
	int t_security_blob__arraylength;
	t_security_blob__arraylength = 0;
	t_security_blob__arraylength = security_length();
	if ( t_begin_of_data + t_security_blob__arraylength > t_end_of_data + 1 )
		{
		t_security_blob__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_security_blob__arraylength < 0 )
		{
		t_security_blob__arraylength = 0;
		}
	security_blob__elem_ = 0;
	int t_security_blob__elem__it;
	t_security_blob__elem__it = 0;
	int t_security_blob__size;
	security_blob_ = new vector<uint8>;
	security_blob_->reserve(t_security_blob__arraylength);
	const_byteptr t_security_blob__elem__dataptr = (t_begin_of_data + 25);
	for (; t_security_blob__elem__it < t_security_blob__arraylength; ++t_security_blob__elem__it)
		{
		// Check &until(security_blob__elem__dataptr >= end_of_data)
		if ( t_security_blob__elem__dataptr >= t_end_of_data )
			{
			goto end_of_security_blob;
			}
		// Checking out-of-bound for "SMB_setup_andx_ext:security_blob__elem"
		if ( t_security_blob__elem__dataptr + (1) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("SMB_setup_andx_ext:security_blob__elem",
				((t_security_blob__elem__dataptr - t_begin_of_data)) + (1), 
				(t_end_of_data) - (t_begin_of_data));
			}
		security_blob__elem_ = *((uint8 const *) (t_security_blob__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		security_blob_->push_back(security_blob__elem_);
		t_security_blob__elem__dataptr += 1;
		BINPAC_ASSERT(t_security_blob__elem__dataptr <= t_end_of_data);
		}
end_of_security_blob: ;
	t_security_blob__size = t_security_blob__elem__dataptr - ((t_begin_of_data + 25));
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_security_blob = (t_begin_of_data + 25) + (t_security_blob__size);
	BINPAC_ASSERT(t_dataptr_after_security_blob <= t_end_of_data);
	// Parse "native_os"
	native_os_ = new SMB_string(unicode(), (t_dataptr_after_security_blob - t_begin_of_data));
	int t_native_os__size;
	t_native_os__size = native_os_->Parse(t_dataptr_after_security_blob, t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_native_os = t_dataptr_after_security_blob + (t_native_os__size);
	BINPAC_ASSERT(t_dataptr_after_native_os <= t_end_of_data);
	// Parse "native_lanman"
	native_lanman_ = new SMB_string(unicode(), (t_dataptr_after_native_os - t_begin_of_data));
	int t_native_lanman__size;
	t_native_lanman__size = native_lanman_->Parse(t_dataptr_after_native_os, t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	int t_SMB_setup_andx_ext__size;
	const_byteptr const t_dataptr_after_native_lanman = t_dataptr_after_native_os + (t_native_lanman__size);
	BINPAC_ASSERT(t_dataptr_after_native_lanman <= t_end_of_data);
	t_SMB_setup_andx_ext__size = t_dataptr_after_native_lanman - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_setup_andx_ext__size) <= t_end_of_data);
	return t_SMB_setup_andx_ext__size;
	}

SMB_setup_andx_ext_response::SMB_setup_andx_ext_response(bool unicode)
	{
	word_count_ = 0;
	andx_ = 0;
	action_ = 0;
	security_length_ = 0;
	byte_count_ = 0;
	security_blob_ = 0;
	security_blob__elem_ = 0;
	native_os_ = 0;
	native_lanman_ = 0;
	primary_domain_ = 0;
	unicode_ = unicode;
	byteorder_ = littleendian;
	}

SMB_setup_andx_ext_response::~SMB_setup_andx_ext_response()
	{
	Unref(andx_);
	andx_ = 0;
	delete security_blob_;
	delete native_os_;
	native_os_ = 0;
	delete native_lanman_;
	native_lanman_ = 0;
	delete primary_domain_;
	primary_domain_ = 0;
	}

int SMB_setup_andx_ext_response::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_setup_andx_ext_response:byte_count"
	if ( (t_begin_of_data + 7) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_setup_andx_ext_response:byte_count",
			(7) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "word_count"
	word_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "andx"
	andx_ = new SMB_andx();
	andx_->Parse((t_begin_of_data + 1), t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "action"
	action_ = *((uint8 const *) ((t_begin_of_data + 5)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "security_length"
	security_length_ = *((uint8 const *) ((t_begin_of_data + 6)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte_count"
	byte_count_ = *((uint8 const *) ((t_begin_of_data + 7)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "security_blob"
	int t_security_blob__arraylength;
	t_security_blob__arraylength = 0;
	t_security_blob__arraylength = security_length();
	if ( t_begin_of_data + t_security_blob__arraylength > t_end_of_data + 1 )
		{
		t_security_blob__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_security_blob__arraylength < 0 )
		{
		t_security_blob__arraylength = 0;
		}
	security_blob__elem_ = 0;
	int t_security_blob__elem__it;
	t_security_blob__elem__it = 0;
	int t_security_blob__size;
	security_blob_ = new vector<uint8>;
	security_blob_->reserve(t_security_blob__arraylength);
	const_byteptr t_security_blob__elem__dataptr = (t_begin_of_data + 8);
	for (; t_security_blob__elem__it < t_security_blob__arraylength; ++t_security_blob__elem__it)
		{
		// Check &until(security_blob__elem__dataptr >= end_of_data)
		if ( t_security_blob__elem__dataptr >= t_end_of_data )
			{
			goto end_of_security_blob;
			}
		// Checking out-of-bound for "SMB_setup_andx_ext_response:security_blob__elem"
		if ( t_security_blob__elem__dataptr + (1) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("SMB_setup_andx_ext_response:security_blob__elem",
				((t_security_blob__elem__dataptr - t_begin_of_data)) + (1), 
				(t_end_of_data) - (t_begin_of_data));
			}
		security_blob__elem_ = *((uint8 const *) (t_security_blob__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		security_blob_->push_back(security_blob__elem_);
		t_security_blob__elem__dataptr += 1;
		BINPAC_ASSERT(t_security_blob__elem__dataptr <= t_end_of_data);
		}
end_of_security_blob: ;
	t_security_blob__size = t_security_blob__elem__dataptr - ((t_begin_of_data + 8));
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_security_blob = (t_begin_of_data + 8) + (t_security_blob__size);
	BINPAC_ASSERT(t_dataptr_after_security_blob <= t_end_of_data);
	// Parse "native_os"
	native_os_ = new SMB_string(unicode(), (t_dataptr_after_security_blob - t_begin_of_data));
	int t_native_os__size;
	t_native_os__size = native_os_->Parse(t_dataptr_after_security_blob, t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_native_os = t_dataptr_after_security_blob + (t_native_os__size);
	BINPAC_ASSERT(t_dataptr_after_native_os <= t_end_of_data);
	// Parse "native_lanman"
	native_lanman_ = new SMB_string(unicode(), (t_dataptr_after_native_os - t_begin_of_data));
	int t_native_lanman__size;
	t_native_lanman__size = native_lanman_->Parse(t_dataptr_after_native_os, t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_native_lanman = t_dataptr_after_native_os + (t_native_lanman__size);
	BINPAC_ASSERT(t_dataptr_after_native_lanman <= t_end_of_data);
	// Parse "primary_domain"
	primary_domain_ = new SMB_string(unicode(), (t_dataptr_after_native_lanman - t_begin_of_data));
	int t_primary_domain__size;
	t_primary_domain__size = primary_domain_->Parse(t_dataptr_after_native_lanman, t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	int t_SMB_setup_andx_ext_response__size;
	const_byteptr const t_dataptr_after_primary_domain = t_dataptr_after_native_lanman + (t_primary_domain__size);
	BINPAC_ASSERT(t_dataptr_after_primary_domain <= t_end_of_data);
	t_SMB_setup_andx_ext_response__size = t_dataptr_after_primary_domain - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_setup_andx_ext_response__size) <= t_end_of_data);
	return t_SMB_setup_andx_ext_response__size;
	}

SMB_logoff_andx::SMB_logoff_andx(bool unicode)
	{
	word_count_ = 0;
	andx_ = 0;
	byte_count_ = 0;
	unicode_ = unicode;
	byteorder_ = littleendian;
	}

SMB_logoff_andx::~SMB_logoff_andx()
	{
	Unref(andx_);
	andx_ = 0;
	}

int SMB_logoff_andx::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_logoff_andx"
	if ( t_begin_of_data + (7) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_logoff_andx",
			(0) + (7), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "word_count"
	word_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "andx"
	andx_ = new SMB_andx();
	andx_->Parse((t_begin_of_data + 1), t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte_count"
	byte_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 5))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (7) <= t_end_of_data);
	return 7;
	}

SMB_tree_connect_andx::SMB_tree_connect_andx(bool unicode)
	{
	word_count_ = 0;
	andx_ = 0;
	flags_ = 0;
	password_length_ = 0;
	byte_count_ = 0;
	password_ = 0;
	password__elem_ = 0;
	path_ = 0;
	service_ = 0;
	unicode_ = unicode;
	byteorder_ = littleendian;
	}

SMB_tree_connect_andx::~SMB_tree_connect_andx()
	{
	Unref(andx_);
	andx_ = 0;
	delete password_;
	delete path_;
	path_ = 0;
	delete service_;
	service_ = 0;
	}

int SMB_tree_connect_andx::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_tree_connect_andx:byte_count"
	if ( (t_begin_of_data + 9) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_tree_connect_andx:byte_count",
			(9) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "word_count"
	word_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "andx"
	andx_ = new SMB_andx();
	andx_->Parse((t_begin_of_data + 1), t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "flags"
	flags_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 5))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "password_length"
	password_length_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 7))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte_count"
	byte_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 9))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "password"
	int t_password__arraylength;
	t_password__arraylength = 0;
	t_password__arraylength = password_length();
	if ( t_begin_of_data + t_password__arraylength > t_end_of_data + 1 )
		{
		t_password__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_password__arraylength < 0 )
		{
		t_password__arraylength = 0;
		}
	password__elem_ = 0;
	int t_password__elem__it;
	t_password__elem__it = 0;
	int t_password__size;
	password_ = new vector<uint8>;
	password_->reserve(t_password__arraylength);
	const_byteptr t_password__elem__dataptr = (t_begin_of_data + 11);
	for (; t_password__elem__it < t_password__arraylength; ++t_password__elem__it)
		{
		// Check &until(password__elem__dataptr >= end_of_data)
		if ( t_password__elem__dataptr >= t_end_of_data )
			{
			goto end_of_password;
			}
		// Checking out-of-bound for "SMB_tree_connect_andx:password__elem"
		if ( t_password__elem__dataptr + (1) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("SMB_tree_connect_andx:password__elem",
				((t_password__elem__dataptr - t_begin_of_data)) + (1), 
				(t_end_of_data) - (t_begin_of_data));
			}
		password__elem_ = *((uint8 const *) (t_password__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		password_->push_back(password__elem_);
		t_password__elem__dataptr += 1;
		BINPAC_ASSERT(t_password__elem__dataptr <= t_end_of_data);
		}
end_of_password: ;
	t_password__size = t_password__elem__dataptr - ((t_begin_of_data + 11));
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_password = (t_begin_of_data + 11) + (t_password__size);
	BINPAC_ASSERT(t_dataptr_after_password <= t_end_of_data);
	// Parse "path"
	path_ = new SMB_string(unicode(), (t_dataptr_after_password - t_begin_of_data));
	int t_path__size;
	t_path__size = path_->Parse(t_dataptr_after_password, t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_path = t_dataptr_after_password + (t_path__size);
	BINPAC_ASSERT(t_dataptr_after_path <= t_end_of_data);
	// Parse "service"
	service_ = new SMB_ascii_string();
	int t_service__size;
	t_service__size = service_->Parse(t_dataptr_after_path, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_SMB_tree_connect_andx__size;
	const_byteptr const t_dataptr_after_service = t_dataptr_after_path + (t_service__size);
	BINPAC_ASSERT(t_dataptr_after_service <= t_end_of_data);
	t_SMB_tree_connect_andx__size = t_dataptr_after_service - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_tree_connect_andx__size) <= t_end_of_data);
	return t_SMB_tree_connect_andx__size;
	}

SMB_close::SMB_close(bool unicode)
	{
	word_count_ = 0;
	fid_ = 0;
	time_ = 0;
	byte_count_ = 0;
	unicode_ = unicode;
	byteorder_ = littleendian;
	}

SMB_close::~SMB_close()
	{
	delete time_;
	time_ = 0;
	}

int SMB_close::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_close"
	if ( t_begin_of_data + (11) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_close",
			(0) + (11), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "word_count"
	word_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "fid"
	fid_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time"
	time_ = new SMB_time();
	time_->Parse((t_begin_of_data + 3), t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte_count"
	byte_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 9))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (11) <= t_end_of_data);
	return 11;
	}

SMB_tree_disconnect::SMB_tree_disconnect(bool unicode)
	{
	word_count_ = 0;
	byte_count_ = 0;
	unicode_ = unicode;
	byteorder_ = littleendian;
	}

SMB_tree_disconnect::~SMB_tree_disconnect()
	{
	}

int SMB_tree_disconnect::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_tree_disconnect"
	if ( t_begin_of_data + (3) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_tree_disconnect",
			(0) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "word_count"
	word_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte_count"
	byte_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (3) <= t_end_of_data);
	return 3;
	}

SMB_nt_create_andx::SMB_nt_create_andx(bool unicode)
	{
	word_count_ = 0;
	andx_ = 0;
	reserved_ = 0;
	name_length_ = 0;
	flags_ = 0;
	rest_words_ = 0;
	rest_words__elem_ = 0;
	byte_count_ = 0;
	name_ = 0;
	unicode_ = unicode;
	byteorder_ = littleendian;
	}

SMB_nt_create_andx::~SMB_nt_create_andx()
	{
	Unref(andx_);
	andx_ = 0;
	delete rest_words_;
	delete name_;
	name_ = 0;
	}

int SMB_nt_create_andx::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_nt_create_andx:flags"
	if ( (t_begin_of_data + 8) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_nt_create_andx:flags",
			(8) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "word_count"
	word_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "andx"
	andx_ = new SMB_andx();
	andx_->Parse((t_begin_of_data + 1), t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "reserved"
	reserved_ = *((uint8 const *) ((t_begin_of_data + 5)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "name_length"
	name_length_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 6))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "flags"
	flags_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 8))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "rest_words"
	int t_rest_words__arraylength;
	t_rest_words__arraylength = 0;
	t_rest_words__arraylength = word_count() * 2 - 11;
	if ( t_begin_of_data + t_rest_words__arraylength > t_end_of_data + 1 )
		{
		t_rest_words__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_rest_words__arraylength < 0 )
		{
		t_rest_words__arraylength = 0;
		}
	rest_words__elem_ = 0;
	int t_rest_words__elem__it;
	t_rest_words__elem__it = 0;
	int t_rest_words__size;
	rest_words_ = new vector<uint8>;
	rest_words_->reserve(t_rest_words__arraylength);
	const_byteptr t_rest_words__elem__dataptr = (t_begin_of_data + 12);
	for (; t_rest_words__elem__it < t_rest_words__arraylength; ++t_rest_words__elem__it)
		{
		// Check &until(rest_words__elem__dataptr >= end_of_data)
		if ( t_rest_words__elem__dataptr >= t_end_of_data )
			{
			goto end_of_rest_words;
			}
		// Checking out-of-bound for "SMB_nt_create_andx:rest_words__elem"
		if ( t_rest_words__elem__dataptr + (1) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("SMB_nt_create_andx:rest_words__elem",
				((t_rest_words__elem__dataptr - t_begin_of_data)) + (1), 
				(t_end_of_data) - (t_begin_of_data));
			}
		rest_words__elem_ = *((uint8 const *) (t_rest_words__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		rest_words_->push_back(rest_words__elem_);
		t_rest_words__elem__dataptr += 1;
		BINPAC_ASSERT(t_rest_words__elem__dataptr <= t_end_of_data);
		}
end_of_rest_words: ;
	t_rest_words__size = t_rest_words__elem__dataptr - ((t_begin_of_data + 12));
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_rest_words = (t_begin_of_data + 12) + (t_rest_words__size);
	BINPAC_ASSERT(t_dataptr_after_rest_words <= t_end_of_data);
	// Checking out-of-bound for "SMB_nt_create_andx:byte_count"
	if ( t_dataptr_after_rest_words + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_nt_create_andx:byte_count",
			((t_dataptr_after_rest_words - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "byte_count"
	byte_count_ = FixByteOrder(byteorder(), *((uint16 const *) (t_dataptr_after_rest_words)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "name"
	name_ = new SMB_string(unicode(), ((t_dataptr_after_rest_words + 2) - t_begin_of_data));
	int t_name__size;
	t_name__size = name_->Parse((t_dataptr_after_rest_words + 2), t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	int t_SMB_nt_create_andx__size;
	const_byteptr const t_dataptr_after_name = (t_dataptr_after_rest_words + 2) + (t_name__size);
	BINPAC_ASSERT(t_dataptr_after_name <= t_end_of_data);
	t_SMB_nt_create_andx__size = t_dataptr_after_name - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_nt_create_andx__size) <= t_end_of_data);
	return t_SMB_nt_create_andx__size;
	}

SMB_read_andx::SMB_read_andx()
	{
	word_count_ = 0;
	andx_ = 0;
	fid_ = 0;
	offset_ = 0;
	max_count_ = 0;
	min_count_ = 0;
	max_count_high_ = 0;
	remaining_ = 0;
	offset_high_u_case_index_ = -1;
	offset_high_ = 0;
	byte_count_ = 0;
	byteorder_ = littleendian;
	}

SMB_read_andx::~SMB_read_andx()
	{
	Unref(andx_);
	andx_ = 0;
	switch ( offset_high_u_case_index() )
		{
		case 12:
			// Clean up "offset_high"
			{
			}
			break;
		case 10:
			// Clean up "null"
			{
			}
			break;
		}
	}

int SMB_read_andx::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_read_andx:remaining"
	if ( (t_begin_of_data + 17) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_read_andx:remaining",
			(17) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "word_count"
	word_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "andx"
	andx_ = new SMB_andx();
	andx_->Parse((t_begin_of_data + 1), t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "fid"
	fid_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 5))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "offset"
	offset_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 7))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "max_count"
	max_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 11))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "min_count"
	min_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 13))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "max_count_high"
	max_count_high_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 15))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "remaining"
	remaining_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 17))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "offset_high_u"
	int t_offset_high_u__size;
	offset_high_u_case_index_ = word_count();
	switch ( offset_high_u_case_index() )
		{
		case 12:
			// Parse "offset_high"
			{
			// Checking out-of-bound for "SMB_read_andx:offset_high"
			if ( (t_begin_of_data + 19) + (4) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("SMB_read_andx:offset_high",
					(19) + (4), 
					(t_end_of_data) - (t_begin_of_data));
				}
			offset_high_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 19))));
			// Evaluate 'let' and 'withinput' fields
			t_offset_high_u__size = 4;
			}
			break;
		case 10:
			// Parse "null"
			{
			// Evaluate 'let' and 'withinput' fields
			t_offset_high_u__size = 0;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("SMB_read_andx", offset_high_u_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_offset_high_u = (t_begin_of_data + 19) + (t_offset_high_u__size);
	BINPAC_ASSERT(t_dataptr_after_offset_high_u <= t_end_of_data);
	// Checking out-of-bound for "SMB_read_andx:byte_count"
	if ( t_dataptr_after_offset_high_u + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_read_andx:byte_count",
			((t_dataptr_after_offset_high_u - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "byte_count"
	byte_count_ = FixByteOrder(byteorder(), *((uint16 const *) (t_dataptr_after_offset_high_u)));
	// Evaluate 'let' and 'withinput' fields
	
	int t_SMB_read_andx__size;
	t_SMB_read_andx__size = (t_dataptr_after_offset_high_u + 2) - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_read_andx__size) <= t_end_of_data);
	return t_SMB_read_andx__size;
	}

SMB_read_andx_response::SMB_read_andx_response()
	{
	word_count_ = 0;
	andx_ = 0;
	remaining_ = 0;
	data_compact_ = 0;
	reserved_ = 0;
	data_len_ = 0;
	data_offset_ = 0;
	data_len_high_ = 0;
	reserved2_ = 0;
	reserved2__elem_ = 0;
	byte_count_ = 0;
	byteorder_ = littleendian;
	data_length_ = 0;
	padding_length_ = 0;
	}

SMB_read_andx_response::~SMB_read_andx_response()
	{
	Unref(andx_);
	andx_ = 0;
	delete reserved2_;
	data_.free();
	}

int SMB_read_andx_response::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_read_andx_response:byte_count"
	if ( (t_begin_of_data + 25) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_read_andx_response:byte_count",
			(25) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "word_count"
	word_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "andx"
	andx_ = new SMB_andx();
	andx_->Parse((t_begin_of_data + 1), t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "remaining"
	remaining_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 5))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data_compact"
	data_compact_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 7))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "reserved"
	reserved_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 9))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data_len"
	data_len_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 11))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data_offset"
	data_offset_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 13))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data_len_high"
	data_len_high_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 15))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "reserved2"
	int t_reserved2__arraylength;
	t_reserved2__arraylength = 0;
	t_reserved2__arraylength = 4;
	if ( t_begin_of_data + t_reserved2__arraylength > t_end_of_data + 1 )
		{
		t_reserved2__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_reserved2__arraylength < 0 )
		{
		t_reserved2__arraylength = 0;
		}
	reserved2__elem_ = 0;
	int t_reserved2__elem__it;
	t_reserved2__elem__it = 0;
	reserved2_ = new vector<uint16>;
	reserved2_->reserve(t_reserved2__arraylength);
	const_byteptr t_reserved2__elem__dataptr = (t_begin_of_data + 17);
	for (; t_reserved2__elem__it < t_reserved2__arraylength; ++t_reserved2__elem__it)
		{
		// Check &until(reserved2__elem__dataptr >= end_of_data)
		if ( t_reserved2__elem__dataptr >= t_end_of_data )
			{
			goto end_of_reserved2;
			}
		reserved2__elem_ = FixByteOrder(byteorder(), *((uint16 const *) (t_reserved2__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		reserved2_->push_back(reserved2__elem_);
		t_reserved2__elem__dataptr += 2;
		BINPAC_ASSERT(t_reserved2__elem__dataptr <= t_end_of_data);
		}
end_of_reserved2: ;
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte_count"
	byte_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 25))));
	// Evaluate 'let' and 'withinput' fields
	
	
	data_length_ = data_len_high() * 0x10000 + data_len();
	padding_length_ = byte_count() - data_length();
	const_byteptr const t_dataptr_after_pad = (t_begin_of_data + 27) + (padding_length());
	// Parse "data"
	int t_data__size;
	t_data__size = data_length();
	// Checking out-of-bound for "SMB_read_andx_response:data"
	if ( t_dataptr_after_pad + (t_data__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_read_andx_response:data",
			((t_dataptr_after_pad - t_begin_of_data)) + (t_data__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_pad + t_data__size;
	int t_data_string_length;
	t_data_string_length = data_length();
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-protocol.pac:338", t_data_string_length);
	data_.init(t_dataptr_after_pad, t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_SMB_read_andx_response__size;
	const_byteptr const t_dataptr_after_data = t_dataptr_after_pad + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_SMB_read_andx_response__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_read_andx_response__size) <= t_end_of_data);
	return t_SMB_read_andx_response__size;
	}

SMB_write_andx::SMB_write_andx()
	{
	word_count_ = 0;
	andx_ = 0;
	fid_ = 0;
	offset_ = 0;
	reserved_ = 0;
	write_mode_ = 0;
	remaining_ = 0;
	data_len_high_ = 0;
	data_len_ = 0;
	data_offset_ = 0;
	rest_words_ = 0;
	rest_words__elem_ = 0;
	byte_count_ = 0;
	byteorder_ = littleendian;
	data_length_ = 0;
	}

SMB_write_andx::~SMB_write_andx()
	{
	Unref(andx_);
	andx_ = 0;
	delete rest_words_;
	data_.free();
	}

int SMB_write_andx::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_write_andx:data_offset"
	if ( (t_begin_of_data + 23) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_write_andx:data_offset",
			(23) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "word_count"
	word_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "andx"
	andx_ = new SMB_andx();
	andx_->Parse((t_begin_of_data + 1), t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "fid"
	fid_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 5))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "offset"
	offset_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 7))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "reserved"
	reserved_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 11))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "write_mode"
	write_mode_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 15))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "remaining"
	remaining_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 17))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data_len_high"
	data_len_high_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 19))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data_len"
	data_len_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 21))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data_offset"
	data_offset_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 23))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "rest_words"
	int t_rest_words__arraylength;
	t_rest_words__arraylength = 0;
	t_rest_words__arraylength = word_count() * 2 - 25 + 1;
	if ( t_begin_of_data + t_rest_words__arraylength > t_end_of_data + 1 )
		{
		t_rest_words__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_rest_words__arraylength < 0 )
		{
		t_rest_words__arraylength = 0;
		}
	rest_words__elem_ = 0;
	int t_rest_words__elem__it;
	t_rest_words__elem__it = 0;
	int t_rest_words__size;
	rest_words_ = new vector<uint8>;
	rest_words_->reserve(t_rest_words__arraylength);
	const_byteptr t_rest_words__elem__dataptr = (t_begin_of_data + 25);
	for (; t_rest_words__elem__it < t_rest_words__arraylength; ++t_rest_words__elem__it)
		{
		// Check &until(rest_words__elem__dataptr >= end_of_data)
		if ( t_rest_words__elem__dataptr >= t_end_of_data )
			{
			goto end_of_rest_words;
			}
		// Checking out-of-bound for "SMB_write_andx:rest_words__elem"
		if ( t_rest_words__elem__dataptr + (1) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("SMB_write_andx:rest_words__elem",
				((t_rest_words__elem__dataptr - t_begin_of_data)) + (1), 
				(t_end_of_data) - (t_begin_of_data));
			}
		rest_words__elem_ = *((uint8 const *) (t_rest_words__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		rest_words_->push_back(rest_words__elem_);
		t_rest_words__elem__dataptr += 1;
		BINPAC_ASSERT(t_rest_words__elem__dataptr <= t_end_of_data);
		}
end_of_rest_words: ;
	t_rest_words__size = t_rest_words__elem__dataptr - ((t_begin_of_data + 25));
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_rest_words = (t_begin_of_data + 25) + (t_rest_words__size);
	BINPAC_ASSERT(t_dataptr_after_rest_words <= t_end_of_data);
	// Checking out-of-bound for "SMB_write_andx:byte_count"
	if ( t_dataptr_after_rest_words + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_write_andx:byte_count",
			((t_dataptr_after_rest_words - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "byte_count"
	byte_count_ = FixByteOrder(byteorder(), *((uint16 const *) (t_dataptr_after_rest_words)));
	// Evaluate 'let' and 'withinput' fields
	
	
	const_byteptr t_dataptr_after_pad = t_begin_of_data + (data_offset() - smb_header_length);
	if ( t_dataptr_after_pad < (t_dataptr_after_rest_words + 2) )
		{
		// throw binpac::ExceptionInvalidOffset("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-protocol.pac:362:pad", (t_dataptr_after_rest_words + 2) - t_begin_of_data, data_offset() - smb_header_length);
		t_dataptr_after_pad = (t_dataptr_after_rest_words + 2);
		}
	// Parse "data"
	int t_data__size;
	data_length_ = data_len_high() * 0x10000 + data_len();
	t_data__size = data_length();
	// Checking out-of-bound for "SMB_write_andx:data"
	if ( t_dataptr_after_pad + (t_data__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_write_andx:data",
			((t_dataptr_after_pad - t_begin_of_data)) + (t_data__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_pad + t_data__size;
	int t_data_string_length;
	t_data_string_length = data_length();
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-protocol.pac:363", t_data_string_length);
	data_.init(t_dataptr_after_pad, t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_SMB_write_andx__size;
	const_byteptr const t_dataptr_after_data = t_dataptr_after_pad + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_SMB_write_andx__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_write_andx__size) <= t_end_of_data);
	return t_SMB_write_andx__size;
	}

SMB_write_andx_response::SMB_write_andx_response()
	{
	word_count_ = 0;
	andx_ = 0;
	count_ = 0;
	remaining_ = 0;
	reserved_ = 0;
	byte_count_ = 0;
	byteorder_ = littleendian;
	}

SMB_write_andx_response::~SMB_write_andx_response()
	{
	Unref(andx_);
	andx_ = 0;
	}

int SMB_write_andx_response::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_write_andx_response"
	if ( t_begin_of_data + (15) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_write_andx_response",
			(0) + (15), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "word_count"
	word_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "andx"
	andx_ = new SMB_andx();
	andx_->Parse((t_begin_of_data + 1), t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "count"
	count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 5))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "remaining"
	remaining_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 7))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "reserved"
	reserved_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 9))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte_count"
	byte_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 13))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (15) <= t_end_of_data);
	return 15;
	}

SMB_transaction_data::SMB_transaction_data(bool unicode, uint16 count, uint16 sub_cmd, TransactionType trans_type)
	{
	val_case_index_ = -1;
	mailslot_ = 0;
	lanman_ = 0;
	rap_ = 0;
	pipe_ = 0;
	unicode_ = unicode;
	count_ = count;
	sub_cmd_ = sub_cmd;
	trans_type_ = trans_type;
	}

SMB_transaction_data::~SMB_transaction_data()
	{
	switch ( val_case_index() )
		{
		case 0:
			// Clean up "mailslot"
			{
			delete mailslot_;
			mailslot_ = 0;
			}
			break;
		case 1:
			// Clean up "lanman"
			{
			delete lanman_;
			lanman_ = 0;
			}
			break;
		case 3:
			// Clean up "rap"
			{
			delete rap_;
			rap_ = 0;
			}
			break;
		case 2:
			// Clean up "pipe"
			{
			delete pipe_;
			pipe_ = 0;
			}
			break;
		case 4:
			// Clean up "unknown"
			{
			unknown_.free();
			}
			break;
		default:
			// Clean up "data"
			{
			data_.free();
			}
			break;
		}
	}

int SMB_transaction_data::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	int t_val__size;
	val_case_index_ = trans_type();
	switch ( val_case_index() )
		{
		case 0:
			// Parse "mailslot"
			{
			mailslot_ = new SMB_MailSlot_message(unicode(), count());
			int t_mailslot__size;
			t_mailslot__size = mailslot_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_mailslot__size;
			}
			break;
		case 1:
			// Parse "lanman"
			{
			lanman_ = new SMB_MailSlot_message(unicode(), count());
			int t_lanman__size;
			t_lanman__size = lanman_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_lanman__size;
			}
			break;
		case 3:
			// Parse "rap"
			{
			rap_ = new SMB_Pipe_message(unicode(), count(), sub_cmd());
			int t_rap__size;
			t_rap__size = rap_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_rap__size;
			}
			break;
		case 2:
			// Parse "pipe"
			{
			pipe_ = new SMB_Pipe_message(unicode(), count(), sub_cmd());
			int t_pipe__size;
			t_pipe__size = pipe_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_pipe__size;
			}
			break;
		case 4:
			// Parse "unknown"
			{
			int t_unknown_string_length;
			t_unknown_string_length = (t_end_of_data) - (t_begin_of_data);
			int t_unknown__size;
			t_unknown__size = t_unknown_string_length;
			// check for negative sizes
			if ( t_unknown_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-protocol.pac:384", t_unknown_string_length);
			unknown_.init(t_begin_of_data, t_unknown_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_unknown__size;
			}
			break;
		default:
			// Parse "data"
			{
			int t_data_string_length;
			t_data_string_length = (t_end_of_data) - (t_begin_of_data);
			int t_data__size;
			t_data__size = t_data_string_length;
			// check for negative sizes
			if ( t_data_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-protocol.pac:385", t_data_string_length);
			data_.init(t_begin_of_data, t_data_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_data__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

SMB_transaction::SMB_transaction(int trans_type, bool unicode)
	{
	word_count_ = 0;
	total_param_count_ = 0;
	total_data_count_ = 0;
	max_param_count_ = 0;
	max_data_count_ = 0;
	max_setup_count_ = 0;
	reserved_ = 0;
	flags_ = 0;
	timeout_ = 0;
	reserved2_ = 0;
	param_count_ = 0;
	param_offset_ = 0;
	data_count_ = 0;
	data_offset_ = 0;
	setup_count_ = 0;
	reserved3_ = 0;
	setup_ = 0;
	setup__elem_ = 0;
	byte_count_ = 0;
	name_u_case_index_ = -1;
	name_ = 0;
	data_ = 0;
	trans_type_ = trans_type;
	unicode_ = unicode;
	byteorder_ = littleendian;
	sub_cmd_ = 0;
	}

SMB_transaction::~SMB_transaction()
	{
	delete setup_;
	switch ( name_u_case_index() )
		{
		case 1:
			// Clean up "name"
			{
			delete name_;
			name_ = 0;
			}
			break;
		case 2:
			// Clean up "null"
			{
			}
			break;
		}
	parameters_.free();
	delete data_;
	data_ = 0;
	}

int SMB_transaction::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_transaction:reserved3"
	if ( (t_begin_of_data + 28) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_transaction:reserved3",
			(28) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "word_count"
	word_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "total_param_count"
	total_param_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "total_data_count"
	total_data_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 3))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "max_param_count"
	max_param_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 5))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "max_data_count"
	max_data_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 7))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "max_setup_count"
	max_setup_count_ = *((uint8 const *) ((t_begin_of_data + 9)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "reserved"
	reserved_ = *((uint8 const *) ((t_begin_of_data + 10)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "flags"
	flags_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 11))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "timeout"
	timeout_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 13))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "reserved2"
	reserved2_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 17))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "param_count"
	param_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 19))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "param_offset"
	param_offset_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 21))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data_count"
	data_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 23))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data_offset"
	data_offset_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 25))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "setup_count"
	setup_count_ = *((uint8 const *) ((t_begin_of_data + 27)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "reserved3"
	reserved3_ = *((uint8 const *) ((t_begin_of_data + 28)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "setup"
	int t_setup__arraylength;
	t_setup__arraylength = 0;
	t_setup__arraylength = setup_count();
	if ( t_begin_of_data + t_setup__arraylength > t_end_of_data + 1 )
		{
		t_setup__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_setup__arraylength < 0 )
		{
		t_setup__arraylength = 0;
		}
	setup__elem_ = 0;
	int t_setup__elem__it;
	t_setup__elem__it = 0;
	int t_setup__size;
	setup_ = new vector<uint16>;
	setup_->reserve(t_setup__arraylength);
	const_byteptr t_setup__elem__dataptr = (t_begin_of_data + 29);
	for (; t_setup__elem__it < t_setup__arraylength; ++t_setup__elem__it)
		{
		// Check &until(setup__elem__dataptr >= end_of_data)
		if ( t_setup__elem__dataptr >= t_end_of_data )
			{
			goto end_of_setup;
			}
		// Checking out-of-bound for "SMB_transaction:setup__elem"
		if ( t_setup__elem__dataptr + (2) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("SMB_transaction:setup__elem",
				((t_setup__elem__dataptr - t_begin_of_data)) + (2), 
				(t_end_of_data) - (t_begin_of_data));
			}
		setup__elem_ = FixByteOrder(byteorder(), *((uint16 const *) (t_setup__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		setup_->push_back(setup__elem_);
		t_setup__elem__dataptr += 2;
		BINPAC_ASSERT(t_setup__elem__dataptr <= t_end_of_data);
		}
end_of_setup: ;
	t_setup__size = t_setup__elem__dataptr - ((t_begin_of_data + 29));
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_setup = (t_begin_of_data + 29) + (t_setup__size);
	BINPAC_ASSERT(t_dataptr_after_setup <= t_end_of_data);
	// Checking out-of-bound for "SMB_transaction:byte_count"
	if ( t_dataptr_after_setup + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_transaction:byte_count",
			((t_dataptr_after_setup - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "byte_count"
	byte_count_ = FixByteOrder(byteorder(), *((uint16 const *) (t_dataptr_after_setup)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "name_u"
	int t_name_u__size;
	name_u_case_index_ = trans_type();
	switch ( name_u_case_index() )
		{
		case 1:
			// Parse "name"
			{
			name_ = new SMB_string(unicode(), ((t_dataptr_after_setup + 2) - t_begin_of_data));
			int t_name__size;
			t_name__size = name_->Parse((t_dataptr_after_setup + 2), t_end_of_data, byteorder());
			// Evaluate 'let' and 'withinput' fields
			t_name_u__size = t_name__size;
			}
			break;
		case 2:
			// Parse "null"
			{
			// Evaluate 'let' and 'withinput' fields
			t_name_u__size = 0;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("SMB_transaction", name_u_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	
	const_byteptr const t_dataptr_after_name_u = (t_dataptr_after_setup + 2) + (t_name_u__size);
	BINPAC_ASSERT(t_dataptr_after_name_u <= t_end_of_data);
	const_byteptr t_dataptr_after_pad0 = t_begin_of_data + (param_offset() - smb_header_length);
	if ( t_dataptr_after_pad0 < t_dataptr_after_name_u )
		{
		// throw binpac::ExceptionInvalidOffset("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-protocol.pac:412:pad0", t_dataptr_after_name_u - t_begin_of_data, param_offset() - smb_header_length);
		t_dataptr_after_pad0 = t_dataptr_after_name_u;
		}
	// Parse "parameters"
	int t_parameters__size;
	t_parameters__size = param_count();
	// Checking out-of-bound for "SMB_transaction:parameters"
	if ( t_dataptr_after_pad0 + (t_parameters__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_transaction:parameters",
			((t_dataptr_after_pad0 - t_begin_of_data)) + (t_parameters__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_pad0 + t_parameters__size;
	int t_parameters_string_length;
	t_parameters_string_length = param_count();
	// check for negative sizes
	if ( t_parameters_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-protocol.pac:413", t_parameters_string_length);
	parameters_.init(t_dataptr_after_pad0, t_parameters_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	
	const_byteptr const t_dataptr_after_parameters = t_dataptr_after_pad0 + (t_parameters__size);
	BINPAC_ASSERT(t_dataptr_after_parameters <= t_end_of_data);
	const_byteptr t_dataptr_after_pad1 = t_begin_of_data + (data_offset() - smb_header_length);
	if ( t_dataptr_after_pad1 < t_dataptr_after_parameters )
		{
		// throw binpac::ExceptionInvalidOffset("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-protocol.pac:414:pad1", t_dataptr_after_parameters - t_begin_of_data, data_offset() - smb_header_length);
		t_dataptr_after_pad1 = t_dataptr_after_parameters;
		}
	// Parse "data"
	sub_cmd_ = setup_count() ? (*(setup()))[0] : 0;
	data_ = new SMB_transaction_data(unicode(), data_count(), sub_cmd(), determine_transaction_type(setup_count(), name_string(this)));
	int t_data__size;
	t_data__size = data_->Parse(t_dataptr_after_pad1, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_SMB_transaction__size;
	const_byteptr const t_dataptr_after_data = t_dataptr_after_pad1 + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_SMB_transaction__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_transaction__size) <= t_end_of_data);
	return t_SMB_transaction__size;
	}

SMB_transaction_secondary::SMB_transaction_secondary(bool unicode)
	{
	word_count_ = 0;
	total_param_count_ = 0;
	total_data_count_ = 0;
	param_count_ = 0;
	param_offset_ = 0;
	param_displacement_ = 0;
	data_count_ = 0;
	data_offset_ = 0;
	data_displacement_ = 0;
	fid_ = 0;
	byte_count_ = 0;
	data_ = 0;
	unicode_ = unicode;
	byteorder_ = littleendian;
	}

SMB_transaction_secondary::~SMB_transaction_secondary()
	{
	parameters_.free();
	delete data_;
	data_ = 0;
	}

int SMB_transaction_secondary::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_transaction_secondary:byte_count"
	if ( (t_begin_of_data + 19) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_transaction_secondary:byte_count",
			(19) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "word_count"
	word_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "total_param_count"
	total_param_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "total_data_count"
	total_data_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 3))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "param_count"
	param_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 5))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "param_offset"
	param_offset_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 7))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "param_displacement"
	param_displacement_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 9))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data_count"
	data_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 11))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data_offset"
	data_offset_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 13))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data_displacement"
	data_displacement_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 15))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "fid"
	fid_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 17))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "byte_count"
	byte_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 19))));
	// Evaluate 'let' and 'withinput' fields
	
	
	const_byteptr t_dataptr_after_pad0 = t_begin_of_data + (param_offset() - smb_header_length);
	if ( t_dataptr_after_pad0 < (t_begin_of_data + 21) )
		{
		// throw binpac::ExceptionInvalidOffset("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-protocol.pac:435:pad0", (t_begin_of_data + 21) - t_begin_of_data, param_offset() - smb_header_length);
		t_dataptr_after_pad0 = (t_begin_of_data + 21);
		}
	// Parse "parameters"
	int t_parameters__size;
	t_parameters__size = param_count();
	// Checking out-of-bound for "SMB_transaction_secondary:parameters"
	if ( t_dataptr_after_pad0 + (t_parameters__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_transaction_secondary:parameters",
			((t_dataptr_after_pad0 - t_begin_of_data)) + (t_parameters__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_pad0 + t_parameters__size;
	int t_parameters_string_length;
	t_parameters_string_length = param_count();
	// check for negative sizes
	if ( t_parameters_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-protocol.pac:436", t_parameters_string_length);
	parameters_.init(t_dataptr_after_pad0, t_parameters_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	
	const_byteptr const t_dataptr_after_parameters = t_dataptr_after_pad0 + (t_parameters__size);
	BINPAC_ASSERT(t_dataptr_after_parameters <= t_end_of_data);
	const_byteptr t_dataptr_after_pad1 = t_begin_of_data + (data_offset() - smb_header_length);
	if ( t_dataptr_after_pad1 < t_dataptr_after_parameters )
		{
		// throw binpac::ExceptionInvalidOffset("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-protocol.pac:437:pad1", t_dataptr_after_parameters - t_begin_of_data, data_offset() - smb_header_length);
		t_dataptr_after_pad1 = t_dataptr_after_parameters;
		}
	// Parse "data"
	data_ = new SMB_transaction_data(unicode(), data_count(), 0, SMB_UNKNOWN);
	int t_data__size;
	t_data__size = data_->Parse(t_dataptr_after_pad1, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_SMB_transaction_secondary__size;
	const_byteptr const t_dataptr_after_data = t_dataptr_after_pad1 + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_SMB_transaction_secondary__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_transaction_secondary__size) <= t_end_of_data);
	return t_SMB_transaction_secondary__size;
	}

SMB_transaction_response::SMB_transaction_response(bool unicode)
	{
	word_count_ = 0;
	total_param_count_ = 0;
	total_data_count_ = 0;
	reserved_ = 0;
	param_count_ = 0;
	param_offset_ = 0;
	param_displacement_ = 0;
	data_count_ = 0;
	data_offset_ = 0;
	data_displacement_ = 0;
	setup_count_ = 0;
	reserved2_ = 0;
	setup_ = 0;
	setup__elem_ = 0;
	byte_count_ = 0;
	data_ = 0;
	unicode_ = unicode;
	byteorder_ = littleendian;
	}

SMB_transaction_response::~SMB_transaction_response()
	{
	delete setup_;
	parameters_.free();
	delete data_;
	data_ = 0;
	}

int SMB_transaction_response::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_transaction_response:reserved2"
	if ( (t_begin_of_data + 20) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_transaction_response:reserved2",
			(20) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "word_count"
	word_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "total_param_count"
	total_param_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "total_data_count"
	total_data_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 3))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "reserved"
	reserved_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 5))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "param_count"
	param_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 7))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "param_offset"
	param_offset_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 9))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "param_displacement"
	param_displacement_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 11))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data_count"
	data_count_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 13))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data_offset"
	data_offset_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 15))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data_displacement"
	data_displacement_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 17))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "setup_count"
	setup_count_ = *((uint8 const *) ((t_begin_of_data + 19)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "reserved2"
	reserved2_ = *((uint8 const *) ((t_begin_of_data + 20)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "setup"
	int t_setup__arraylength;
	t_setup__arraylength = 0;
	t_setup__arraylength = setup_count();
	if ( t_begin_of_data + t_setup__arraylength > t_end_of_data + 1 )
		{
		t_setup__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_setup__arraylength < 0 )
		{
		t_setup__arraylength = 0;
		}
	setup__elem_ = 0;
	int t_setup__elem__it;
	t_setup__elem__it = 0;
	int t_setup__size;
	setup_ = new vector<uint16>;
	setup_->reserve(t_setup__arraylength);
	const_byteptr t_setup__elem__dataptr = (t_begin_of_data + 21);
	for (; t_setup__elem__it < t_setup__arraylength; ++t_setup__elem__it)
		{
		// Check &until(setup__elem__dataptr >= end_of_data)
		if ( t_setup__elem__dataptr >= t_end_of_data )
			{
			goto end_of_setup;
			}
		// Checking out-of-bound for "SMB_transaction_response:setup__elem"
		if ( t_setup__elem__dataptr + (2) > t_end_of_data )
			{
			// Handle out-of-bound condition
			throw binpac::ExceptionOutOfBound("SMB_transaction_response:setup__elem",
				((t_setup__elem__dataptr - t_begin_of_data)) + (2), 
				(t_end_of_data) - (t_begin_of_data));
			}
		setup__elem_ = FixByteOrder(byteorder(), *((uint16 const *) (t_setup__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		setup_->push_back(setup__elem_);
		t_setup__elem__dataptr += 2;
		BINPAC_ASSERT(t_setup__elem__dataptr <= t_end_of_data);
		}
end_of_setup: ;
	t_setup__size = t_setup__elem__dataptr - ((t_begin_of_data + 21));
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_setup = (t_begin_of_data + 21) + (t_setup__size);
	BINPAC_ASSERT(t_dataptr_after_setup <= t_end_of_data);
	// Checking out-of-bound for "SMB_transaction_response:byte_count"
	if ( t_dataptr_after_setup + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_transaction_response:byte_count",
			((t_dataptr_after_setup - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "byte_count"
	byte_count_ = FixByteOrder(byteorder(), *((uint16 const *) (t_dataptr_after_setup)));
	// Evaluate 'let' and 'withinput' fields
	
	
	const_byteptr t_dataptr_after_pad0 = t_begin_of_data + (param_offset() - smb_header_length);
	if ( t_dataptr_after_pad0 < (t_dataptr_after_setup + 2) )
		{
		// throw binpac::ExceptionInvalidOffset("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-protocol.pac:456:pad0", (t_dataptr_after_setup + 2) - t_begin_of_data, param_offset() - smb_header_length);
		t_dataptr_after_pad0 = (t_dataptr_after_setup + 2);
		}
	// Parse "parameters"
	int t_parameters__size;
	t_parameters__size = param_count();
	// Checking out-of-bound for "SMB_transaction_response:parameters"
	if ( t_dataptr_after_pad0 + (t_parameters__size) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_transaction_response:parameters",
			((t_dataptr_after_pad0 - t_begin_of_data)) + (t_parameters__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_pad0 + t_parameters__size;
	int t_parameters_string_length;
	t_parameters_string_length = param_count();
	// check for negative sizes
	if ( t_parameters_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-protocol.pac:457", t_parameters_string_length);
	parameters_.init(t_dataptr_after_pad0, t_parameters_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	
	const_byteptr const t_dataptr_after_parameters = t_dataptr_after_pad0 + (t_parameters__size);
	BINPAC_ASSERT(t_dataptr_after_parameters <= t_end_of_data);
	const_byteptr t_dataptr_after_pad1 = t_begin_of_data + (data_offset() - smb_header_length);
	if ( t_dataptr_after_pad1 < t_dataptr_after_parameters )
		{
		// throw binpac::ExceptionInvalidOffset("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-protocol.pac:458:pad1", t_dataptr_after_parameters - t_begin_of_data, data_offset() - smb_header_length);
		t_dataptr_after_pad1 = t_dataptr_after_parameters;
		}
	// Parse "data"
	data_ = new SMB_transaction_data(unicode(), data_count(), 0, SMB_UNKNOWN);
	int t_data__size;
	t_data__size = data_->Parse(t_dataptr_after_pad1, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_SMB_transaction_response__size;
	const_byteptr const t_dataptr_after_data = t_dataptr_after_pad1 + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_SMB_transaction_response__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_transaction_response__size) <= t_end_of_data);
	return t_SMB_transaction_response__size;
	}

SMB_get_dfs_referral::SMB_get_dfs_referral(bool unicode)
	{
	max_referral_level_ = 0;
	file_name_ = 0;
	unicode_ = unicode;
	byteorder_ = littleendian;
	}

SMB_get_dfs_referral::~SMB_get_dfs_referral()
	{
	delete file_name_;
	file_name_ = 0;
	}

int SMB_get_dfs_referral::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_get_dfs_referral:max_referral_level"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_get_dfs_referral:max_referral_level",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "max_referral_level"
	max_referral_level_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "file_name"
	file_name_ = new SMB_string(unicode(), 2);
	int t_file_name__size;
	t_file_name__size = file_name_->Parse((t_begin_of_data + 2), t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	int t_SMB_get_dfs_referral__size;
	const_byteptr const t_dataptr_after_file_name = (t_begin_of_data + 2) + (t_file_name__size);
	BINPAC_ASSERT(t_dataptr_after_file_name <= t_end_of_data);
	t_SMB_get_dfs_referral__size = t_dataptr_after_file_name - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_get_dfs_referral__size) <= t_end_of_data);
	return t_SMB_get_dfs_referral__size;
	}

SMB_MailSlot_message::SMB_MailSlot_message(bool unicode, uint16 byte_count)
	{
	opcode_ = 0;
	data_ = 0;
	unicode_ = unicode;
	byte_count_ = byte_count;
	byteorder_ = littleendian;
	}

SMB_MailSlot_message::~SMB_MailSlot_message()
	{
	delete data_;
	data_ = 0;
	}

int SMB_MailSlot_message::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_MailSlot_message:opcode"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_MailSlot_message:opcode",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "opcode"
	opcode_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data"
	data_ = new SMB_MailSlot_command(unicode(), opcode(), byte_count());
	int t_data__size;
	t_data__size = data_->Parse((t_begin_of_data + 1), t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_SMB_MailSlot_message__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 1) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_SMB_MailSlot_message__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_MailSlot_message__size) <= t_end_of_data);
	return t_SMB_MailSlot_message__size;
	}

SMB_MailSlot_command::SMB_MailSlot_command(bool unicode, uint8 code, uint16 byte_count)
	{
	val_case_index_ = -1;
	announce_ = 0;
	announce_req_ = 0;
	election_req_ = 0;
	get_backup_req_ = 0;
	get_backup_resp_ = 0;
	domain_announce_ = 0;
	lm_announce_ = 0;
	unicode_ = unicode;
	code_ = code;
	byte_count_ = byte_count;
	byteorder_ = littleendian;
	}

SMB_MailSlot_command::~SMB_MailSlot_command()
	{
	switch ( val_case_index() )
		{
		case 1:
			// Clean up "announce"
			{
			delete announce_;
			announce_ = 0;
			}
			break;
		case 2:
			// Clean up "announce_req"
			{
			delete announce_req_;
			announce_req_ = 0;
			}
			break;
		case 8:
			// Clean up "election_req"
			{
			delete election_req_;
			election_req_ = 0;
			}
			break;
		case 9:
			// Clean up "get_backup_req"
			{
			delete get_backup_req_;
			get_backup_req_ = 0;
			}
			break;
		case 10:
			// Clean up "get_backup_resp"
			{
			delete get_backup_resp_;
			get_backup_resp_ = 0;
			}
			break;
		case 12:
			// Clean up "domain_announce"
			{
			delete domain_announce_;
			domain_announce_ = 0;
			}
			break;
		case 15:
			// Clean up "lm_announce"
			{
			delete lm_announce_;
			lm_announce_ = 0;
			}
			break;
		default:
			// Clean up "data"
			{
			data_.free();
			}
			break;
		}
	}

int SMB_MailSlot_command::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	int t_val__size;
	val_case_index_ = code();
	switch ( val_case_index() )
		{
		case 1:
			// Parse "announce"
			{
			announce_ = new SMB_MailSlot_host_announcement(unicode());
			int t_announce__size;
			t_announce__size = announce_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_announce__size;
			}
			break;
		case 2:
			// Parse "announce_req"
			{
			announce_req_ = new SMB_MailSlot_announcement_request(unicode());
			int t_announce_req__size;
			t_announce_req__size = announce_req_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_announce_req__size;
			}
			break;
		case 8:
			// Parse "election_req"
			{
			election_req_ = new SMB_MailSlot_request_election(unicode());
			int t_election_req__size;
			t_election_req__size = election_req_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_election_req__size;
			}
			break;
		case 9:
			// Parse "get_backup_req"
			{
			get_backup_req_ = new SMB_MailSlot_get_backup_list_request(unicode());
			get_backup_req_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 5;
			}
			break;
		case 10:
			// Parse "get_backup_resp"
			{
			get_backup_resp_ = new SMB_MailSlot_get_backup_list_response(unicode());
			int t_get_backup_resp__size;
			t_get_backup_resp__size = get_backup_resp_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_get_backup_resp__size;
			}
			break;
		case 12:
			// Parse "domain_announce"
			{
			domain_announce_ = new SMB_MailSlot_domain_announcement(unicode());
			int t_domain_announce__size;
			t_domain_announce__size = domain_announce_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_domain_announce__size;
			}
			break;
		case 15:
			// Parse "lm_announce"
			{
			lm_announce_ = new SMB_MailSlot_local_master_announcement(unicode());
			int t_lm_announce__size;
			t_lm_announce__size = lm_announce_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_lm_announce__size;
			}
			break;
		default:
			// Parse "data"
			{
			int t_data_string_length;
			t_data_string_length = (t_end_of_data) - (t_begin_of_data);
			int t_data__size;
			t_data__size = t_data_string_length;
			// check for negative sizes
			if ( t_data_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-mailslot.pac:30", t_data_string_length);
			data_.init(t_begin_of_data, t_data_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_data__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

SMB_MailSlot_host_announcement::SMB_MailSlot_host_announcement(bool unicode)
	{
	update_count_ = 0;
	periodicity_ = 0;
	server_name_ = 0;
	os_major_ver_ = 0;
	os_minor_ver_ = 0;
	server_type_ = 0;
	bro_major_ver_ = 0;
	bro_minor_ver_ = 0;
	signature_ = 0;
	comment_ = 0;
	unicode_ = unicode;
	byteorder_ = littleendian;
	}

SMB_MailSlot_host_announcement::~SMB_MailSlot_host_announcement()
	{
	delete server_name_;
	server_name_ = 0;
	delete comment_;
	comment_ = 0;
	}

int SMB_MailSlot_host_announcement::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_MailSlot_host_announcement:periodicity"
	if ( (t_begin_of_data + 1) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_MailSlot_host_announcement:periodicity",
			(1) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "update_count"
	update_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "periodicity"
	periodicity_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "server_name"
	server_name_ = new SMB_string(unicode(), 5);
	int t_server_name__size;
	t_server_name__size = server_name_->Parse((t_begin_of_data + 5), t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_server_name = (t_begin_of_data + 5) + (t_server_name__size);
	BINPAC_ASSERT(t_dataptr_after_server_name <= t_end_of_data);
	// Checking out-of-bound for "SMB_MailSlot_host_announcement:signature"
	if ( (t_dataptr_after_server_name + 8) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_MailSlot_host_announcement:signature",
			(((t_dataptr_after_server_name + 8) - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "os_major_ver"
	os_major_ver_ = *((uint8 const *) (t_dataptr_after_server_name));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "os_minor_ver"
	os_minor_ver_ = *((uint8 const *) ((t_dataptr_after_server_name + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "server_type"
	server_type_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_dataptr_after_server_name + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "bro_major_ver"
	bro_major_ver_ = *((uint8 const *) ((t_dataptr_after_server_name + 6)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "bro_minor_ver"
	bro_minor_ver_ = *((uint8 const *) ((t_dataptr_after_server_name + 7)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "signature"
	signature_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_dataptr_after_server_name + 8))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "comment"
	comment_ = new SMB_string(unicode(), ((t_dataptr_after_server_name + 10) - t_begin_of_data));
	int t_comment__size;
	t_comment__size = comment_->Parse((t_dataptr_after_server_name + 10), t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	int t_SMB_MailSlot_host_announcement__size;
	const_byteptr const t_dataptr_after_comment = (t_dataptr_after_server_name + 10) + (t_comment__size);
	BINPAC_ASSERT(t_dataptr_after_comment <= t_end_of_data);
	t_SMB_MailSlot_host_announcement__size = t_dataptr_after_comment - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_MailSlot_host_announcement__size) <= t_end_of_data);
	return t_SMB_MailSlot_host_announcement__size;
	}

SMB_MailSlot_announcement_request::SMB_MailSlot_announcement_request(bool unicode)
	{
	unused_ = 0;
	response_name_ = 0;
	unicode_ = unicode;
	byteorder_ = littleendian;
	}

SMB_MailSlot_announcement_request::~SMB_MailSlot_announcement_request()
	{
	delete response_name_;
	response_name_ = 0;
	}

int SMB_MailSlot_announcement_request::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_MailSlot_announcement_request:unused"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_MailSlot_announcement_request:unused",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "unused"
	unused_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "response_name"
	response_name_ = new SMB_string(unicode(), 1);
	int t_response_name__size;
	t_response_name__size = response_name_->Parse((t_begin_of_data + 1), t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	int t_SMB_MailSlot_announcement_request__size;
	const_byteptr const t_dataptr_after_response_name = (t_begin_of_data + 1) + (t_response_name__size);
	BINPAC_ASSERT(t_dataptr_after_response_name <= t_end_of_data);
	t_SMB_MailSlot_announcement_request__size = t_dataptr_after_response_name - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_MailSlot_announcement_request__size) <= t_end_of_data);
	return t_SMB_MailSlot_announcement_request__size;
	}

SMB_MailSlot_request_election::SMB_MailSlot_request_election(bool unicode)
	{
	version_ = 0;
	criteria_ = 0;
	uptime_ = 0;
	reserved_ = 0;
	server_name_ = 0;
	unicode_ = unicode;
	byteorder_ = littleendian;
	}

SMB_MailSlot_request_election::~SMB_MailSlot_request_election()
	{
	delete server_name_;
	server_name_ = 0;
	}

int SMB_MailSlot_request_election::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_MailSlot_request_election:reserved"
	if ( (t_begin_of_data + 9) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_MailSlot_request_election:reserved",
			(9) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "version"
	version_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "criteria"
	criteria_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "uptime"
	uptime_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 5))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "reserved"
	reserved_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 9))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "server_name"
	server_name_ = new SMB_string(unicode(), 13);
	int t_server_name__size;
	t_server_name__size = server_name_->Parse((t_begin_of_data + 13), t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	int t_SMB_MailSlot_request_election__size;
	const_byteptr const t_dataptr_after_server_name = (t_begin_of_data + 13) + (t_server_name__size);
	BINPAC_ASSERT(t_dataptr_after_server_name <= t_end_of_data);
	t_SMB_MailSlot_request_election__size = t_dataptr_after_server_name - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_MailSlot_request_election__size) <= t_end_of_data);
	return t_SMB_MailSlot_request_election__size;
	}

SMB_MailSlot_get_backup_list_request::SMB_MailSlot_get_backup_list_request(bool unicode)
	{
	req_count_ = 0;
	token_ = 0;
	unicode_ = unicode;
	byteorder_ = littleendian;
	}

SMB_MailSlot_get_backup_list_request::~SMB_MailSlot_get_backup_list_request()
	{
	}

int SMB_MailSlot_get_backup_list_request::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_MailSlot_get_backup_list_request"
	if ( t_begin_of_data + (5) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_MailSlot_get_backup_list_request",
			(0) + (5), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "req_count"
	req_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "token"
	token_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (5) <= t_end_of_data);
	return 5;
	}

SMB_MailSlot_get_backup_list_response::SMB_MailSlot_get_backup_list_response(bool unicode)
	{
	backup_count_ = 0;
	token_ = 0;
	backup_list_ = 0;
	unicode_ = unicode;
	byteorder_ = littleendian;
	}

SMB_MailSlot_get_backup_list_response::~SMB_MailSlot_get_backup_list_response()
	{
	delete backup_list_;
	backup_list_ = 0;
	}

int SMB_MailSlot_get_backup_list_response::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_MailSlot_get_backup_list_response:token"
	if ( (t_begin_of_data + 1) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_MailSlot_get_backup_list_response:token",
			(1) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "backup_count"
	backup_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "token"
	token_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "backup_list"
	backup_list_ = new SMB_string(unicode(), 5);
	int t_backup_list__size;
	t_backup_list__size = backup_list_->Parse((t_begin_of_data + 5), t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	int t_SMB_MailSlot_get_backup_list_response__size;
	const_byteptr const t_dataptr_after_backup_list = (t_begin_of_data + 5) + (t_backup_list__size);
	BINPAC_ASSERT(t_dataptr_after_backup_list <= t_end_of_data);
	t_SMB_MailSlot_get_backup_list_response__size = t_dataptr_after_backup_list - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_MailSlot_get_backup_list_response__size) <= t_end_of_data);
	return t_SMB_MailSlot_get_backup_list_response__size;
	}

SMB_MailSlot_domain_announcement::SMB_MailSlot_domain_announcement(bool unicode)
	{
	update_count_ = 0;
	periodicity_ = 0;
	server_name_ = 0;
	os_major_ver_ = 0;
	os_minor_ver_ = 0;
	server_type_ = 0;
	bro_major_ver_ = 0;
	bro_minor_ver_ = 0;
	signature_ = 0;
	comment_ = 0;
	unicode_ = unicode;
	byteorder_ = littleendian;
	}

SMB_MailSlot_domain_announcement::~SMB_MailSlot_domain_announcement()
	{
	delete server_name_;
	server_name_ = 0;
	delete comment_;
	comment_ = 0;
	}

int SMB_MailSlot_domain_announcement::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_MailSlot_domain_announcement:periodicity"
	if ( (t_begin_of_data + 1) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_MailSlot_domain_announcement:periodicity",
			(1) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "update_count"
	update_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "periodicity"
	periodicity_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "server_name"
	server_name_ = new SMB_string(unicode(), 5);
	int t_server_name__size;
	t_server_name__size = server_name_->Parse((t_begin_of_data + 5), t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_server_name = (t_begin_of_data + 5) + (t_server_name__size);
	BINPAC_ASSERT(t_dataptr_after_server_name <= t_end_of_data);
	// Checking out-of-bound for "SMB_MailSlot_domain_announcement:signature"
	if ( (t_dataptr_after_server_name + 8) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_MailSlot_domain_announcement:signature",
			(((t_dataptr_after_server_name + 8) - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "os_major_ver"
	os_major_ver_ = *((uint8 const *) (t_dataptr_after_server_name));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "os_minor_ver"
	os_minor_ver_ = *((uint8 const *) ((t_dataptr_after_server_name + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "server_type"
	server_type_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_dataptr_after_server_name + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "bro_major_ver"
	bro_major_ver_ = *((uint8 const *) ((t_dataptr_after_server_name + 6)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "bro_minor_ver"
	bro_minor_ver_ = *((uint8 const *) ((t_dataptr_after_server_name + 7)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "signature"
	signature_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_dataptr_after_server_name + 8))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "comment"
	comment_ = new SMB_string(unicode(), ((t_dataptr_after_server_name + 10) - t_begin_of_data));
	int t_comment__size;
	t_comment__size = comment_->Parse((t_dataptr_after_server_name + 10), t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	int t_SMB_MailSlot_domain_announcement__size;
	const_byteptr const t_dataptr_after_comment = (t_dataptr_after_server_name + 10) + (t_comment__size);
	BINPAC_ASSERT(t_dataptr_after_comment <= t_end_of_data);
	t_SMB_MailSlot_domain_announcement__size = t_dataptr_after_comment - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_MailSlot_domain_announcement__size) <= t_end_of_data);
	return t_SMB_MailSlot_domain_announcement__size;
	}

SMB_MailSlot_local_master_announcement::SMB_MailSlot_local_master_announcement(bool unicode)
	{
	update_count_ = 0;
	periodicity_ = 0;
	server_name_ = 0;
	os_major_ver_ = 0;
	os_minor_ver_ = 0;
	server_type_ = 0;
	bro_major_ver_ = 0;
	bro_minor_ver_ = 0;
	signature_ = 0;
	comment_ = 0;
	unicode_ = unicode;
	byteorder_ = littleendian;
	}

SMB_MailSlot_local_master_announcement::~SMB_MailSlot_local_master_announcement()
	{
	delete server_name_;
	server_name_ = 0;
	delete comment_;
	comment_ = 0;
	}

int SMB_MailSlot_local_master_announcement::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_MailSlot_local_master_announcement:periodicity"
	if ( (t_begin_of_data + 1) + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_MailSlot_local_master_announcement:periodicity",
			(1) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "update_count"
	update_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "periodicity"
	periodicity_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "server_name"
	server_name_ = new SMB_string(unicode(), 5);
	int t_server_name__size;
	t_server_name__size = server_name_->Parse((t_begin_of_data + 5), t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_server_name = (t_begin_of_data + 5) + (t_server_name__size);
	BINPAC_ASSERT(t_dataptr_after_server_name <= t_end_of_data);
	// Checking out-of-bound for "SMB_MailSlot_local_master_announcement:signature"
	if ( (t_dataptr_after_server_name + 8) + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_MailSlot_local_master_announcement:signature",
			(((t_dataptr_after_server_name + 8) - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "os_major_ver"
	os_major_ver_ = *((uint8 const *) (t_dataptr_after_server_name));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "os_minor_ver"
	os_minor_ver_ = *((uint8 const *) ((t_dataptr_after_server_name + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "server_type"
	server_type_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_dataptr_after_server_name + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "bro_major_ver"
	bro_major_ver_ = *((uint8 const *) ((t_dataptr_after_server_name + 6)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "bro_minor_ver"
	bro_minor_ver_ = *((uint8 const *) ((t_dataptr_after_server_name + 7)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "signature"
	signature_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_dataptr_after_server_name + 8))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "comment"
	comment_ = new SMB_string(unicode(), ((t_dataptr_after_server_name + 10) - t_begin_of_data));
	int t_comment__size;
	t_comment__size = comment_->Parse((t_dataptr_after_server_name + 10), t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	int t_SMB_MailSlot_local_master_announcement__size;
	const_byteptr const t_dataptr_after_comment = (t_dataptr_after_server_name + 10) + (t_comment__size);
	BINPAC_ASSERT(t_dataptr_after_comment <= t_end_of_data);
	t_SMB_MailSlot_local_master_announcement__size = t_dataptr_after_comment - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_MailSlot_local_master_announcement__size) <= t_end_of_data);
	return t_SMB_MailSlot_local_master_announcement__size;
	}

SMB_Pipe_message::SMB_Pipe_message(bool unicode, uint16 byte_count, uint16 sub_cmd)
	{
	unicode_ = unicode;
	byte_count_ = byte_count;
	sub_cmd_ = sub_cmd;
	byteorder_ = littleendian;
	}

SMB_Pipe_message::~SMB_Pipe_message()
	{
	data_.free();
	}

int SMB_Pipe_message::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-pipe.pac:8", t_data_string_length);
	data_.init(t_begin_of_data, t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_SMB_Pipe_message__size;
	const_byteptr const t_dataptr_after_data = t_begin_of_data + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_SMB_Pipe_message__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_Pipe_message__size) <= t_end_of_data);
	return t_SMB_Pipe_message__size;
	}

SMB_RAP_message::SMB_RAP_message(bool unicode, uint16 byte_count)
	{
	rap_code_ = 0;
	param_desc_ = 0;
	data_desc_ = 0;
	unicode_ = unicode;
	byte_count_ = byte_count;
	byteorder_ = littleendian;
	}

SMB_RAP_message::~SMB_RAP_message()
	{
	delete param_desc_;
	param_desc_ = 0;
	delete data_desc_;
	data_desc_ = 0;
	data_.free();
	}

int SMB_RAP_message::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "SMB_RAP_message:rap_code"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("SMB_RAP_message:rap_code",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "rap_code"
	rap_code_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "param_desc"
	param_desc_ = new SMB_string(unicode(), 2);
	int t_param_desc__size;
	t_param_desc__size = param_desc_->Parse((t_begin_of_data + 2), t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_param_desc = (t_begin_of_data + 2) + (t_param_desc__size);
	BINPAC_ASSERT(t_dataptr_after_param_desc <= t_end_of_data);
	// Parse "data_desc"
	data_desc_ = new SMB_string(unicode(), (t_dataptr_after_param_desc - t_begin_of_data));
	int t_data_desc__size;
	t_data_desc__size = data_desc_->Parse(t_dataptr_after_param_desc, t_end_of_data, byteorder());
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_data_desc = t_dataptr_after_param_desc + (t_data_desc__size);
	BINPAC_ASSERT(t_dataptr_after_data_desc <= t_end_of_data);
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - (t_dataptr_after_data_desc);
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/smb/smb-pipe.pac:17", t_data_string_length);
	data_.init(t_dataptr_after_data_desc, t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_SMB_RAP_message__size;
	const_byteptr const t_dataptr_after_data = t_dataptr_after_data_desc + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_SMB_RAP_message__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_SMB_RAP_message__size) <= t_end_of_data);
	return t_SMB_RAP_message__size;
	}

} // namespace SMB
}  // namespace binpac

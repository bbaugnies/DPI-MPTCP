// This file is automatically generated from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus.pac.

#ifndef _home_benjamin_Bro_bro_2_3_1_src_analyzer_protocol_modbus_modbus_pac_h
#define _home_benjamin_Bro_bro_2_3_1_src_analyzer_protocol_modbus_modbus_pac_h

#include <vector>

#include "binpac.h"


#include "binpac_bro.h"


#include "events.bif.h"

namespace binpac {

namespace ModbusTCP {
class ContextModbusTCP;
class ModbusTCP_Conn;
enum function_codes {
	READ_COILS = 1,
	READ_DISCRETE_INPUTS = 2,
	READ_HOLDING_REGISTERS = 3,
	READ_INPUT_REGISTERS = 4,
	WRITE_SINGLE_COIL = 5,
	WRITE_SINGLE_REGISTER = 6,
	WRITE_MULTIPLE_COILS = 15,
	WRITE_MULTIPLE_REGISTERS = 16,
	READ_FILE_RECORD = 20,
	WRITE_FILE_RECORD = 21,
	MASK_WRITE_REGISTER = 22,
	READ_WRITE_MULTIPLE_REGISTERS = 23,
	READ_FIFO_QUEUE = 24,
	ENCAP_INTERFACE_TRANSPORT = 43,
	PROGRAM_484 = 9,
	POLL_484 = 10,
	PROGRAM_584_984 = 13,
	POLL_584_984 = 14,
	PROGRAM_884_U84 = 18,
	RESET_COMM_LINK_884_U84 = 19,
	PROGRAM_CONCEPT = 40,
	FIRMWARE_REPLACEMENT = 125,
	PROGRAM_584_984_2 = 126,
	REPORT_LOCAL_ADDRESS = 127,
	READ_COILS_EXCEPTION = 129,
	READ_DISCRETE_INPUTS_EXCEPTION = 130,
	READ_HOLDING_REGISTERS_EXCEPTION = 131,
	READ_INPUT_REGISTERS_EXCEPTION = 132,
	WRITE_SINGLE_COIL_EXCEPTION = 133,
	WRITE_SINGLE_REGISTER_EXCEPTION = 134,
	READ_EXCEPTION_STATUS_EXCEPTION = 135,
	WRITE_MULTIPLE_COILS_EXCEPTION = 143,
	WRITE_MULTIPLE_REGISTERS_EXCEPTION = 144,
	READ_FILE_RECORD_EXCEPTION = 148,
	WRITE_FILE_RECORD_EXCEPTION = 149,
	MASK_WRITE_REGISTER_EXCEPTION = 150,
	READ_WRITE_MULTIPLE_REGISTERS_EXCEPTION = 151,
	READ_FIFO_QUEUE_EXCEPTION = 152,
};
class ModbusTCP_PDU;
class ModbusTCP_TransportHeader;
class ModbusTCP_Request;
class ModbusTCP_Response;
class Exception;
class ReadCoilsRequest;
class ReadCoilsResponse;
class ReadDiscreteInputsRequest;
class ReadDiscreteInputsResponse;
class ReadHoldingRegistersRequest;
class ReadHoldingRegistersResponse;
class ReadInputRegistersRequest;
class ReadInputRegistersResponse;
class WriteSingleCoilRequest;
class WriteSingleCoilResponse;
class WriteSingleRegisterRequest;
class WriteSingleRegisterResponse;
class WriteMultipleCoilsRequest;
class WriteMultipleCoilsResponse;
class WriteMultipleRegistersRequest;
class WriteMultipleRegistersResponse;
class FileRecordRequest;
class ReadFileRecordRequest;
class FileRecordResponse;
class ReadFileRecordResponse;
class ReferenceWithData;
class WriteFileRecordRequest;
class WriteFileRecordResponse;
class MaskWriteRegisterRequest;
class MaskWriteRegisterResponse;
class ReadWriteMultipleRegistersRequest;
class ReadWriteMultipleRegistersResponse;
class ReadFIFOQueueRequest;
class ReadFIFOQueueResponse;
class ModbusTCP_Flow;
} // namespace ModbusTCP

int bytestring_to_int(const_bytestring const & s, int base);
double bytestring_to_double(const_bytestring const & s);
int bytestring_casecmp(const_bytestring const & s1, const_charptr const & s2);
bool bytestring_caseprefix(const_bytestring const & s1, const_charptr const & s2);
double network_time();
namespace ModbusTCP {

class ContextModbusTCP
{
public:
	ContextModbusTCP(ModbusTCP_Conn * connection, ModbusTCP_Flow * flow, FlowBuffer * flow_buffer);
	~ContextModbusTCP();
	
	// Member access functions
	ModbusTCP_Conn * connection() const { return connection_; }
	ModbusTCP_Flow * flow() const { return flow_; }
	FlowBuffer * flow_buffer() const { return flow_buffer_; }
	
protected:
	ModbusTCP_Conn * connection_;
	ModbusTCP_Flow * flow_;
	FlowBuffer * flow_buffer_;
};


class ModbusTCP_Conn : public binpac::ConnectionAnalyzer
{
public:
	ModbusTCP_Conn(BroAnalyzer const & bro_analyzer);
	~ModbusTCP_Conn();
	
	// Member access functions
	ModbusTCP_Flow * upflow() const { return upflow_; }
	ModbusTCP_Flow * downflow() const { return downflow_; }
	BroAnalyzer const & bro_analyzer() const { return bro_analyzer_; }
	
	void NewData(bool is_orig, const_byteptr begin, const_byteptr end);
	void NewGap(bool is_orig, int gap_length);
	void FlowEOF(bool is_orig);
	
protected:
	ModbusTCP_Flow * upflow_;
	ModbusTCP_Flow * downflow_;
	BroAnalyzer bro_analyzer_;
};


class ModbusTCP_PDU
{
public:
	ModbusTCP_PDU(bool is_orig);
	~ModbusTCP_PDU();
	int initial_buffer_length() const { return 8; }
	bool ParseBuffer(flow_buffer_t t_flow_buffer, ContextModbusTCP * t_context);
	
	// Member access functions
	ModbusTCP_TransportHeader * header() const { return header_; }
	int body_case_index() const	{ return body_case_index_; }
	ModbusTCP_Request * request() const
		{
		switch ( body_case_index() )
			{
			case 1:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:64:request", body_case_index(), "true");
				break;
			}
		return request_;
		}
	ModbusTCP_Response * response() const
		{
		switch ( body_case_index() )
			{
			case 0:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:65:response", body_case_index(), "false");
				break;
			}
		return response_;
		}
	bool is_orig() const { return is_orig_; }
	int byteorder() const { return byteorder_; }
	
protected:
	ModbusTCP_TransportHeader * header_;
	int body_case_index_;
	ModbusTCP_Request * request_;
	ModbusTCP_Response * response_;
	bool is_orig_;
	int byteorder_;
	int buffering_state_;
};


class ModbusTCP_TransportHeader
{
public:
	ModbusTCP_TransportHeader();
	~ModbusTCP_TransportHeader();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint16 tid() const { return tid_; }
	uint16 pid() const { return pid_; }
	uint16 len() const { return len_; }
	uint8 uid() const { return uid_; }
	uint8 fc() const { return fc_; }
	int byteorder() const { return byteorder_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint16 tid_;
	uint16 pid_;
	uint16 len_;
	uint8 uid_;
	uint8 fc_;
	int byteorder_;
	bool deliver_;
};


class ModbusTCP_Request
{
public:
	ModbusTCP_Request(ModbusTCP_TransportHeader * header);
	~ModbusTCP_Request();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	int val_case_index() const	{ return val_case_index_; }
	ReadCoilsRequest * readCoils() const
		{
		switch ( val_case_index() )
			{
			case 1:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:80:readCoils", val_case_index(), "READ_COILS");
				break;
			}
		return readCoils_;
		}
	ReadDiscreteInputsRequest * readDiscreteInputs() const
		{
		switch ( val_case_index() )
			{
			case 2:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:81:readDiscreteInputs", val_case_index(), "READ_DISCRETE_INPUTS");
				break;
			}
		return readDiscreteInputs_;
		}
	ReadHoldingRegistersRequest * readHoldingRegisters() const
		{
		switch ( val_case_index() )
			{
			case 3:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:82:readHoldingRegisters", val_case_index(), "READ_HOLDING_REGISTERS");
				break;
			}
		return readHoldingRegisters_;
		}
	ReadInputRegistersRequest * readInputRegisters() const
		{
		switch ( val_case_index() )
			{
			case 4:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:83:readInputRegisters", val_case_index(), "READ_INPUT_REGISTERS");
				break;
			}
		return readInputRegisters_;
		}
	WriteSingleCoilRequest * writeSingleCoil() const
		{
		switch ( val_case_index() )
			{
			case 5:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:84:writeSingleCoil", val_case_index(), "WRITE_SINGLE_COIL");
				break;
			}
		return writeSingleCoil_;
		}
	WriteSingleRegisterRequest * writeSingleRegister() const
		{
		switch ( val_case_index() )
			{
			case 6:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:85:writeSingleRegister", val_case_index(), "WRITE_SINGLE_REGISTER");
				break;
			}
		return writeSingleRegister_;
		}
	WriteMultipleCoilsRequest * writeMultipleCoils() const
		{
		switch ( val_case_index() )
			{
			case 15:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:90:writeMultipleCoils", val_case_index(), "WRITE_MULTIPLE_COILS");
				break;
			}
		return writeMultipleCoils_;
		}
	WriteMultipleRegistersRequest * writeMultRegisters() const
		{
		switch ( val_case_index() )
			{
			case 16:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:91:writeMultRegisters", val_case_index(), "WRITE_MULTIPLE_REGISTERS");
				break;
			}
		return writeMultRegisters_;
		}
	ReadFileRecordRequest * readFileRecord() const
		{
		switch ( val_case_index() )
			{
			case 20:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:93:readFileRecord", val_case_index(), "READ_FILE_RECORD");
				break;
			}
		return readFileRecord_;
		}
	WriteFileRecordRequest * writeFileRecord() const
		{
		switch ( val_case_index() )
			{
			case 21:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:94:writeFileRecord", val_case_index(), "WRITE_FILE_RECORD");
				break;
			}
		return writeFileRecord_;
		}
	MaskWriteRegisterRequest * maskWriteRegister() const
		{
		switch ( val_case_index() )
			{
			case 22:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:95:maskWriteRegister", val_case_index(), "MASK_WRITE_REGISTER");
				break;
			}
		return maskWriteRegister_;
		}
	ReadWriteMultipleRegistersRequest * readWriteMultipleRegisters() const
		{
		switch ( val_case_index() )
			{
			case 23:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:96:readWriteMultipleRegisters", val_case_index(), "READ_WRITE_MULTIPLE_REGISTERS");
				break;
			}
		return readWriteMultipleRegisters_;
		}
	ReadFIFOQueueRequest * readFIFOQueue() const
		{
		switch ( val_case_index() )
			{
			case 24:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:97:readFIFOQueue", val_case_index(), "READ_FIFO_QUEUE");
				break;
			}
		return readFIFOQueue_;
		}
	bytestring const & unknown() const
		{
		return unknown_;
		}
	ModbusTCP_TransportHeader * header() const { return header_; }
	
protected:
	int val_case_index_;
	ReadCoilsRequest * readCoils_;
	ReadDiscreteInputsRequest * readDiscreteInputs_;
	ReadHoldingRegistersRequest * readHoldingRegisters_;
	ReadInputRegistersRequest * readInputRegisters_;
	WriteSingleCoilRequest * writeSingleCoil_;
	WriteSingleRegisterRequest * writeSingleRegister_;
	WriteMultipleCoilsRequest * writeMultipleCoils_;
	WriteMultipleRegistersRequest * writeMultRegisters_;
	ReadFileRecordRequest * readFileRecord_;
	WriteFileRecordRequest * writeFileRecord_;
	MaskWriteRegisterRequest * maskWriteRegister_;
	ReadWriteMultipleRegistersRequest * readWriteMultipleRegisters_;
	ReadFIFOQueueRequest * readFIFOQueue_;
	bytestring unknown_;
	ModbusTCP_TransportHeader * header_;
};


class ModbusTCP_Response
{
public:
	ModbusTCP_Response(ModbusTCP_TransportHeader * header);
	~ModbusTCP_Response();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	int val_case_index() const	{ return val_case_index_; }
	ReadCoilsResponse * readCoils() const
		{
		switch ( val_case_index() )
			{
			case 1:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:107:readCoils", val_case_index(), "READ_COILS");
				break;
			}
		return readCoils_;
		}
	ReadDiscreteInputsResponse * readDiscreteInputs() const
		{
		switch ( val_case_index() )
			{
			case 2:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:108:readDiscreteInputs", val_case_index(), "READ_DISCRETE_INPUTS");
				break;
			}
		return readDiscreteInputs_;
		}
	ReadHoldingRegistersResponse * readHoldingRegisters() const
		{
		switch ( val_case_index() )
			{
			case 3:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:109:readHoldingRegisters", val_case_index(), "READ_HOLDING_REGISTERS");
				break;
			}
		return readHoldingRegisters_;
		}
	ReadInputRegistersResponse * readInputRegisters() const
		{
		switch ( val_case_index() )
			{
			case 4:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:110:readInputRegisters", val_case_index(), "READ_INPUT_REGISTERS");
				break;
			}
		return readInputRegisters_;
		}
	WriteSingleCoilResponse * writeSingleCoil() const
		{
		switch ( val_case_index() )
			{
			case 5:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:111:writeSingleCoil", val_case_index(), "WRITE_SINGLE_COIL");
				break;
			}
		return writeSingleCoil_;
		}
	WriteSingleRegisterResponse * writeSingleRegister() const
		{
		switch ( val_case_index() )
			{
			case 6:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:112:writeSingleRegister", val_case_index(), "WRITE_SINGLE_REGISTER");
				break;
			}
		return writeSingleRegister_;
		}
	WriteMultipleCoilsResponse * writeMultipleCoils() const
		{
		switch ( val_case_index() )
			{
			case 15:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:117:writeMultipleCoils", val_case_index(), "WRITE_MULTIPLE_COILS");
				break;
			}
		return writeMultipleCoils_;
		}
	WriteMultipleRegistersResponse * writeMultRegisters() const
		{
		switch ( val_case_index() )
			{
			case 16:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:118:writeMultRegisters", val_case_index(), "WRITE_MULTIPLE_REGISTERS");
				break;
			}
		return writeMultRegisters_;
		}
	ReadFileRecordResponse * readFileRecord() const
		{
		switch ( val_case_index() )
			{
			case 20:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:120:readFileRecord", val_case_index(), "READ_FILE_RECORD");
				break;
			}
		return readFileRecord_;
		}
	WriteFileRecordResponse * writeFileRecord() const
		{
		switch ( val_case_index() )
			{
			case 21:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:121:writeFileRecord", val_case_index(), "WRITE_FILE_RECORD");
				break;
			}
		return writeFileRecord_;
		}
	MaskWriteRegisterResponse * maskWriteRegister() const
		{
		switch ( val_case_index() )
			{
			case 22:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:122:maskWriteRegister", val_case_index(), "MASK_WRITE_REGISTER");
				break;
			}
		return maskWriteRegister_;
		}
	ReadWriteMultipleRegistersResponse * readWriteMultipleRegisters() const
		{
		switch ( val_case_index() )
			{
			case 23:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:123:readWriteMultipleRegisters", val_case_index(), "READ_WRITE_MULTIPLE_REGISTERS");
				break;
			}
		return readWriteMultipleRegisters_;
		}
	ReadFIFOQueueResponse * readFIFOQueue() const
		{
		switch ( val_case_index() )
			{
			case 24:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:124:readFIFOQueue", val_case_index(), "READ_FIFO_QUEUE");
				break;
			}
		return readFIFOQueue_;
		}
	Exception * readHoldingRegistersException() const
		{
		switch ( val_case_index() )
			{
			case 131:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:127:readHoldingRegistersException", val_case_index(), "READ_HOLDING_REGISTERS_EXCEPTION");
				break;
			}
		return readHoldingRegistersException_;
		}
	Exception * writeMultRegistersException() const
		{
		switch ( val_case_index() )
			{
			case 144:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:128:writeMultRegistersException", val_case_index(), "WRITE_MULTIPLE_REGISTERS_EXCEPTION");
				break;
			}
		return writeMultRegistersException_;
		}
	Exception * readCoilsException() const
		{
		switch ( val_case_index() )
			{
			case 129:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:129:readCoilsException", val_case_index(), "READ_COILS_EXCEPTION");
				break;
			}
		return readCoilsException_;
		}
	Exception * readDiscreteInputsException() const
		{
		switch ( val_case_index() )
			{
			case 130:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:130:readDiscreteInputsException", val_case_index(), "READ_DISCRETE_INPUTS_EXCEPTION");
				break;
			}
		return readDiscreteInputsException_;
		}
	Exception * readInputRegistersException() const
		{
		switch ( val_case_index() )
			{
			case 132:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:131:readInputRegistersException", val_case_index(), "READ_INPUT_REGISTERS_EXCEPTION");
				break;
			}
		return readInputRegistersException_;
		}
	Exception * writeCoilException() const
		{
		switch ( val_case_index() )
			{
			case 133:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:132:writeCoilException", val_case_index(), "WRITE_SINGLE_COIL_EXCEPTION");
				break;
			}
		return writeCoilException_;
		}
	Exception * writeSingleRegisterException() const
		{
		switch ( val_case_index() )
			{
			case 134:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:133:writeSingleRegisterException", val_case_index(), "WRITE_SINGLE_REGISTER_EXCEPTION");
				break;
			}
		return writeSingleRegisterException_;
		}
	Exception * readExceptionStatusException() const
		{
		switch ( val_case_index() )
			{
			case 135:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:134:readExceptionStatusException", val_case_index(), "READ_EXCEPTION_STATUS_EXCEPTION");
				break;
			}
		return readExceptionStatusException_;
		}
	Exception * forceMultipleCoilsException() const
		{
		switch ( val_case_index() )
			{
			case 143:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:135:forceMultipleCoilsException", val_case_index(), "WRITE_MULTIPLE_COILS_EXCEPTION");
				break;
			}
		return forceMultipleCoilsException_;
		}
	Exception * readGeneralReferenceException() const
		{
		switch ( val_case_index() )
			{
			case 148:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:136:readGeneralReferenceException", val_case_index(), "READ_FILE_RECORD_EXCEPTION");
				break;
			}
		return readGeneralReferenceException_;
		}
	Exception * writeGeneralReferenceException() const
		{
		switch ( val_case_index() )
			{
			case 149:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:137:writeGeneralReferenceException", val_case_index(), "WRITE_FILE_RECORD_EXCEPTION");
				break;
			}
		return writeGeneralReferenceException_;
		}
	Exception * maskWriteRegisterException() const
		{
		switch ( val_case_index() )
			{
			case 150:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:138:maskWriteRegisterException", val_case_index(), "MASK_WRITE_REGISTER_EXCEPTION");
				break;
			}
		return maskWriteRegisterException_;
		}
	Exception * readWriteRegistersException() const
		{
		switch ( val_case_index() )
			{
			case 151:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:139:readWriteRegistersException", val_case_index(), "READ_WRITE_MULTIPLE_REGISTERS_EXCEPTION");
				break;
			}
		return readWriteRegistersException_;
		}
	Exception * readFIFOQueueException() const
		{
		switch ( val_case_index() )
			{
			case 152:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/modbus/modbus-protocol.pac:140:readFIFOQueueException", val_case_index(), "READ_FIFO_QUEUE_EXCEPTION");
				break;
			}
		return readFIFOQueueException_;
		}
	bytestring const & unknown() const
		{
		return unknown_;
		}
	ModbusTCP_TransportHeader * header() const { return header_; }
	
protected:
	int val_case_index_;
	ReadCoilsResponse * readCoils_;
	ReadDiscreteInputsResponse * readDiscreteInputs_;
	ReadHoldingRegistersResponse * readHoldingRegisters_;
	ReadInputRegistersResponse * readInputRegisters_;
	WriteSingleCoilResponse * writeSingleCoil_;
	WriteSingleRegisterResponse * writeSingleRegister_;
	WriteMultipleCoilsResponse * writeMultipleCoils_;
	WriteMultipleRegistersResponse * writeMultRegisters_;
	ReadFileRecordResponse * readFileRecord_;
	WriteFileRecordResponse * writeFileRecord_;
	MaskWriteRegisterResponse * maskWriteRegister_;
	ReadWriteMultipleRegistersResponse * readWriteMultipleRegisters_;
	ReadFIFOQueueResponse * readFIFOQueue_;
	Exception * readHoldingRegistersException_;
	Exception * writeMultRegistersException_;
	Exception * readCoilsException_;
	Exception * readDiscreteInputsException_;
	Exception * readInputRegistersException_;
	Exception * writeCoilException_;
	Exception * writeSingleRegisterException_;
	Exception * readExceptionStatusException_;
	Exception * forceMultipleCoilsException_;
	Exception * readGeneralReferenceException_;
	Exception * writeGeneralReferenceException_;
	Exception * maskWriteRegisterException_;
	Exception * readWriteRegistersException_;
	Exception * readFIFOQueueException_;
	bytestring unknown_;
	ModbusTCP_TransportHeader * header_;
};


class Exception
{
public:
	Exception(ModbusTCP_TransportHeader * header);
	~Exception();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint8 code() const { return code_; }
	ModbusTCP_TransportHeader * header() const { return header_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint8 code_;
	ModbusTCP_TransportHeader * header_;
	bool deliver_;
};


class ReadCoilsRequest
{
public:
	ReadCoilsRequest(ModbusTCP_TransportHeader * header);
	~ReadCoilsRequest();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint16 start_address() const { return start_address_; }
	uint16 quantity() const { return quantity_; }
	ModbusTCP_TransportHeader * header() const { return header_; }
	int byteorder() const { return byteorder_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint16 start_address_;
	uint16 quantity_;
	ModbusTCP_TransportHeader * header_;
	int byteorder_;
	bool deliver_;
};


class ReadCoilsResponse
{
public:
	ReadCoilsResponse(ModbusTCP_TransportHeader * header);
	~ReadCoilsResponse();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint8 byte_count() const { return byte_count_; }
	bytestring const & bits() const { return bits_; }
	ModbusTCP_TransportHeader * header() const { return header_; }
	int byteorder() const { return byteorder_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint8 byte_count_;
	bytestring bits_;
	ModbusTCP_TransportHeader * header_;
	int byteorder_;
	bool deliver_;
};


class ReadDiscreteInputsRequest
{
public:
	ReadDiscreteInputsRequest(ModbusTCP_TransportHeader * header);
	~ReadDiscreteInputsRequest();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint16 start_address() const { return start_address_; }
	uint16 quantity() const { return quantity_; }
	ModbusTCP_TransportHeader * header() const { return header_; }
	int byteorder() const { return byteorder_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint16 start_address_;
	uint16 quantity_;
	ModbusTCP_TransportHeader * header_;
	int byteorder_;
	bool deliver_;
};


class ReadDiscreteInputsResponse
{
public:
	ReadDiscreteInputsResponse(ModbusTCP_TransportHeader * header);
	~ReadDiscreteInputsResponse();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint8 byte_count() const { return byte_count_; }
	bytestring const & bits() const { return bits_; }
	ModbusTCP_TransportHeader * header() const { return header_; }
	int byteorder() const { return byteorder_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint8 byte_count_;
	bytestring bits_;
	ModbusTCP_TransportHeader * header_;
	int byteorder_;
	bool deliver_;
};


class ReadHoldingRegistersRequest
{
public:
	ReadHoldingRegistersRequest(ModbusTCP_TransportHeader * header);
	~ReadHoldingRegistersRequest();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint16 start_address() const { return start_address_; }
	uint16 quantity() const { return quantity_; }
	ModbusTCP_TransportHeader * header() const { return header_; }
	int byteorder() const { return byteorder_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint16 start_address_;
	uint16 quantity_;
	ModbusTCP_TransportHeader * header_;
	int byteorder_;
	bool deliver_;
};


class ReadHoldingRegistersResponse
{
public:
	ReadHoldingRegistersResponse(ModbusTCP_TransportHeader * header);
	~ReadHoldingRegistersResponse();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint8 byte_count() const { return byte_count_; }
	vector<uint16> * registers() const { return registers_; }
	ModbusTCP_TransportHeader * header() const { return header_; }
	int byteorder() const { return byteorder_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint8 byte_count_;
	vector<uint16> * registers_;
	uint16 registers__elem_;
	ModbusTCP_TransportHeader * header_;
	int byteorder_;
	bool deliver_;
};


class ReadInputRegistersRequest
{
public:
	ReadInputRegistersRequest(ModbusTCP_TransportHeader * header);
	~ReadInputRegistersRequest();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint16 start_address() const { return start_address_; }
	uint16 quantity() const { return quantity_; }
	ModbusTCP_TransportHeader * header() const { return header_; }
	int byteorder() const { return byteorder_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint16 start_address_;
	uint16 quantity_;
	ModbusTCP_TransportHeader * header_;
	int byteorder_;
	bool deliver_;
};


class ReadInputRegistersResponse
{
public:
	ReadInputRegistersResponse(ModbusTCP_TransportHeader * header);
	~ReadInputRegistersResponse();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint8 byte_count() const { return byte_count_; }
	vector<uint16> * registers() const { return registers_; }
	ModbusTCP_TransportHeader * header() const { return header_; }
	int byteorder() const { return byteorder_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint8 byte_count_;
	vector<uint16> * registers_;
	uint16 registers__elem_;
	ModbusTCP_TransportHeader * header_;
	int byteorder_;
	bool deliver_;
};


class WriteSingleCoilRequest
{
public:
	WriteSingleCoilRequest(ModbusTCP_TransportHeader * header);
	~WriteSingleCoilRequest();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint16 address() const { return address_; }
	uint16 value() const { return value_; }
	ModbusTCP_TransportHeader * header() const { return header_; }
	int byteorder() const { return byteorder_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint16 address_;
	uint16 value_;
	ModbusTCP_TransportHeader * header_;
	int byteorder_;
	bool deliver_;
};


class WriteSingleCoilResponse
{
public:
	WriteSingleCoilResponse(ModbusTCP_TransportHeader * header);
	~WriteSingleCoilResponse();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint16 address() const { return address_; }
	uint16 value() const { return value_; }
	ModbusTCP_TransportHeader * header() const { return header_; }
	int byteorder() const { return byteorder_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint16 address_;
	uint16 value_;
	ModbusTCP_TransportHeader * header_;
	int byteorder_;
	bool deliver_;
};


class WriteSingleRegisterRequest
{
public:
	WriteSingleRegisterRequest(ModbusTCP_TransportHeader * header);
	~WriteSingleRegisterRequest();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint16 address() const { return address_; }
	uint16 value() const { return value_; }
	ModbusTCP_TransportHeader * header() const { return header_; }
	int byteorder() const { return byteorder_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint16 address_;
	uint16 value_;
	ModbusTCP_TransportHeader * header_;
	int byteorder_;
	bool deliver_;
};


class WriteSingleRegisterResponse
{
public:
	WriteSingleRegisterResponse(ModbusTCP_TransportHeader * header);
	~WriteSingleRegisterResponse();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint16 address() const { return address_; }
	uint16 value() const { return value_; }
	ModbusTCP_TransportHeader * header() const { return header_; }
	int byteorder() const { return byteorder_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint16 address_;
	uint16 value_;
	ModbusTCP_TransportHeader * header_;
	int byteorder_;
	bool deliver_;
};


class WriteMultipleCoilsRequest
{
public:
	WriteMultipleCoilsRequest(ModbusTCP_TransportHeader * header);
	~WriteMultipleCoilsRequest();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint16 start_address() const { return start_address_; }
	uint16 quantity() const { return quantity_; }
	uint8 byte_count() const { return byte_count_; }
	bytestring const & coils() const { return coils_; }
	ModbusTCP_TransportHeader * header() const { return header_; }
	int byteorder() const { return byteorder_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint16 start_address_;
	uint16 quantity_;
	uint8 byte_count_;
	bytestring coils_;
	ModbusTCP_TransportHeader * header_;
	int byteorder_;
	bool deliver_;
};


class WriteMultipleCoilsResponse
{
public:
	WriteMultipleCoilsResponse(ModbusTCP_TransportHeader * header);
	~WriteMultipleCoilsResponse();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint16 start_address() const { return start_address_; }
	uint16 quantity() const { return quantity_; }
	ModbusTCP_TransportHeader * header() const { return header_; }
	int byteorder() const { return byteorder_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint16 start_address_;
	uint16 quantity_;
	ModbusTCP_TransportHeader * header_;
	int byteorder_;
	bool deliver_;
};


class WriteMultipleRegistersRequest
{
public:
	WriteMultipleRegistersRequest(ModbusTCP_TransportHeader * header);
	~WriteMultipleRegistersRequest();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint16 start_address() const { return start_address_; }
	uint16 quantity() const { return quantity_; }
	uint8 byte_count() const { return byte_count_; }
	vector<uint16> * registers() const { return registers_; }
	ModbusTCP_TransportHeader * header() const { return header_; }
	int byteorder() const { return byteorder_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint16 start_address_;
	uint16 quantity_;
	uint8 byte_count_;
	vector<uint16> * registers_;
	uint16 registers__elem_;
	ModbusTCP_TransportHeader * header_;
	int byteorder_;
	bool deliver_;
};


class WriteMultipleRegistersResponse
{
public:
	WriteMultipleRegistersResponse(ModbusTCP_TransportHeader * header);
	~WriteMultipleRegistersResponse();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint16 start_address() const { return start_address_; }
	uint16 quantity() const { return quantity_; }
	ModbusTCP_TransportHeader * header() const { return header_; }
	int byteorder() const { return byteorder_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint16 start_address_;
	uint16 quantity_;
	ModbusTCP_TransportHeader * header_;
	int byteorder_;
	bool deliver_;
};


class FileRecordRequest
{
public:
	FileRecordRequest();
	~FileRecordRequest();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 ref_type() const { return ref_type_; }
	uint16 file_num() const { return file_num_; }
	uint16 record_num() const { return record_num_; }
	uint16 record_len() const { return record_len_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 ref_type_;
	uint16 file_num_;
	uint16 record_num_;
	uint16 record_len_;
	int byteorder_;
};


class ReadFileRecordRequest
{
public:
	ReadFileRecordRequest(ModbusTCP_TransportHeader * header);
	~ReadFileRecordRequest();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint8 byte_count() const { return byte_count_; }
	vector<FileRecordRequest *> * references() const { return references_; }
	ModbusTCP_TransportHeader * header() const { return header_; }
	int byteorder() const { return byteorder_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint8 byte_count_;
	vector<FileRecordRequest *> * references_;
	FileRecordRequest * references__elem_;
	ModbusTCP_TransportHeader * header_;
	int byteorder_;
	bool deliver_;
};


class FileRecordResponse
{
public:
	FileRecordResponse();
	~FileRecordResponse();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 file_len() const { return file_len_; }
	uint8 ref_type() const { return ref_type_; }
	vector<uint16> * record_data() const { return record_data_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 file_len_;
	uint8 ref_type_;
	vector<uint16> * record_data_;
	uint16 record_data__elem_;
	int byteorder_;
};


class ReadFileRecordResponse
{
public:
	ReadFileRecordResponse(ModbusTCP_TransportHeader * header);
	~ReadFileRecordResponse();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint8 byte_count() const { return byte_count_; }
	vector<FileRecordResponse *> * references() const { return references_; }
	ModbusTCP_TransportHeader * header() const { return header_; }
	int byteorder() const { return byteorder_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint8 byte_count_;
	vector<FileRecordResponse *> * references_;
	FileRecordResponse * references__elem_;
	ModbusTCP_TransportHeader * header_;
	int byteorder_;
	bool deliver_;
};


class ReferenceWithData
{
public:
	ReferenceWithData();
	~ReferenceWithData();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	uint8 ref_type() const { return ref_type_; }
	uint16 file_num() const { return file_num_; }
	uint16 record_num() const { return record_num_; }
	uint16 word_count() const { return word_count_; }
	vector<uint16> * register_value() const { return register_value_; }
	int byteorder() const { return byteorder_; }
	
protected:
	uint8 ref_type_;
	uint16 file_num_;
	uint16 record_num_;
	uint16 word_count_;
	vector<uint16> * register_value_;
	uint16 register_value__elem_;
	int byteorder_;
};


class WriteFileRecordRequest
{
public:
	WriteFileRecordRequest(ModbusTCP_TransportHeader * header);
	~WriteFileRecordRequest();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint8 byte_count() const { return byte_count_; }
	vector<ReferenceWithData *> * references() const { return references_; }
	ModbusTCP_TransportHeader * header() const { return header_; }
	int byteorder() const { return byteorder_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint8 byte_count_;
	vector<ReferenceWithData *> * references_;
	ReferenceWithData * references__elem_;
	ModbusTCP_TransportHeader * header_;
	int byteorder_;
	bool deliver_;
};


class WriteFileRecordResponse
{
public:
	WriteFileRecordResponse(ModbusTCP_TransportHeader * header);
	~WriteFileRecordResponse();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint8 byte_count() const { return byte_count_; }
	vector<ReferenceWithData *> * references() const { return references_; }
	ModbusTCP_TransportHeader * header() const { return header_; }
	int byteorder() const { return byteorder_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint8 byte_count_;
	vector<ReferenceWithData *> * references_;
	ReferenceWithData * references__elem_;
	ModbusTCP_TransportHeader * header_;
	int byteorder_;
	bool deliver_;
};


class MaskWriteRegisterRequest
{
public:
	MaskWriteRegisterRequest(ModbusTCP_TransportHeader * header);
	~MaskWriteRegisterRequest();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint16 address() const { return address_; }
	uint16 and_mask() const { return and_mask_; }
	uint16 or_mask() const { return or_mask_; }
	ModbusTCP_TransportHeader * header() const { return header_; }
	int byteorder() const { return byteorder_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint16 address_;
	uint16 and_mask_;
	uint16 or_mask_;
	ModbusTCP_TransportHeader * header_;
	int byteorder_;
	bool deliver_;
};


class MaskWriteRegisterResponse
{
public:
	MaskWriteRegisterResponse(ModbusTCP_TransportHeader * header);
	~MaskWriteRegisterResponse();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint16 address() const { return address_; }
	uint16 and_mask() const { return and_mask_; }
	uint16 or_mask() const { return or_mask_; }
	ModbusTCP_TransportHeader * header() const { return header_; }
	int byteorder() const { return byteorder_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint16 address_;
	uint16 and_mask_;
	uint16 or_mask_;
	ModbusTCP_TransportHeader * header_;
	int byteorder_;
	bool deliver_;
};


class ReadWriteMultipleRegistersRequest
{
public:
	ReadWriteMultipleRegistersRequest(ModbusTCP_TransportHeader * header);
	~ReadWriteMultipleRegistersRequest();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint16 read_start_address() const { return read_start_address_; }
	uint16 read_quantity() const { return read_quantity_; }
	uint16 write_start_address() const { return write_start_address_; }
	uint16 write_quantity() const { return write_quantity_; }
	uint8 write_byte_count() const { return write_byte_count_; }
	vector<uint16> * write_register_values() const { return write_register_values_; }
	ModbusTCP_TransportHeader * header() const { return header_; }
	int byteorder() const { return byteorder_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint16 read_start_address_;
	uint16 read_quantity_;
	uint16 write_start_address_;
	uint16 write_quantity_;
	uint8 write_byte_count_;
	vector<uint16> * write_register_values_;
	uint16 write_register_values__elem_;
	ModbusTCP_TransportHeader * header_;
	int byteorder_;
	bool deliver_;
};


class ReadWriteMultipleRegistersResponse
{
public:
	ReadWriteMultipleRegistersResponse(ModbusTCP_TransportHeader * header);
	~ReadWriteMultipleRegistersResponse();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint8 byte_count() const { return byte_count_; }
	vector<uint16> * registers() const { return registers_; }
	ModbusTCP_TransportHeader * header() const { return header_; }
	int byteorder() const { return byteorder_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint8 byte_count_;
	vector<uint16> * registers_;
	uint16 registers__elem_;
	ModbusTCP_TransportHeader * header_;
	int byteorder_;
	bool deliver_;
};


class ReadFIFOQueueRequest
{
public:
	ReadFIFOQueueRequest(ModbusTCP_TransportHeader * header);
	~ReadFIFOQueueRequest();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint16 start_address() const { return start_address_; }
	ModbusTCP_TransportHeader * header() const { return header_; }
	int byteorder() const { return byteorder_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint16 start_address_;
	ModbusTCP_TransportHeader * header_;
	int byteorder_;
	bool deliver_;
};


class ReadFIFOQueueResponse
{
public:
	ReadFIFOQueueResponse(ModbusTCP_TransportHeader * header);
	~ReadFIFOQueueResponse();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextModbusTCP * t_context);
	
	// Member access functions
	uint16 byte_count() const { return byte_count_; }
	uint16 fifo_count() const { return fifo_count_; }
	vector<uint16> * register_data() const { return register_data_; }
	ModbusTCP_TransportHeader * header() const { return header_; }
	int byteorder() const { return byteorder_; }
	bool deliver() const { return deliver_; }
	
protected:
	uint16 byte_count_;
	uint16 fifo_count_;
	vector<uint16> * register_data_;
	uint16 register_data__elem_;
	ModbusTCP_TransportHeader * header_;
	int byteorder_;
	bool deliver_;
};


class ModbusTCP_Flow : public binpac::FlowAnalyzer
{
public:
	ModbusTCP_Flow(ModbusTCP_Conn * connection, bool is_orig);
	~ModbusTCP_Flow();
	
	// Member access functions
	FlowBuffer * flow_buffer() const { return flow_buffer_; }
	ModbusTCP_Conn * connection() const { return connection_; }
	bool is_orig() const { return is_orig_; }
	
	void NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data);
	void NewGap(int gap_length);
	void FlowEOF();
	
	// Functions
	bool deliver_message(ModbusTCP_TransportHeader * header);
	bool deliver_Exception(ModbusTCP_TransportHeader * header, Exception * message);
	bool deliver_ReadCoilsRequest(ModbusTCP_TransportHeader * header, ReadCoilsRequest * message);
	bool deliver_ReadCoilsResponse(ModbusTCP_TransportHeader * header, ReadCoilsResponse * message);
	bool deliver_ReadDiscreteInputsRequest(ModbusTCP_TransportHeader * header, ReadDiscreteInputsRequest * message);
	bool deliver_ReadDiscreteInputsResponse(ModbusTCP_TransportHeader * header, ReadDiscreteInputsResponse * message);
	bool deliver_ReadHoldingRegistersRequest(ModbusTCP_TransportHeader * header, ReadHoldingRegistersRequest * message);
	bool deliver_ReadHoldingRegistersResponse(ModbusTCP_TransportHeader * header, ReadHoldingRegistersResponse * message);
	bool deliver_ReadInputRegistersRequest(ModbusTCP_TransportHeader * header, ReadInputRegistersRequest * message);
	bool deliver_ReadInputRegistersResponse(ModbusTCP_TransportHeader * header, ReadInputRegistersResponse * message);
	bool deliver_WriteSingleCoilRequest(ModbusTCP_TransportHeader * header, WriteSingleCoilRequest * message);
	bool deliver_WriteSingleCoilResponse(ModbusTCP_TransportHeader * header, WriteSingleCoilResponse * message);
	bool deliver_WriteSingleRegisterRequest(ModbusTCP_TransportHeader * header, WriteSingleRegisterRequest * message);
	bool deliver_WriteSingleRegisterResponse(ModbusTCP_TransportHeader * header, WriteSingleRegisterResponse * message);
	bool deliver_WriteMultipleCoilsRequest(ModbusTCP_TransportHeader * header, WriteMultipleCoilsRequest * message);
	bool deliver_WriteMultipleCoilsResponse(ModbusTCP_TransportHeader * header, WriteMultipleCoilsResponse * message);
	bool deliver_WriteMultipleRegistersRequest(ModbusTCP_TransportHeader * header, WriteMultipleRegistersRequest * message);
	bool deliver_WriteMultipleRegistersResponse(ModbusTCP_TransportHeader * header, WriteMultipleRegistersResponse * message);
	bool deliver_ReadFileRecordRequest(ModbusTCP_TransportHeader * header, ReadFileRecordRequest * message);
	bool deliver_ReadFileRecordResponse(ModbusTCP_TransportHeader * header, ReadFileRecordResponse * message);
	bool deliver_WriteFileRecordRequest(ModbusTCP_TransportHeader * header, WriteFileRecordRequest * message);
	bool deliver_WriteFileRecordResponse(ModbusTCP_TransportHeader * header, WriteFileRecordResponse * message);
	bool deliver_MaskWriteRegisterRequest(ModbusTCP_TransportHeader * header, MaskWriteRegisterRequest * message);
	bool deliver_MaskWriteRegisterResponse(ModbusTCP_TransportHeader * header, MaskWriteRegisterResponse * message);
	bool deliver_ReadWriteMultipleRegistersRequest(ModbusTCP_TransportHeader * header, ReadWriteMultipleRegistersRequest * message);
	bool deliver_ReadWriteMultipleRegistersResponse(ModbusTCP_TransportHeader * header, ReadWriteMultipleRegistersResponse * message);
	bool deliver_ReadFIFOQueueRequest(ModbusTCP_TransportHeader * header, ReadFIFOQueueRequest * message);
	bool deliver_ReadFIFOQueueResponse(ModbusTCP_TransportHeader * header, ReadFIFOQueueResponse * message);
	
protected:
	ModbusTCP_PDU * dataunit_;
	ContextModbusTCP * context_;
	FlowBuffer * flow_buffer_;
	ModbusTCP_Conn * connection_;
	bool is_orig_;
};


	VectorVal* bytestring_to_coils(bytestring coils, uint quantity);
	RecordVal* HeaderToBro(ModbusTCP_TransportHeader *header);
	VectorVal* create_vector_of_count();
	
} // namespace ModbusTCP
}  // namespace binpac
#endif /* _home_benjamin_Bro_bro_2_3_1_src_analyzer_protocol_modbus_modbus_pac_h */

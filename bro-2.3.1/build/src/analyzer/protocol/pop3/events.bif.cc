// This file was automatically generated by bifcl from /home/benjamin/Bro/bro-2.3.1/src/analyzer/protocol/pop3/events.bif (plugin mode).


#include "events.bif.h"

EventHandlerPtr pop3_request; 
void BifEvent::generate_pop3_request(analyzer::Analyzer* analyzer, Connection* c, int is_orig, StringVal* command, StringVal* arg)
	{
	// Note that it is intentional that here we do not
	// check if ::pop3_request is NULL, which should happen *before*
	// BifEvent::generate_pop3_request is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(command);
	vl->append(arg);

	mgr.QueueEvent(::pop3_request, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr pop3_reply; 
void BifEvent::generate_pop3_reply(analyzer::Analyzer* analyzer, Connection* c, int is_orig, StringVal* cmd, StringVal* msg)
	{
	// Note that it is intentional that here we do not
	// check if ::pop3_reply is NULL, which should happen *before*
	// BifEvent::generate_pop3_reply is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(cmd);
	vl->append(msg);

	mgr.QueueEvent(::pop3_reply, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr pop3_data; 
void BifEvent::generate_pop3_data(analyzer::Analyzer* analyzer, Connection* c, int is_orig, StringVal* data)
	{
	// Note that it is intentional that here we do not
	// check if ::pop3_data is NULL, which should happen *before*
	// BifEvent::generate_pop3_data is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(data);

	mgr.QueueEvent(::pop3_data, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr pop3_unexpected; 
void BifEvent::generate_pop3_unexpected(analyzer::Analyzer* analyzer, Connection* c, int is_orig, StringVal* msg, StringVal* detail)
	{
	// Note that it is intentional that here we do not
	// check if ::pop3_unexpected is NULL, which should happen *before*
	// BifEvent::generate_pop3_unexpected is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(msg);
	vl->append(detail);

	mgr.QueueEvent(::pop3_unexpected, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr pop3_starttls; 
void BifEvent::generate_pop3_starttls(analyzer::Analyzer* analyzer, Connection* c)
	{
	// Note that it is intentional that here we do not
	// check if ::pop3_starttls is NULL, which should happen *before*
	// BifEvent::generate_pop3_starttls is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());

	mgr.QueueEvent(::pop3_starttls, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr pop3_login_success; 
void BifEvent::generate_pop3_login_success(analyzer::Analyzer* analyzer, Connection* c, int is_orig, StringVal* user, StringVal* password)
	{
	// Note that it is intentional that here we do not
	// check if ::pop3_login_success is NULL, which should happen *before*
	// BifEvent::generate_pop3_login_success is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(user);
	vl->append(password);

	mgr.QueueEvent(::pop3_login_success, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr pop3_login_failure; 
void BifEvent::generate_pop3_login_failure(analyzer::Analyzer* analyzer, Connection* c, int is_orig, StringVal* user, StringVal* password)
	{
	// Note that it is intentional that here we do not
	// check if ::pop3_login_failure is NULL, which should happen *before*
	// BifEvent::generate_pop3_login_failure is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(user);
	vl->append(password);

	mgr.QueueEvent(::pop3_login_failure, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
